<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: Java_Project - SPY 的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SPY 的博客"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SPY 的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="一个热爱技术追求技术的小白"><meta property="og:type" content="blog"><meta property="og:title" content="SPY 的博客"><meta property="og:url" content="https://spy955.github.io/"><meta property="og:site_name" content="SPY 的博客"><meta property="og:description" content="一个热爱技术追求技术的小白"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://spy955.github.io/img/og_image.png"><meta property="article:author" content="Sun Peiyuan"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://spy955.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://Spy955.github.io"},"headline":"SPY 的博客","image":["https://spy955.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Sun Peiyuan"},"publisher":{"@type":"Organization","name":"SPY 的博客","logo":{"@type":"ImageObject","url":"https://spy955.github.io/img/favicon.png"}},"description":"一个热爱技术追求技术的小白"}</script><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.png" alt="SPY 的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Spy955"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Java_Project</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-06-20T05:40:45.000Z" title="2023/6/20 13:40:45">2023-06-20</time>发表</span><span class="level-item"><time dateTime="2023-06-20T05:44:12.469Z" title="2023/6/20 13:44:12">2023-06-20</time>更新</span><span class="level-item">2 小时读完 (大约13760个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/20/Lottery/">Lottery抽奖系统</a></p><div class="content"><h2 id="DAY01："><a href="#DAY01：" class="headerlink" title="DAY01："></a>DAY01：</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>按照小册子搭建环境即可。</p>
<p><strong>注意</strong></p>
<ul>
<li><p>如果使用的数据库是8版本以上，还需要再对配置文件的进行修改</p>
<p>将该模块下的yml配置文件中将driver-class-name 调整为com.mysql.cj.jdbc.Driver ，且因为MySQL8连接要求，必须在连接url后跟上serverTimezone 的配置，即url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;lottery?useUnicode&#x3D;true&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</p>
</li>
</ul>
<h3 id="DDD架构："><a href="#DDD架构：" class="headerlink" title="DDD架构："></a>DDD架构：</h3><p>两篇文章：</p>
<p>美团篇：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html">领域驱动设计在互联网业务开发中的实践 - 美团技术团队 (meituan.com)</a></p>
<p>腾讯篇：<a target="_blank" rel="noopener" href="http://www.yitb.com/article-41463">后台开发进阶：白话DDD从入门到实践 - 元宇宙 (yitb.com)</a></p>
<h3 id="RPC："><a href="#RPC：" class="headerlink" title="RPC："></a>RPC：</h3><p>之前的学习以及做的项目都是一个单体项目，也就是用户直接通过X来调用A应用，然后来实现自己的需求。但是这样的系统结构在面对一些高并发的场景时，会由于流量过多而发生异常。因此引入了扩容，即一个RPC对应一个应用的实例，当流量进入的时候，可以将流量分散开，从而保证系统正常运行。</p>
<p><img src="/2023/06/20/Lottery/image-20230425143855347.png" alt="image-20230425143855347"></p>
<p>一般RPC的结构实现：</p>
<p><img src="/2023/06/20/Lottery/image-20230425153013662.png" alt="image-20230425153013662"></p>
<h3 id="pom文件修改："><a href="#pom文件修改：" class="headerlink" title="pom文件修改："></a>pom文件修改：</h3><p>如果将所有的依赖都添加在父工程的pom文件中，那么就会导致子工程在加载时会引入所有父工程的依赖，因此父工程只定义springboot和jdk版本的依赖。</p>
<p>关于pom文件中两种build的理解：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fz13768884254/article/details/85088616">(5条消息) POM.XML的build标签中resources标签_狂丰的博客-CSDN博客</a></p>
<h3 id="今日总结："><a href="#今日总结：" class="headerlink" title="今日总结："></a>今日总结：</h3><ul>
<li><p>今天按照小傅哥的册子跑通了广播模式RPC过程调用，过程可谓一波三折，总结以下几个问题：</p>
<ul>
<li><p>首先在引入小傅哥的文件时，要修改相关的配置以及引用</p>
</li>
<li><p>在修改数据库版本的时候，要注意修改配置文件中的url和driver-class-name</p>
</li>
<li><p>注意每一个模块对其他模块的调用以及打包方式（只有interfaces层采用war包）</p>
</li>
<li><p>注意@Service是Dubbo中的注解而不是引用Spring中的</p>
<p><img src="/2023/06/20/Lottery/image-20230425202627877.png" alt="image-20230425202627877"></p>
</li>
<li><p>刚开始不知道为什么报错，后来又莫名其妙好了，这个我还没有想明白</p>
</li>
<li><p>注意在进行单元测试的时候，首先要向数据库添加数据，否则会报错</p>
</li>
</ul>
</li>
</ul>
<h3 id="明日计划："><a href="#明日计划：" class="headerlink" title="明日计划："></a>明日计划：</h3><ul>
<li>将第三节的代码自己编写一遍</li>
<li>学习一个简单的Dubbo项目</li>
</ul>
<h2 id="DAY02："><a href="#DAY02：" class="headerlink" title="DAY02："></a>DAY02：</h2><p>今日工作：</p>
<ul>
<li>重新编写DAY01的代码并提交到代码库中</li>
<li>整理代码框架</li>
<li>对整个框架以及DDD结构有了全新的理解</li>
</ul>
<p><img src="/2023/06/20/Lottery/image-20230426142933613.png" alt="image-20230426142933613"></p>
<h3 id="DDD架构的个人理解"><a href="#DDD架构的个人理解" class="headerlink" title="DDD架构的个人理解"></a>DDD架构的个人理解</h3><p>如果是一个单体项目采用DDD结构，那么RPC层不存在，剩余的层：</p>
<ul>
<li>interface层：接口层，负责接收前端发给的请求并且进行处理，然后调用应用层的方法来实现请求并且将结果返回给前端</li>
<li>application层：应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装</li>
<li>domain层：领域层，负责核心业务代码的编写</li>
<li>infrastructure层：为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响</li>
</ul>
<p>如果是分布式项目：</p>
<ul>
<li>RPC层：作用是提供远程调用接口</li>
</ul>
<h3 id="PO、VO、DO、DTO的对比"><a href="#PO、VO、DO、DTO的对比" class="headerlink" title="PO、VO、DO、DTO的对比"></a>PO、VO、DO、DTO的对比</h3><p>参考自小傅哥：</p>
<p>PO：persistent object 持久对象</p>
<ul>
<li>有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。（一般存放在infrastructure层中，如上图中的Activity）</li>
<li>在Mybatis持久化框架中与insert&#x2F;delet操作密切相关。</li>
<li>PO中不应该包含任何对数据库的操作。</li>
</ul>
<p>POJO ：plain ordinary java object 无规则简单java对象</p>
<p>VO：value object 值对象 &#x2F; view object 表现层对象（一般放在domain层中）</p>
<ul>
<li>主要对应页面显示（web页面&#x2F;swt、swing界面）的数据对象。</li>
<li>可以和表对应，也可以不，这根据业务的需要。</li>
<li>可以细分包括 req、res（请求时的实体类、返回的实体类）</li>
</ul>
<p>DO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。通常可以代替部分 PO 的职责。</p>
<p>DTO（TO）：Data Transfer Object 数据传输对象</p>
<ul>
<li>用在需要跨进程或远程传输时，它不应该包含业务逻辑。</li>
<li>比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</li>
</ul>
<h2 id="DAY03："><a href="#DAY03：" class="headerlink" title="DAY03："></a>DAY03：</h2><h3 id="抽奖活动策略表设计"><a href="#抽奖活动策略表设计" class="headerlink" title="抽奖活动策略表设计"></a>抽奖活动策略表设计</h3><ul>
<li><p>抽奖活动策略表设计</p>
<p><img src="/2023/06/20/Lottery/image-20230427134258197.png" alt="image-20230427134258197"></p>
</li>
</ul>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p><strong>分表的意义：</strong></p>
<ul>
<li>MySQL数据库采用B+树来进行数据的存储和查找，如果数据量太大的话，SQL查询效率就会变低。如果一个查询SQL没有命中，那么就回去在海量数据中进行查找，从而影响性能甚至崩溃。</li>
<li>就算是命中，但是如果数据过多，比如千万级别。那么B+树就会变高，从而影响查询。</li>
</ul>
<p>B+树工作原理：</p>
<ul>
<li>InnoDB存储引擎最小单元是页，一页大小就是16KB，B+树叶子节点存储的是索引和数据(针对主键而言)内部节点存储的是键值和指针。</li>
<li>索引组织表通过非叶子节点的二分查找法以及指针确定数据具体在哪个页里，再从数据页中寻找需要的数据。</li>
<li>假设B+树高度是2，(根节点占一格高度，和若干叶子节点)。这颗B+树存放的总记录数 &#x3D; 根节点指针数 * 单个叶子节点记录行数</li>
<li>如果一行记录数的数据是1k，那么叶子节点 (单个)能存储的数据量就是 16k &#x2F; k &#x3D; 16</li>
<li>非叶子节点内存放多少指针呢？我们假设主键ID为bigint类型，长度为8字节(面试官问你int类型，一个int就是32位，4字节)，而指针大小在InnoDB源码中设置为6字节，所以就是 8+6&#x3D;14 字节，16k &#x2F;14B &#x3D; 16 * 1024B &#x2F;14B &#x3D;1170</li>
<li>因此，一棵高度为2的B+树，能存放1170（第一层的索引数量） * 16（第二层每一个索引指向的数量）&#x3D;18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 &#x3D;21902400，大概可以存放两千万左右的记录。B+树高度一般为1-3层，如果B+到了4层，查询的时候会多查磁盘的次数（即磁盘IO），SQL就会变慢。</li>
<li>如果说不进行分表，那么一行记录数的数据就会变大，单个叶子结点储存的信息数量就会减少，就会导致B+树高度变大</li>
</ul>
<p><strong>分库的意义：</strong><br>在本业务中，用户参与活动记录和次数，用户是否中奖，中奖信息需要分库</p>
<ul>
<li>本身这些操作，属于是非常非常高频的一些操作，如果业务量剧增，数据库可能会出现性能瓶颈，这时候我们就需要考虑拆分数据库。从这几方面来看<ul>
<li>磁盘存储<br>业务量剧增，MySOL单机磁盘容量会撑爆，拆成多个数据库，磁盘使用率大大降低</li>
<li>并发连接支撑<br>数据库的连接是有限的，在高并发场景下，大量请求访问数据库，MySQL单机无法承受，因此我们的项目采用微服务架构，通过将订单，用户，商品等不同模块都拆分成一个domain。并且将单个数据库也拆分成多个不同功能模块的数据库，或者是相同功能，放在多个库里分摊连接请求。 (同时可以采用缓存架构来降低访问)</li>
</ul>
</li>
</ul>
<p><strong>分库分表的意义</strong>：</p>
<ul>
<li>解决连接数瓶颈，解决数据增量，通常数据存量200万-300万，增量在单表50万就要考虑拆表了 (一开始可能很小，都设计成分库分表)因为拆分的库大多都是虚拟机上的，不会对服务器资源造成太大浪费，后续数量增多时，再迁徙物理机。</li>
<li>分库分表之后，数据分散，通过路由规则和负载均衡策略保证请求均衡打在不同库表上，不用担心会集中打在某个库表上造成数据库瘫痪。</li>
<li>本质上为:减少数据库压力，提高数据库效率，缩短查询时间</li>
</ul>
<p><strong>总结：</strong></p>
<p>分库：解决qps过高，连接数不够用</p>
<p>分表：解决数据量过大，查询效率不高</p>
<p>分库分表：解决qps过高和查询效率不高</p>
<h3 id="抽奖策略开发"><a href="#抽奖策略开发" class="headerlink" title="抽奖策略开发"></a>抽奖策略开发</h3><h4 id="抽奖策略分类："><a href="#抽奖策略分类：" class="headerlink" title="抽奖策略分类："></a>抽奖策略分类：</h4><p>场景：奖品A B C的中奖概率分别为：50%、30%、20%</p>
<ul>
<li>总体概率：如果说A奖品被抽完了，那么B、C的中奖概率分别为60%和40%</li>
<li>单项概率：如果A奖品抽空后，B和C保持目前中奖概率，用户抽奖扔有20%中为A，因A库存抽空则结果展示为未中奖。<em>为了运营成本，通常这种情况的使用的比较多</em></li>
</ul>
<p>在库表设计上我们把抽奖需要的策略配置和策略明细，它们的关系是<code>1vn</code>。</p>
<h4 id="DDD架构：-1"><a href="#DDD架构：-1" class="headerlink" title="DDD架构："></a>DDD架构：</h4><p><img src="/2023/06/20/Lottery/5-02.png" alt="image-20230427134258197"></p>
<ul>
<li>model，用于提供vo、req、res 和 aggregates 聚合对象。</li>
<li>repository，提供仓储服务，其实也就是对Mysql、Redis等数据的统一包装。后面的话只在domain编写接口，实现类放到infrastructure层中。</li>
<li>service，是具体的业务领域逻辑实现层，在这个包下定义了algorithm抽奖算法实现和具体的抽奖策略包装 draw 层，对外提供抽奖接口。</li>
</ul>
<h4 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h4><h5 id="总体概率："><a href="#总体概率：" class="headerlink" title="总体概率："></a><strong>总体概率</strong>：</h5><p>分别把A、B、C对应的概率值转换成阶梯范围值，A&#x3D;(0~0.2」、B&#x3D;(0.2-0.5」、C&#x3D;(0.5-1.0」，当使用随机数方法生成一个随机数后，与阶梯范围值进行循环比对找到对应的区域，匹配到中奖结果。</p>
<p><strong>实现过程</strong>：</p>
<ul>
<li>首先要从总的中奖列表中排除掉那些被排除掉的奖品，这些奖品会涉及到概率的值重新计算。</li>
<li>如果排除后剩下的奖品列表小于等于1，则可以直接返回对应信息</li>
<li>接下来就使用随机数工具生产一个100内的随值与奖品列表中的值进行循环比对，算法时间复杂度O(n)</li>
</ul>
<img src="/2023/06/20/Lottery/image-20230427161311046.png" alt="image-20230427161311046" style="zoom:50%;">

<h5 id="单项概率："><a href="#单项概率：" class="headerlink" title="单项概率："></a>单项概率：</h5><p><strong>算法描述</strong>：单项概率算法不涉及奖品概率重新计算的问题，那么也就是说我们分配好的概率结果是可以固定下来的。好，这里就有一个可以优化的算法，不需要在轮训匹配O(n)时间复杂度来处理中奖信息，而是可以根据概率值存放到HashMap或者自定义散列数组进行存放结果，这样就可以根据概率值直接定义中奖结果，时间复杂度由O(n)降低到O(1)。这样的设计在一般电商大促并发较高的情况下，达到优化接口响应时间的目的。也就是说，现在只需要根据索引值来查找相对应的索引即可。</p>
<img src="/2023/06/20/Lottery/image-20230427162247157.png" alt="image-20230427162247157" style="zoom:50%;">

<p>对于流程的分析，等代码开发完成之后进行总结。</p>
<h3 id="今日总结：-1"><a href="#今日总结：-1" class="headerlink" title="今日总结："></a>今日总结：</h3><ul>
<li>完成抽奖活动策略表的设计与理解</li>
<li>学习分库分表的意义，以及数据库存储方式的B+树</li>
<li>学习第05节的视频和小册，并且理清楚相关的类</li>
</ul>
<h2 id="DAY04："><a href="#DAY04：" class="headerlink" title="DAY04："></a>DAY04：</h2><h3 id="今日任务："><a href="#今日任务：" class="headerlink" title="今日任务："></a>今日任务：</h3><ul>
<li>代码撰写，将第05节代码进行编写</li>
<li>整理今天学到的知识，完成小傅哥的作业</li>
</ul>
<h3 id="梳理交互过程"><a href="#梳理交互过程" class="headerlink" title="梳理交互过程"></a>梳理交互过程</h3><h4 id="算法模块"><a href="#算法模块" class="headerlink" title="算法模块"></a>算法模块</h4><img src="/2023/06/20/Lottery/image-20230428151200307.png" alt="image-20230428151200307" style="zoom:50%;">

<p><strong>梳理流程：</strong></p>
<p>（1）首先定义一个接口：IDrawAlgorithm，其中有三个方法</p>
<ul>
<li><pre><code>initRateTuple(Long strategyId, List&lt;AwardRateInfo&gt; awardRateInfoList)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  定义了一个初始化的方法，也就是将每一个奖品都放置到100斐波那契散列之中，如下图这样</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;Lottery/image-20230428151915087.png&quot; alt=&quot;image-20230428151915087&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  isExistRateTuple</span><br></pre></td></tr></table></figure>

判断是否已经，做了数据初始化
</code></pre>
</li>
<li><p>&#96;&#96;&#96;<br>randomDraw</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  生成随机数，索引到对应的奖品信息返回结果，该方法在基础算法中不进行实现，在实际落地的算法中才加以实现</span><br><span class="line"></span><br><span class="line">（2）编写基础算法实现类BaseAlgorithm，并且重写initRateTuple和isExistRateTuple方法，还有hashIdx方法</span><br><span class="line"></span><br><span class="line">在这里先补一下关于斐波那契散列的相关知识</span><br><span class="line"></span><br><span class="line">- 哈希算法：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  keyIndex = ((value + 1) * HASH_INCREMENT) &amp; (length - 1);</span><br><span class="line">  //斐波那契（Fibonacci）散列法，计算哈希索引下标值；将100个奖品映射到128个空格中</span><br><span class="line">  //HASH_INCREMENT是常量0x61c88647；length表示数组初始化的长度，就是要定义多长的数组来放置100个奖品</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>算法实现：</strong></p>
<ul>
<li>首先定义相关的成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契散列增量，逻辑：黄金分割点：(√5 - 1) / 2 = 0.6180339887，Math.pow(2, 32) * 0.6180339887 = 0x61c88647</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组初始化长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RATE_TUPLE_LENGTH</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放概率与奖品对应的散列结果，strategyId -&gt; rateTuple(数组长度为128，用来存放奖品的id)</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;Long, String[]&gt; rateTupleMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 奖品区间概率值，strategyId -&gt; [awardId-&gt;begin、awardId-&gt;end](这个成员变量用于后面总体概率法的时候重新计算概率使用)</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;Long, List&lt;AwardRateInfo&gt;&gt; awardRateInfoMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>initRateTuple算法实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRateTuple</span><span class="params">(Long strategyId, List&lt;AwardRateInfo&gt; awardRateInfoList)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存奖品概率信息</span></span><br><span class="line">    awardRateInfoMap.put(strategyId, awardRateInfoList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建奖品对应的斐波那契散列表   computeIfAbsent：如果没有就创建</span></span><br><span class="line">    String[] rateTuple = rateTupleMap.computeIfAbsent(strategyId, k -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[RATE_TUPLE_LENGTH]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cursorVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//按照概率，取出中奖概率对应的长度，即如果概率为0.2，那么rateVal为20</span></span><br><span class="line">    <span class="keyword">for</span> (AwardRateInfo awardRateInfo : awardRateInfoList) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rateVal</span> <span class="operator">=</span> awardRateInfo.getAwardRate().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">100</span>)).intValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环填充概率范围值</span></span><br><span class="line">        <span class="comment">// 计算hashindex来将对应位置填充为相应的AwardId</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursorVal + <span class="number">1</span>; i &lt;= (rateVal + cursorVal); i++) &#123;</span><br><span class="line">            rateTuple[hashIdx(i)] = awardRateInfo.getAwardId();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cursorVal += rateVal;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写isExistRateTuple</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExistRateTuple</span><span class="params">(Long strategyId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rateTupleMap.containsKey(strategyId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>斐波那契散列法计算哈希索引下标值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契（Fibonacci）散列法，计算哈希索引下标值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">hashIdx</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> val * HASH_INCREMENT + HASH_INCREMENT;</span><br><span class="line">    <span class="keyword">return</span> hashCode &amp; (RATE_TUPLE_LENGTH - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）编写单体概率实现方法（抽到库存为0的直接显示未中奖）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;singleRateRandomDrawAlgorithm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleRateRandomDrawAlgorithm</span> <span class="keyword">extends</span> <span class="title class_">BaseAlgorithm</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">randomDraw</span><span class="params">(Long strategyId, List&lt;String&gt; excludeAwardIds)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取策略对应的元祖</span></span><br><span class="line">        String[] rateTuple = <span class="built_in">super</span>.rateTupleMap.get(strategyId);</span><br><span class="line">        <span class="keyword">assert</span> rateTuple != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomVal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>().nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="built_in">super</span>.hashIdx(randomVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">awardId</span> <span class="operator">=</span> rateTuple[idx];</span><br><span class="line">        <span class="comment">// 库存为0则未中奖</span></span><br><span class="line">        <span class="keyword">if</span> (excludeAwardIds.contains(awardId)) <span class="keyword">return</span> <span class="string">&quot;未中奖&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> awardId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecureRandom方法与Random方法的区别是：</p>
<ul>
<li><code>SecureRandom</code> 提供加密的强随机数生成器 (RNG)，要求种子必须是<strong>不可预知</strong>的，产生<strong>非确定性</strong>输出。</li>
<li>个人认为是产生相同的概率会减小</li>
</ul>
<p>（4）编写总体概率实现方法（必中奖策略抽奖，排掉已经中奖的概率，重新计算中奖范围）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;defaultRateRandomDrawAlgorithm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultRateRandomDrawAlgorithm</span> <span class="keyword">extends</span> <span class="title class_">BaseAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">randomDraw</span><span class="params">(Long strategyId, List&lt;String&gt; excludeAwardIds)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时场上还存在的中奖概率（如果场上产品只有A：0.2和B：0.5，则这个值为0.7，用于重新计算概率作为被除数）</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">differenceDenominator</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排除掉不在抽奖范围的奖品ID集合</span></span><br><span class="line">        List&lt;AwardRateInfo&gt; differenceAwardRateList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;AwardRateInfo&gt; awardRateIntervalValList = awardRateInfoMap.get(strategyId);</span><br><span class="line">        <span class="keyword">for</span> (AwardRateInfo awardRateInfo : awardRateIntervalValList) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">awardId</span> <span class="operator">=</span> awardRateInfo.getAwardId();</span><br><span class="line">            <span class="keyword">if</span> (excludeAwardIds.contains(awardId)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            differenceAwardRateList.add(awardRateInfo);</span><br><span class="line">            differenceDenominator = differenceDenominator.add(awardRateInfo.getAwardRate());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置判断</span></span><br><span class="line">        <span class="keyword">if</span> (differenceAwardRateList.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (differenceAwardRateList.size() == <span class="number">1</span>) <span class="keyword">return</span> differenceAwardRateList.get(<span class="number">0</span>).getAwardId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取随机概率值</span></span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">secureRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomVal</span> <span class="operator">=</span> secureRandom.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环获取奖品</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">awardId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cursorVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (AwardRateInfo awardRateInfo : differenceAwardRateList) &#123;</span><br><span class="line">            <span class="comment">// awardRateInfo.getAwardRate() / differenceDenominator</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rateVal</span> <span class="operator">=</span> awardRateInfo.getAwardRate().divide(differenceDenominator, <span class="number">2</span>, BigDecimal.ROUND_UP).multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">100</span>)).intValue();</span><br><span class="line">            <span class="keyword">if</span> (randomVal &lt;= (cursorVal + rateVal)) &#123;</span><br><span class="line">                awardId = awardRateInfo.getAwardId();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursorVal += rateVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回中奖结果</span></span><br><span class="line">        <span class="keyword">return</span> awardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法实现模块"><a href="#算法实现模块" class="headerlink" title="算法实现模块"></a>算法实现模块</h4><p><strong>实现流程</strong>（抽奖实现接口）</p>
<img src="/2023/06/20/Lottery/image-20230428172417519.png" alt="image-20230428172417519" style="zoom:50%;">

<p>（1）DrawConfig（提供一个配置类，将两种策略进行封装）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IDrawAlgorithm defaultRateRandomDrawAlgorithm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IDrawAlgorithm singleRateRandomDrawAlgorithm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Map&lt;Integer, IDrawAlgorithm&gt; drawAlgorithmMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAlgorithmMap.put(<span class="number">1</span>, defaultRateRandomDrawAlgorithm);</span><br><span class="line">        drawAlgorithmMap.put(<span class="number">2</span>, singleRateRandomDrawAlgorithm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解析<code>@PostConstruct</code> ： </p>
<p>@PostConstruct该注解被用来修饰一个非静态的 void() 方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。@PostConstruct在构造函数之后执行，init() 方法之前执行。</p>
</li>
<li><p>该注解的方法在整个Bean初始化中的执行顺序：</p>
<p>Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)</p>
</li>
<li><p>使用该注解可以保证在init()之前将@Resource注解的对象已经注入</p>
</li>
</ul>
<p>（2）DrawBase</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawBase</span> <span class="keyword">extends</span> <span class="title class_">DrawConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndInitRateData</span><span class="params">(Long strategyId, Integer strategyMode, List&lt;StrategyDetail&gt; strategyDetailList)</span> &#123;</span><br><span class="line">        <span class="comment">// 表示策略1需要进行初始化；策略2不需要下面的初始化过程</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> != strategyMode) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">IDrawAlgorithm</span> <span class="variable">drawAlgorithm</span> <span class="operator">=</span> drawAlgorithmMap.get(strategyMode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">existRateTuple</span> <span class="operator">=</span> drawAlgorithm.isExistRateTuple(strategyId);</span><br><span class="line">        <span class="keyword">if</span> (existRateTuple) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;AwardRateInfo&gt; awardRateInfoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(strategyDetailList.size());</span><br><span class="line">        <span class="keyword">for</span> (StrategyDetail strategyDetail : strategyDetailList) &#123;</span><br><span class="line">            awardRateInfoList.add(<span class="keyword">new</span> <span class="title class_">AwardRateInfo</span>(strategyDetail.getAwardId(), strategyDetail.getAwardRate()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        drawAlgorithm.initRateTuple(strategyId, awardRateInfoList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）IDrawExec</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDrawExec</span> &#123;</span><br><span class="line"></span><br><span class="line">    DrawResult <span class="title function_">doDrawExec</span><span class="params">(DrawReq req)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供一个方法接口</p>
<p>（4）DrawExecImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;drawExec&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawExecImpl</span> <span class="keyword">extends</span> <span class="title class_">DrawBase</span> <span class="keyword">implements</span> <span class="title class_">IDrawExec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(DrawExecImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IStrategyRepository strategyRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DrawResult <span class="title function_">doDrawExec</span><span class="params">(DrawReq req)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;执行策略抽奖开始，strategyId：&#123;&#125;&quot;</span>, req.getStrategyId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取抽奖策略配置数据</span></span><br><span class="line">        <span class="type">StrategyRich</span> <span class="variable">strategyRich</span> <span class="operator">=</span> strategyRepository.queryStrategyRich(req.getStrategyId());</span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> strategyRich.getStrategy();</span><br><span class="line">        List&lt;StrategyDetail&gt; strategyDetailList = strategyRich.getStrategyDetailList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验和初始化数据</span></span><br><span class="line">        checkAndInitRateData(req.getStrategyId(), strategy.getStrategyMode(), strategyDetailList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据策略方式抽奖</span></span><br><span class="line">        <span class="type">IDrawAlgorithm</span> <span class="variable">drawAlgorithm</span> <span class="operator">=</span> drawAlgorithmMap.get(strategy.getStrategyMode());</span><br><span class="line">        <span class="type">String</span> <span class="variable">awardId</span> <span class="operator">=</span> drawAlgorithm.randomDraw(req.getStrategyId(), <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取奖品信息</span></span><br><span class="line">        <span class="type">Award</span> <span class="variable">award</span> <span class="operator">=</span> strategyRepository.queryAwardInfo(awardId);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;执行策略抽奖完成，中奖用户：&#123;&#125; 奖品ID：&#123;&#125; 奖品名称：&#123;&#125;&quot;</span>, req.getuId(), awardId, award.getAwardName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DrawResult</span>(req.getuId(), req.getStrategyId(), awardId, award.getAwardName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽奖策略的实现</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>略</p>
<p><strong>注意：</strong></p>
<p>除了上面核心业务的开发以外，还有一些实体类和一些mapper方法需要编写</p>
<h3 id="编写相关代码"><a href="#编写相关代码" class="headerlink" title="编写相关代码"></a>编写相关代码</h3><p>第一遍先仿照小傅哥的代码进行编写</p>
<h2 id="DAY05"><a href="#DAY05" class="headerlink" title="DAY05:"></a>DAY05:</h2><h3 id="今日计划："><a href="#今日计划：" class="headerlink" title="今日计划："></a>今日计划：</h3><ul>
<li>完成代码编写与测试</li>
</ul>
<h3 id="处理BUG："><a href="#处理BUG：" class="headerlink" title="处理BUG："></a>处理BUG：</h3><p>在按照上面的算法流程编写相应的代码，在测试的时候遇到了以下问题</p>
<p>首先在小傅哥的代码中，创建数据库和xml中查询都是直接命名为驼峰的，但是在我的代码中，并没有使用这种方式。而是使用的下划线方式来命名数据库列表的，因此造成了第一个问题就是找不到相关的列</p>
<p><img src="/2023/06/20/Lottery/image-20230430222555897.png" alt="image-20230430222555897"></p>
<p>当我把查询改为下划线格式的时候，发现始终只能查询到id，其他属性全都没有，这是由于mybatis没有配置驼峰映射，采取的第一种方式是在applicat.yml配置文件中加上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">    configuration:</span><br><span class="line">        map-underscore-to-camel-case: true</span><br></pre></td></tr></table></figure>

<p>结果报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together</span><br></pre></td></tr></table></figure>

<p>也就是上面的配置不能和下面的配置一起声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:/mybatis/mapper/*.xml</span><br><span class="line">  config-location: classpath:/mybatis/config/mybatis-config.xml</span><br></pre></td></tr></table></figure>

<p>因此采取resultMap方式来进行配置，在每一个xml查询中都插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;strategyDetailMap&quot; type=&quot;cn.spy.lottery.infrastructure.po.StrategyDetail&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;strategy_id&quot; property=&quot;strategyId&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;award_id&quot; property=&quot;awardId&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;award_count&quot; property=&quot;awardCount&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;award_rate&quot; property=&quot;awardRate&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<p>然后将下面的查询中的resultType改为resultMap的id即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;queryStrategyDetailList&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;strategyDetailMap&quot;&gt;</span><br><span class="line">    SELECT id, strategy_id, award_id, award_count, award_rate, create_time, update_time</span><br><span class="line">    FROM strategy_detail</span><br><span class="line">    WHERE strategy_id = #&#123;strategyId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>这个问题改了很久，在这期间学会使用debug来不断进行排错，然后也要将自己的疑惑来及时百度来改正</p>
<h2 id="DAY06"><a href="#DAY06" class="headerlink" title="DAY06:"></a>DAY06:</h2><ul>
<li>将之前的算法以及调用流程使用模板模式处理</li>
</ul>
<h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><p>将配置类中的常量封装到常量枚举类之中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	drawAlgorithmMap.put(Constants.StrategyMode.ENTIRETY.getCode(), defaultRateRandomDrawAlgorithm);</span><br><span class="line">	drawAlgorithmMap.put(Constants.StrategyMode.SINGLE.getCode(), singleRateRandomDrawAlgorithm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<p>使用这种方式不仅可以让后面的人更好的读懂代码，也可以方便以后加相关的策略</p>
<h4 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h4><p><img src="/2023/06/20/Lottery/image-20230504132629338.png" alt="image-20230504132629338"></p>
<h4 id="核心部分："><a href="#核心部分：" class="headerlink" title="核心部分："></a>核心部分：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DrawResult <span class="title function_">doDrawExec</span><span class="params">(DrawReq req)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取抽奖策略</span></span><br><span class="line">    <span class="type">StrategyRich</span> <span class="variable">strategyRich</span> <span class="operator">=</span> strategyRepository.queryStrategyRich(req.getStrategyId());</span><br><span class="line">    <span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> strategyRich.getStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.校验和初始化数据</span></span><br><span class="line">    checkAndInitRateData(req.getStrategyId(), strategy.getStrategyMode(), strategyRich.getStrategyDetailList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.获取不在抽奖范围内的列表，包括：奖品库存为空、风控风险、临时调整等</span></span><br><span class="line">    List&lt;String&gt; excludeAwardIds = <span class="built_in">this</span>.queryExcludeAwardIds(strategy.getStrategyId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.根据策略方式抽奖</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">awardId</span> <span class="operator">=</span> <span class="built_in">this</span>.drawAlgorithm(req.getStrategyId(), drawAlgorithmMap.get(strategy.getStrategyMode()), excludeAwardIds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 包装中奖结果</span></span><br><span class="line">    <span class="keyword">return</span> buildDrawResult(req.getuId(), req.getStrategyId(), awardId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模板模式就是要让过程尽可能的简洁明了，每一步都有固定的作用，关于每一步的实现逻辑方法封装到其他方法中进行实现。</li>
<li>对于不一样的部分在实现类中进行实现，相同的部分，比如结果封装则在抽象类中就加以实现</li>
</ul>
<h3 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h3><p>在写完代码使用单元测试进行代码调试的时候，为了测试库存不足时的返回情况，将库存都设置为0，遇到了这个问题</p>
<p><img src="/2023/06/20/Lottery/image-20230504144430275.png" alt="image-20230504144430275"></p>
<p>即Truncated incorrect DOUBLE value：类型不匹配问题</p>
<p>问题根源是，在单项概率实现策略里面</p>
<p><img src="/2023/06/20/Lottery/image-20230504144536461.png" alt="image-20230504144536461"></p>
<p>返回值为一个字符串，返回值类型有错误，应该返回null</p>
<p><img src="/2023/06/20/Lottery/image-20230504144638024.png" alt="image-20230504144638024"></p>
<p>此时测试通过</p>
<h3 id="其它补充："><a href="#其它补充：" class="headerlink" title="其它补充："></a>其它补充：</h3><p>dependencies和dependencymanagement的区别：</p>
<ul>
<li>Dependencies相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。</li>
<li>dependencyManagement里只是声明依赖，并不自动实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</li>
</ul>
<h2 id="DAY07："><a href="#DAY07：" class="headerlink" title="DAY07："></a>DAY07：</h2><h3 id="今日计划：-1"><a href="#今日计划：-1" class="headerlink" title="今日计划："></a>今日计划：</h3><ul>
<li>按照 Mysql 库表使用规范调整表字段名称，如 <code>activityId</code> 调整为 <code>activity_id</code>，注意修改字符集类型</li>
<li>继续按照 P3C 标准，在 IDEA 插件 <code>Alibaba Java Coding Guidelines</code> 提醒下，修改所有涉及到的领域层、基础层中类、方法、字段的注释信息。</li>
<li>运用简单工厂设计模式，搭建发奖领域服务。介绍：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li>
</ul>
<h3 id="工厂模式："><a href="#工厂模式：" class="headerlink" title="工厂模式："></a>工厂模式：</h3><p>如果在代码中，使用if-else来控制使用哪种策略，这是一种方法，但是如果策略很多，在后期修改维护的时候会带来很大的不方便，很有可能会牵一发而动全身。因此尽可能使用设计模式来代替if-else，让每一个类都有自己的职责来进行业务处理。</p>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="/2023/06/20/Lottery/image-20230505173514660.png" alt="image-20230505173514660"></p>
<h3 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h3><p>在测试中最初存在NPE的Bug，排查原因是发现，GoodsConfig这个配置类上面没有加入注解：@Configuration，也就表示在使用实现类的时候还未将GoodsConfig注入到容器中。两种解决方式：</p>
<ul>
<li>在配置类上面加入注解@Configuration</li>
<li>在实现类集成GoodsConfig</li>
</ul>
<h2 id="Day08："><a href="#Day08：" class="headerlink" title="Day08："></a>Day08：</h2><p>之前由于小论文进度较慢，今天开始赶进度</p>
<h3 id="今日计划：-2"><a href="#今日计划：-2" class="headerlink" title="今日计划："></a>今日计划：</h3><ul>
<li>完成Lottery8节——活动领域的配置与状态模式</li>
</ul>
<h3 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h3><h4 id="1-调整依赖"><a href="#1-调整依赖" class="headerlink" title="1. 调整依赖"></a>1. 调整依赖</h4><ol>
<li><p>之前我们使用domain层调用infrastructure层，将仓储服务接口和实现都放在了领域层。现在我们要将infrastructure引入domain从而将仓储服务的实现放在infrastructure层，只在domain保留接口，从而符合规范。</p>
<ul>
<li><p>记得要将原来的依赖注释掉</p>
</li>
<li><p>此时许多domain层的依赖丢失，解决办法是在domain中的model模块引入每一个service需要的实体类</p>
<p><img src="/2023/06/20/Lottery/image-20230511112225187.png" alt="image-20230511112225187"></p>
</li>
</ul>
</li>
<li><p>在domain层引入spring-tx依赖，开启事务管理</p>
</li>
</ol>
<h4 id="2-梳理流程"><a href="#2-梳理流程" class="headerlink" title="2. 梳理流程"></a>2. 梳理流程</h4><h5 id="2-1-1-活动部署模块"><a href="#2-1-1-活动部署模块" class="headerlink" title="2.1.1 活动部署模块"></a>2.1.1 活动部署模块</h5><p>只有一个简单的接口与实现</p>
<p>其中接口实现方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityDeploy</span> <span class="keyword">implements</span> <span class="title class_">IActivityDeploy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ActivityDeploy.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IActivityRepository activityRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createActivity</span><span class="params">(ActivityConfigReq req)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;创建活动配置开始，activityId：&#123;&#125;&quot;</span>, req.getActivityId());</span><br><span class="line">        <span class="type">ActivityConfigRich</span> <span class="variable">activityConfigRich</span> <span class="operator">=</span> req.getActivityConfigRich();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 添加活动配置</span></span><br><span class="line">            <span class="type">ActivityVO</span> <span class="variable">activity</span> <span class="operator">=</span> activityConfigRich.getActivity();</span><br><span class="line">            activityRepository.addActivity(activity);</span><br><span class="line">            <span class="comment">// 添加奖品配置</span></span><br><span class="line">            List&lt;AwardVO&gt; awardList = activityConfigRich.getAwardList();</span><br><span class="line">            activityRepository.addAward(awardList);</span><br><span class="line">            <span class="comment">// 添加策略配置</span></span><br><span class="line">            <span class="type">StrategyVO</span> <span class="variable">strategy</span> <span class="operator">=</span> activityConfigRich.getStrategy();</span><br><span class="line">            activityRepository.addStrategy(strategy);</span><br><span class="line">            <span class="comment">// 添加策略明细配置</span></span><br><span class="line">            List&lt;StrategyDetailVO&gt; strategyDetailList = activityConfigRich.getStrategy().getStrategyDetailList();</span><br><span class="line">            activityRepository.addStrategyDetailList(strategyDetailList);</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">&quot;创建活动配置完成，activityId：&#123;&#125;&quot;</span>, req.getActivityId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;创建活动配置失败，唯一索引冲突 activityId：&#123;&#125; reqJson：&#123;&#125;&quot;</span>, req.getActivityId(), JSON.toJSONString(req), e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateActivity</span><span class="params">(ActivityConfigReq req)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 后期开发相关功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要在dao和mapper中编写相应的添加语句</li>
<li>添加活动配置、添加奖品配置、添加策略配置、添加策略明细配置在一个事务中，所以加一个@Transactional注解</li>
</ul>
<h5 id="2-2-2-状态变更模块"><a href="#2-2-2-状态变更模块" class="headerlink" title="2.2.2 状态变更模块"></a>2.2.2 状态变更模块</h5><p><img src="/2023/06/20/Lottery/image-20230511161650654.png" alt="image-20230511161650654"></p>
<p>对于这七种状态模式以及对应的方法，根据以下规则：</p>
<img src="/2023/06/20/Lottery/image-20230511162042693.png" alt="image-20230511162042693" style="zoom:50%;">

<p>也可以看这张星友总结的：</p>
<img src="/2023/06/20/Lottery/image-20230511163025069.png" alt="image-20230511163025069" style="zoom:33%;">

<p>使用设计模式中的状态模式，优化掉原本需要在各个流程节点中的转换使用 ifelse 的场景，这样操作以后也可以更加方便进行扩展。<em>当然其实这里还可以使用如工作流的方式进行处理</em></p>
<h4 id="3-单元测试"><a href="#3-单元测试" class="headerlink" title="3. 单元测试"></a>3. 单元测试</h4><p>遇到的BUG：</p>
<ul>
<li>首先是有两个@Service注解忘记加报的错误，NoSuchBeanFactory</li>
<li>第二个是，StrategyDetail中的awardName忘记写getter和setter方法，导致数据库一直没有相应的数据生成</li>
</ul>
<h4 id="4-其它问题"><a href="#4-其它问题" class="headerlink" title="4. 其它问题"></a>4. 其它问题</h4><h5 id="4-1-为什么仓储接口定义在领域层？"><a href="#4-1-为什么仓储接口定义在领域层？" class="headerlink" title="4.1 为什么仓储接口定义在领域层？"></a>4.1 为什么仓储接口定义在领域层？</h5><p>为了领域层多聚合，如果仓储接口交给基础层实现，那么这个接口从使用上就不具备独立领域指责，其他模块都可以使用，最终就变得非常混乱了。将各自需要的接口定义在领域层，然后在基础层实现，可以避免混乱。</p>
<h3 id="ID生成"><a href="#ID生成" class="headerlink" title="ID生成"></a>ID生成</h3><p><strong>开发前须知</strong></p>
<ul>
<li>使用策略模式把三种生成ID的算法进行统一包装，由调用方决定使用哪种生成ID的策略。<em>策略模式属于行为模式的一种，一个类的行为或算法可以在运行时进行更改</em></li>
<li>雪花算法本章节使用的是工具包 hutool 包装好的工具类，一般在实际使用雪花算法时需要做一些优化处理，比如支持时间回拨、支持手工插入、简短生成长度、提升生成速度等</li>
<li>而日期拼接和随机数工具包生成方式，都需要自己保证唯一性，一般使用此方式生成的ID，都用在单表中，本身可以在数据库配置唯一ID。<em>那为什么不用自增ID，因为自增ID通常容易被外界知晓你的运营数据，以及后续需要做数据迁移到分库分表中都会有些麻烦</em></li>
</ul>
<p><strong>三种策略：</strong></p>
<ul>
<li><p><strong>随机生成数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomNumeric</span> <span class="keyword">implements</span> <span class="title class_">IIdGenerator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(RandomStringUtils.randomNumeric(<span class="number">11</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>雪花算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowFlake</span> <span class="keyword">implements</span> <span class="title class_">IIdGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Snowflake snowflake;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 0 ~ 31 位，可以采用配置的方式使用</span></span><br><span class="line">        <span class="type">long</span> workerId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取机器号</span></span><br><span class="line">            workerId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            workerId = NetUtil.getLocalhostStr().hashCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将机器号限制在31以内，也就是五位以内</span></span><br><span class="line">        workerId = workerId &gt;&gt; <span class="number">16</span> &amp; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">dataCenterId</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">        snowflake = IdUtil.createSnowflake(workerId, dataCenterId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Snowflake中生成id的方法</span></span><br><span class="line">        <span class="keyword">return</span> snowflake.nextId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Java 根据雪花算法生成ID的方式</li>
<li><img src="/2023/06/20/Lottery/image-20230512102525046.png" alt="image-20230512102525046" style="zoom:67%;"></li>
<li>上图中的工作机器id，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。也就是可以部署1024个机器，一般没有这么高的需求。</li>
<li>对一些ID生成策略见processon</li>
</ul>
</li>
<li><p><strong>日期拼接随机数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortCode</span> <span class="keyword">implements</span> <span class="title class_">IIdGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，</span></span><br><span class="line"><span class="comment">     * 同时它还可以保证共享变量的内存可见性，Java中每一个对象都可以作为锁，这是synchronized实现同步的基础。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> calendar.get(Calendar.YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> calendar.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> calendar.get(Calendar.HOUR_OF_DAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打乱排序：2020年为准 + 小时 + 周期 + 日 + 三位随机数</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">idStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        idStr.append(year - <span class="number">2023</span>);</span><br><span class="line">        idStr.append(hour);</span><br><span class="line">        idStr.append(String.format(<span class="string">&quot;%02d&quot;</span>, week));</span><br><span class="line">        idStr.append(day);</span><br><span class="line">        idStr.append(String.format(<span class="string">&quot;%03d&quot;</span>, <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(idStr.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Day09"><a href="#Day09" class="headerlink" title="Day09:"></a>Day09:</h2><h3 id="分布式路由组件"><a href="#分布式路由组件" class="headerlink" title="分布式路由组件"></a>分布式路由组件</h3><h4 id="spring-factories的作用"><a href="#spring-factories的作用" class="headerlink" title="spring.factories的作用"></a>spring.factories的作用</h4><img src="/2023/06/20/Lottery/image-20230512113438928.png" alt="image-20230512113438928" style="zoom:50%;">

<p>当启动类和配置类不在同一个包的时候，没有办法进行自动扫描，因此，在resources目录下新建一个META-INF的目录，然后新建一个spring.factories的文件，里面内容为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.bugstack.middleware.db.router.config.DataSourceAutoConfig</span><br></pre></td></tr></table></figure>

<p>即可扫描相应的包</p>
<h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><p>首先先来看整体的包结构</p>
<img src="/2023/06/20/Lottery/image-20230512141025782.png" alt="image-20230512141025782" style="zoom:50%;">

<p><strong>为什么要用分库分表</strong>：</p>
<p>由于业务体量较大，数据增长较快，所以需要把用户数据拆分到不同的库表中去，减轻数据库压力。</p>
<p><strong>分库分表操作分类</strong>：</p>
<ul>
<li>垂直拆分：指按照业务将表进行分类，分布到不同的数据库上，这样也就将数据的压力分担到不同的库上面。最终一个数据库由很多表的构成，每个表对应着不同的业务，也就是专库专用。</li>
<li>水平拆分：如果垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而本章节需要实现的水平拆分，是把同一个表拆到不同的数据库中。如：user_001、user_002</li>
</ul>
<p><strong>涉及技术：</strong></p>
<ul>
<li>AOP 切面拦截的使用，这是因为需要给使用数据库路由的方法做上标记，便于处理分库分表逻辑。</li>
<li>数据源的切换操作，既然有分库那么就会涉及在多个数据源间进行链接切换，以便把数据分配给不同的数据库。</li>
<li>数据库表寻址操作，一条数据分配到哪个数据库，哪张表，都需要进行索引计算。在方法调用的过程中最终通过 ThreadLocal 记录。</li>
<li>为了能让数据均匀的分配到不同的库表中去，还需要考虑如何进行数据散列的操作，不能分库分表后，让数据都集中在某个库的某个表，这样就失去了分库分表的意义。</li>
</ul>
<h4 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h4><h5 id="1-DBRouter"><a href="#1-DBRouter" class="headerlink" title="1. DBRouter"></a>1. DBRouter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBRouter &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">key</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>@Documented</code>表示该注解将被包含在Javadoc中生成的文档中。</li>
<li><code>@Retention(RetentionPolicy.RUNTIME)</code>指定该注解将在运行时可用，这意味着可以在程序运行时访问该注解信息。</li>
<li><code>@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</code>指定了该注解的目标元素，可以应用于类和方法上。</li>
<li><code>public @interface DBRouter</code>声明这是一个注解，注解名为<code>DBRouter</code>。</li>
<li><code>String key() default &quot;&quot;</code>定义了一个名为<code>key</code>的属性，类型为字符串，并设置了一个默认值为空字符串，也就是后续调用这个组件的时候会传入一个属性参数</li>
</ul>
<h5 id="2-解析路由配置"><a href="#2-解析路由配置" class="headerlink" title="2. 解析路由配置"></a>2. 解析路由配置</h5><img src="/2023/06/20/Lottery/image-20230512142503594.png" alt="image-20230512142503594" style="zoom:50%;">

<p><strong>2.1 在配置类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfig</span> <span class="keyword">implements</span> <span class="title class_">EnvironmentAware</span> &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.1.1 数据源配置提取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnvironment</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;router.jdbc.datasource.&quot;</span>;    </span><br><span class="line"></span><br><span class="line">    dbCount = Integer.valueOf(environment.getProperty(prefix + <span class="string">&quot;dbCount&quot;</span>));</span><br><span class="line">    tbCount = Integer.valueOf(environment.getProperty(prefix + <span class="string">&quot;tbCount&quot;</span>));    </span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">dataSources</span> <span class="operator">=</span> environment.getProperty(prefix + <span class="string">&quot;list&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String dbInfo : dataSources.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; dataSourceProps = PropertyUtil.handle(environment, prefix + dbInfo, Map.class);</span><br><span class="line">        dataSourceMap.put(dbInfo, dataSourceProps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>prefix，是数据源配置的开头信息，你可以自定义需要的开头内容。</li>
<li>dbCount、tbCount、dataSources、dataSourceProps，都是对配置信息的提取，并存放到 dataSourceMap 中便于后续使用。</li>
</ul>
<p>其中PropertyUtil.handle()方法类为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">springBootVersion</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;org.springframework.boot.bind.RelaxedPropertyResolver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            springBootVersion = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring Boot 1.x is compatible with Spring Boot 2.x by Using Java Reflect.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment : the environment context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix : the prefix part of property key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetClass : the target class type of result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; : refer to <span class="doctag">@param</span> targetClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">handle</span><span class="params">(<span class="keyword">final</span> Environment environment, <span class="keyword">final</span> String prefix, <span class="keyword">final</span> Class&lt;T&gt; targetClass)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (springBootVersion) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (T) v1(environment, prefix);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> (T) v2(environment, prefix, targetClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">v1</span><span class="params">(<span class="keyword">final</span> Environment environment, <span class="keyword">final</span> String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; resolverClass = Class.forName(<span class="string">&quot;org.springframework.boot.bind.RelaxedPropertyResolver&quot;</span>);</span><br><span class="line">            Constructor&lt;?&gt; resolverConstructor = resolverClass.getDeclaredConstructor(PropertyResolver.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getSubPropertiesMethod</span> <span class="operator">=</span> resolverClass.getDeclaredMethod(<span class="string">&quot;getSubProperties&quot;</span>, String.class);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">resolverObject</span> <span class="operator">=</span> resolverConstructor.newInstance(environment);</span><br><span class="line">            <span class="type">String</span> <span class="variable">prefixParam</span> <span class="operator">=</span> prefix.endsWith(<span class="string">&quot;.&quot;</span>) ? prefix : prefix + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> getSubPropertiesMethod.invoke(resolverObject, prefixParam);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException | NoSuchMethodException | SecurityException | InstantiationException</span><br><span class="line">                | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex.getMessage(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">v2</span><span class="params">(<span class="keyword">final</span> Environment environment, <span class="keyword">final</span> String prefix, <span class="keyword">final</span> Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; binderClass = Class.forName(<span class="string">&quot;org.springframework.boot.context.properties.bind.Binder&quot;</span>);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getMethod</span> <span class="operator">=</span> binderClass.getDeclaredMethod(<span class="string">&quot;get&quot;</span>, Environment.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">bindMethod</span> <span class="operator">=</span> binderClass.getDeclaredMethod(<span class="string">&quot;bind&quot;</span>, String.class, Class.class);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">binderObject</span> <span class="operator">=</span> getMethod.invoke(<span class="literal">null</span>, environment);</span><br><span class="line">            <span class="type">String</span> <span class="variable">prefixParam</span> <span class="operator">=</span> prefix.endsWith(<span class="string">&quot;.&quot;</span>) ? prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>) : prefix;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bindResultObject</span> <span class="operator">=</span> bindMethod.invoke(binderObject, prefixParam, targetClass);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">resultGetMethod</span> <span class="operator">=</span> bindResultObject.getClass().getDeclaredMethod(<span class="string">&quot;get&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> resultGetMethod.invoke(bindResultObject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException | NoSuchMethodException | SecurityException | IllegalAccessException</span><br><span class="line">                | IllegalArgumentException | InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex.getMessage(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个类的主要作用是在Spring Boot 1.x 和 2.x之间提供属性配置文件读取的统一接口，使得代码可以兼容这两个版本。在不同的Spring Boot版本中，读取属性配置文件的方式有所不同，而这个类通过使用Java的反射机制，根据不同的版本使用不同的方法<strong>读取属性配置文件</strong>，从而保证代码的兼容性。</li>
</ul>
<p><strong>2.2.2 创建数据源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建数据源</span></span><br><span class="line">    Map&lt;Object, Object&gt; targetDataSources = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String dbInfo : dataSourceMap.keySet()) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; objMap = dataSourceMap.get(dbInfo);</span><br><span class="line">        targetDataSources.put(dbInfo, <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>(objMap.get(<span class="string">&quot;url&quot;</span>).toString(), objMap.get(<span class="string">&quot;username&quot;</span>).toString(), objMap.get(<span class="string">&quot;password&quot;</span>).toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置数据源</span></span><br><span class="line">    <span class="type">DynamicDataSource</span> <span class="variable">dynamicDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicDataSource</span>();</span><br><span class="line">    dynamicDataSource.setTargetDataSources(targetDataSources);</span><br><span class="line">    <span class="keyword">return</span> dynamicDataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里是一个简化的创建案例，把基于从配置信息中读取到的数据源信息，进行实例化创建。</li>
<li>数据源创建完成后存放到 <code>DynamicDataSource</code> 中，它是一个继承了 AbstractRoutingDataSource 的实现类，这个类里可以存放和读取相应的具体调用的数据源信息</li>
</ul>
<p><strong>总结来说，DataSourceAutoConfig类的作用是获取到配置文件中的配置，并且创建了新的数据源，并且在另一个类中实现了1.x版本和2.x版本的兼容使用</strong></p>
<h5 id="3-切面拦截"><a href="#3-切面拦截" class="headerlink" title="3.切面拦截"></a>3.切面拦截</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component(&quot;db-router-point&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBRouterJoinPoint</span> &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 AOP 的切面拦截中需要完成；数据库路由计算、扰动函数加强散列、计算库表索引、设置到 ThreadLocal 传递数据源，整体案例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;aopPoint() &amp;&amp; @annotation(dbRouter)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doRouter</span><span class="params">(ProceedingJoinPoint jp, DBRouter dbRouter)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">dbKey</span> <span class="operator">=</span> dbRouter.key();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(dbKey)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;annotation DBRouter key is null！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算路由</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dbKeyAttr</span> <span class="operator">=</span> getAttrValue(dbKey, jp.getArgs());</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dbRouterConfig.getDbCount() * dbRouterConfig.getTbCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扰动函数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> (size - <span class="number">1</span>) &amp; (dbKeyAttr.hashCode() ^ (dbKeyAttr.hashCode() &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 库表索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dbIdx</span> <span class="operator">=</span> idx / dbRouterConfig.getTbCount() + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tbIdx</span> <span class="operator">=</span> idx - dbRouterConfig.getTbCount() * (dbIdx - <span class="number">1</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置到 ThreadLocal</span></span><br><span class="line">    DBContextHolder.setDBKey(String.format(<span class="string">&quot;%02d&quot;</span>, dbIdx));</span><br><span class="line">    DBContextHolder.setTBKey(String.format(<span class="string">&quot;%02d&quot;</span>, tbIdx));</span><br><span class="line">    logger.info(<span class="string">&quot;数据库路由 method：&#123;&#125; dbIdx：&#123;&#125; tbIdx：&#123;&#125;&quot;</span>, getMethod(jp).getName(), dbIdx, tbIdx);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jp.proceed();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        DBContextHolder.clearDBKey();</span><br><span class="line">        DBContextHolder.clearTBKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Aspect 表示这是一个切面类</li>
<li>@Component(“db-router-point”) 表示这是一个Spring组件，名称为”db-router-point”</li>
<li>@Pointcut(“@annotation(cn.bugstack.middleware.db.router.annotation.DBRouter)”) 表示定义一个切入点，通过@annotation指定对标注有@DBRouter注解的方法进行切入。</li>
<li>@Around(“aopPoint() &amp;&amp; @annotation(dbRouter)”) 表示定义环绕通知，在目标方法执行之前和之后都会执行，并且可以阻止目标方法的执行。这里通过@annotation(dbRouter)指定了切入点所在方法的DBRouter注解。</li>
</ul>
<p>在doRouter方法中，首先获取DBRouter注解中的key值，并通过getAttrValue方法获取该值对应的参数值。接着，通过扰动函数计算出该key值对应的数据库和表的索引，将其设置到ThreadLocal中。最后，执行目标方法，无论是否抛出异常，都会执行finally中的代码，将ThreadLocal中的值清除。</p>
<p>需要注意的是，DBRouterJoinPoint类使用了@Autowired注解注入了一个DBRouterConfig类，这个类在前面我们已经讲过，是用来存储从配置文件中读取的数据库配置信息以及数据库和表的数量。</p>
<h2 id="Day10"><a href="#Day10" class="headerlink" title="Day10:"></a>Day10:</h2><h3 id="声明式事务领取活动领域开发"><a href="#声明式事务领取活动领域开发" class="headerlink" title="声明式事务领取活动领域开发"></a>声明式事务领取活动领域开发</h3><p><strong>目前的问题：</strong></p>
<p>如果一个场景需要在同一个事务下，连续操作不同的DAO操作，那么就会涉及到在 DAO 上使用注解 @DBRouter(key &#x3D; “uId”) 反复切换路由的操作。虽然都是一个数据源，但这样切换后，事务就没法处理了。</p>
<p><strong>解决</strong></p>
<p>这里选择了一个较低的成本的解决方案，就是把数据源的切换放在事务处理前，而事务操作也通过编程式编码进行处理。<em>具体可以参考 db-router-spring-boot-starter 源码</em></p>
<h4 id="梳理流程"><a href="#梳理流程" class="headerlink" title="梳理流程"></a>梳理流程</h4><p>本次开发主要使用模板模式进行开发，其中抽象类BaseActivityPartake作为一个模板抽象类，在ActivityPartakeImpl进行开发实现，ActivityPartakeSupport是数据库支撑类的开发</p>
<img src="/2023/06/20/Lottery/image-20230515114224073.png" alt="image-20230515114224073" style="zoom:50%;">

<p><img src="/2023/06/20/Lottery/image-20230515134725522.png" alt="image-20230515134725522"></p>
<ul>
<li>个人认为还存在的问题：<ul>
<li>如果在领取活动信息的时候出现错误，那么不会进行回滚，库存白白减1</li>
<li>但是按照小傅哥说法，宁愿减去也不能发生超支的错误，之后会进行改进</li>
</ul>
</li>
</ul>
<p><strong>其他问题</strong></p>
<p><strong>编程式事务处理</strong></p>
<ul>
<li><p>编程式事务处理是指在编程时，通过代码实现事务的提交、回滚等操作。</p>
</li>
<li><p>在进行编程式的事务管理时，只需要将需要事务处理的方法，通过参数 TransactionCallback 传递给TransactionTemplate.execute () 方法，就可以实现事务的处理。</p>
</li>
<li><p>相对于声明式事务，编程式事务使用 TransactionTemplate 或者直接使用底层的PlatformTransactionManager 实现事务。对于编程式事务 Spring 比较推荐使用TransactionTemplate 来对事务进行管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> Result <span class="title function_">grabActivity</span><span class="params">(PartakeReq partake, ActivityBillVO bill)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           dbRouter.doRouter(partake.getuId()); <span class="comment">// 切换数据源在事务处理之前</span></span><br><span class="line">           <span class="keyword">return</span> transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 扣减个人已参与次数</span></span><br><span class="line">                   <span class="type">int</span> <span class="variable">updateCount</span> <span class="operator">=</span> userTakeActivityRepository.subtractionLeftCount(bill.getActivityId(), bill.getActivityName(), bill.getTakeCount(), bill.getUserTakeLeftCount(), partake.getuId(), partake.getPartakeDate());</span><br><span class="line">                   <span class="keyword">if</span> (<span class="number">0</span> == updateCount) &#123;</span><br><span class="line">                       status.setRollbackOnly();</span><br><span class="line">                       logger.error(<span class="string">&quot;领取活动，扣减个人已参与次数失败 activityId：&#123;&#125; uId：&#123;&#125;&quot;</span>, partake.getActivityId(), partake.getuId());</span><br><span class="line">                       <span class="keyword">return</span> Result.buildResult(Constants.ResponseCode.NO_UPDATE);</span><br><span class="line">                   &#125;</span><br><span class="line">  </span><br><span class="line">                   <span class="comment">// 插入领取活动信息</span></span><br><span class="line">                   <span class="type">Long</span> <span class="variable">takeId</span> <span class="operator">=</span> idGeneratorMap.get(Constants.Ids.SnowFlake).nextId();</span><br><span class="line">                   userTakeActivityRepository.takeActivity(bill.getActivityId(), bill.getActivityName(), bill.getTakeCount(), bill.getUserTakeLeftCount(), partake.getuId(), partake.getPartakeDate(), takeId);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (DuplicateKeyException e) &#123;</span><br><span class="line">                   status.setRollbackOnly();</span><br><span class="line">                   logger.error(<span class="string">&quot;领取活动，唯一索引冲突 activityId：&#123;&#125; uId：&#123;&#125;&quot;</span>, partake.getActivityId(), partake.getuId(), e);</span><br><span class="line">                   <span class="keyword">return</span> Result.buildResult(Constants.ResponseCode.INDEX_DUP);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> Result.buildSuccessResult();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           dbRouter.clear();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>编程式事务与声明式事务处理的区别</strong></p>
<ul>
<li><p>编程式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 执行一些数据库操作</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">	<span class="comment">// 实现业务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在编程式事务中，我们需要手动开启、提交、回滚事务;而在声明式事务中，我们只需要在方法上添加@Transactiona注解即可。这样就可以将操作与事务规则进行解耦，使得代码更加简洁易懂。</p>
<p>声明式事务和编程式事务各有优缺点。</p>
<ul>
<li>声明式事务的<ul>
<li>优点是:代码简洁，易于维护，不侵入业务逻辑，使得代码更加清晰，可以通过注解或配置文件来实现，使用方便。</li>
<li>缺点是:不够灵活，无法满足一些特殊需求，不利于调试，出现问题难以定位。</li>
</ul>
</li>
<li>编程式事务的<ul>
<li>优点是: 灵活性高，可以满足各种特殊需求，便于调试，出现问题容易定位。</li>
<li>缺点是:代码复杂，维护困难，侵入业务逻辑，使得代码不够清晰。</li>
</ul>
</li>
</ul>
<p>因此，在选择使用哪种事务管理方式时，需要根据具体情况进行选择<br>这样看下来，其实在一些小项目里面，可能使用声明式事务会是更好的选择。在这个例子中不能使用声明式事务是因为: 如果一个场景需要在同一个事务下，连续操作不同的DAO操作，那么就会涉及到在 DAO 上使用注解 @DBRouter(key &#x3D;”uld”)反复切换路由的操作。虽然都是一个数据源，但这样切换后，事务就没法处理了。</p>
<p>看一个例子: 我要插入两个uid，分别为uid&#x3D;1和uid&#x3D;2，在一般情况下，用声明式事务可以解决问题: insert两次然后commit即可: 但在这种分库分表的情况下，我现在插入一个uld&#x3D;1，这条记录放在db01，uid&#x3D;2的记录放在db02，在这个过程中会发生数据源的切换，切换了数据源，但是还没有提交commit，那么数据就会丢失。</p>
<p><strong>总结</strong>：在分库分表的情况下，建议使用编程式事务。因为声明式事务是通过注解或配置文件来实现的，无法动态地确定开启哪个数据库实例的事务。而在分库分表时，需要动态地确定开启哪个数据库实例的事务，因此需要使用编程式事务。此外，编程式事务可以更好地控制事务的边界，保证数据的一致性。</p>
<h3 id="在应用层编排抽奖过程"><a href="#在应用层编排抽奖过程" class="headerlink" title="在应用层编排抽奖过程"></a>在应用层编排抽奖过程</h3><h4 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h4><ul>
<li><p>分别在两个分库的表<code> lottery_01.user_take_activity</code>、<code>lottery_02.user_take_activity</code> 中添加<code> state【活动单使用状态 0未使用、1已使用】</code> 状态字段，这个状态字段用于写入中奖信息到 <code>user_strategy_export_000~003</code> 表中时候，两个表可以做一个<strong>幂等性</strong>的事务。同时还需要加入 strategy_id 策略ID字段，用于处理领取了活动单但执行抽奖失败时，可以继续获取到此抽奖单继续执行抽奖，而不需要重新领取活动。<em>其实领取活动就像是一种活动镜像信息，可以在控制幂等反复使用</em></p>
<p>所谓的幂等性，是分布式环境下的一个常见问题，一般是指我们在进行多次操作时，所得到的结果是一样的，即多次运算结果是一致的。</p>
<p>也就是说，用户对于同一操作，无论是发起一次请求还是多次请求，最终的执行结果是一致的，不会因为多次点击而产生副作用。</p>
</li>
<li><p>在 lottery-application 模块下新增 process 包用于流程编排，其实它也是 service 服务包是对领域功能的封装，很薄的一层。那么定义成 process 是想大家对流程编排有个概念，一般这一层的处理可以使用可视化的流程编排工具通过拖拽的方式，处理这部分代码的逻辑。</p>
</li>
<li><p>学习本章记得更新分支下的最新SQL语句，另外本章节还连带引入了需要MQ、Worker的场景，后续开发到这些功能的时候，会继续完善</p>
</li>
</ul>
<h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><img src="/2023/06/20/Lottery/image_20230515151626.png" alt="image-20230515134725522" style="zoom: 80%;">

<ul>
<li>抽奖整个活动过程的流程编排，主要包括：对活动的领取、对抽奖的操作、对中奖结果的存放，以及如何处理发奖，对于发奖流程我们设计为MQ触发，后续再补全这部分内容。</li>
<li>对于每一个流程节点编排的内容，都是在领域层开发完成的，而应用层只是做最为简单的且很薄的一层。<em>其实这块也很符合目前很多低代码的使用场景，通过界面可视化控制流程编排，生成代码</em></li>
</ul>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><img src="/2023/06/20/Lottery/process.png">

<p><strong>本章出现BUG的几个位置</strong></p>
<ul>
<li>字段在实体类和数据库表中添加之后在查询中忘记查、在resultMap中忘记加入映射</li>
<li>查询是否有领取但未执行的时候没有加入@DBRouter，导致无法扫描到其他表</li>
</ul>
<h2 id="Day11："><a href="#Day11：" class="headerlink" title="Day11："></a>Day11：</h2><h3 id="规则引擎量化人群参与活动"><a href="#规则引擎量化人群参与活动" class="headerlink" title="规则引擎量化人群参与活动"></a>规则引擎量化人群参与活动</h3><ul>
<li><p>增加规则引擎开发需要的相关的配置类表：rule_tree、rule_tree_node、rule_tree_node_line</p>
<ul>
<li><p>rule_tree                          决策树基本信息</p>
</li>
<li><p>rule_tree_node               决策树各节点信息</p>
</li>
<li><p>rule_tree_node_line       决策树树枝信息</p>
<img src="/2023/06/20/Lottery/image-20230518091921261.png" alt="image-20230518091921261" style="zoom: 50%;"></li>
</ul>
</li>
<li><p>运用组合模式搭建规则引擎领域服务，包括：logic 逻辑过滤器、engine 引擎执行器</p>
</li>
<li><p>修改 lottery-infrastructure 基础层中仓储实现类更为合适的的注解为 <code>@Repository</code> 包括： ActivityRepository、RuleRepository、StrategyRepository、UserTakeActivityRepository</p>
</li>
</ul>
<h4 id="梳理流程-1"><a href="#梳理流程-1" class="headerlink" title="梳理流程"></a>梳理流程</h4><img src="/2023/06/20/Lottery/image-20230518122227515.png" alt="image-20230518122227515" style="zoom:67%;">

<ul>
<li>Filter主要是用来进行规则过滤，也就是根据当前的matter获取到下一个节点</li>
<li>Engine主要是作为规则引擎，也就是根据过滤条件等来获取到最终的节点信息</li>
</ul>
<h3 id="门面接口封装和对象转换"><a href="#门面接口封装和对象转换" class="headerlink" title="门面接口封装和对象转换"></a>门面接口封装和对象转换</h3><p>以 DDD 设计的结构框架，在接口层和应用层需要做防污处理，也就是说不能直接把应用层、领域层的对象直接暴露处理，因为暴露出去可能会随着业务发展的过程中不断的添加各类字段，从而破坏领域结构。那么就需要增加一层对象转换，也就有了 vo2dto、dto2vo 的操作。但这些转换的字段又基本都是重复的，在保证性能的情况下，一些高并发场景就只会选择手动编写 get、set，但其实也有很多其他的方式，转换性能也不差，这里列举一下。</p>
<img src="/2023/06/20/Lottery/image-20230518155601058.png" alt="image-20230518155601058" style="zoom: 67%;">

<p>本章节总体而言完成了三个工作：</p>
<ol>
<li>完成application应用层拼接量化规则操作，返回可以抽奖的活动id</li>
<li>在接口层添加对象转换，完成防污处理</li>
<li>提供rpc接口，分别实现按照id抽奖以及按照量化人群决策进行抽奖两种模式</li>
</ol>
<h2 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h2><h3 id="搭建MQ消息组件Kafka服务环境"><a href="#搭建MQ消息组件Kafka服务环境" class="headerlink" title="搭建MQ消息组件Kafka服务环境"></a>搭建MQ消息组件Kafka服务环境</h3><p>使用MQ消息组件的原因：</p>
<p>当用户发起抽奖，如果我们一条链路进行执行的话就会造成卡顿的现象，因此需要异步调用。先告诉用户中奖了，之后再进行别的操作</p>
<h4 id="windows配置kafka"><a href="#windows配置kafka" class="headerlink" title="windows配置kafka"></a>windows配置kafka</h4><p>首先在官网下载稳定版本的kafka并且进行解压，在解压后的目录下使用终端进行打开</p>
<p><strong>启动zookeeper：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/windows/zookeeper-server-start.bat config/zookeeper.properties</span><br></pre></td></tr></table></figure>

<p><strong>关闭zookeeper</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/windows/zookeeper-server-stop.bat config/zookeeper.properties</span><br></pre></td></tr></table></figure>

<p><strong>启动kafka：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/windows/kafka-server-start.bat config/server.properties</span><br></pre></td></tr></table></figure>

<p><strong>关闭kafka：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/windows/kafka-server-stop.bat config/server.properties</span><br></pre></td></tr></table></figure>

<p><strong>创建主题：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/windows/kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic Hello-Kafka</span><br></pre></td></tr></table></figure>

<p><strong>查看主题：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/windows/kafka-topics.bat --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>

<p><strong>发送消息：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/windows/kafka-console-producer.bat --broker-list localhost:9092 --topic Hello-Kafka</span><br></pre></td></tr></table></figure>

<p><strong>接收消息：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/windows/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic Hello-Kafka --from-beginning</span><br></pre></td></tr></table></figure>

<h3 id="使用MQ解耦抽奖发货流程"><a href="#使用MQ解耦抽奖发货流程" class="headerlink" title="使用MQ解耦抽奖发货流程"></a>使用MQ解耦抽奖发货流程</h3><p>大体流程如下：</p>
<ol>
<li>在ActivityProcessImpl中的doDrawProcess方法中调用kafkaProducer.sendLotteryInvoice(invoiceVO);发送MQ，触发发奖流程 </li>
<li>在LotteryInvoiceListener中进行监听消费，主要完成以下操作<ol>
<li>判断消息是否存在</li>
<li>处理MQ消息（转换对象，获取发送奖品工厂执行发奖，打印日志，消息消费完成）</li>
</ol>
</li>
</ol>
<h2 id="Day13："><a href="#Day13：" class="headerlink" title="Day13："></a>Day13：</h2><h3 id="xxl-job完成活动状态扫描"><a href="#xxl-job完成活动状态扫描" class="headerlink" title="xxl-job完成活动状态扫描"></a>xxl-job完成活动状态扫描</h3><h4 id="引入过程"><a href="#引入过程" class="headerlink" title="引入过程"></a>引入过程</h4><ol>
<li>下载：<a target="_blank" rel="noopener" href="https://github.com/xuxueli/xxl-job/releases/tag/2.3.0">2.3.0</a></li>
<li>打开：使用 IDEA 打开下载的 xxl-job</li>
<li>导表：把 xxl-job 中的 <code>doc\db\tables_xxl_job.sql</code> 导入到自己的数据库中</li>
<li>启动：xxl-job-admin 是用于管理分布式任务调度的后台，一切配置完后，启动 xxl-job-admin 另外你需要配置 application.properties 修改数据库链接参数和日志文件夹</li>
<li>案例：xxl-job-executor-samples 是一组job任务案例，运行后可以在分布式任务调度后台管理任务，配置、启动、关闭</li>
<li>核心：xxl-job-core</li>
</ol>
<h4 id="执行启动"><a href="#执行启动" class="headerlink" title="执行启动"></a>执行启动</h4><ol>
<li>启动前检查好 application.properties 中的端口号</li>
<li>确保数据库表已经初始化完成，并修改 application.properties 中数据库链接信息</li>
<li>修改 logback.xml 日志打印目录，否则日志找不到会报错</li>
</ol>
<p>像启动 SpringBoot 程序一样，启动这个 xxl-job 任务调度后台，如果你是部署到云服务器，则需要打包构架部署</p>
<h4 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h4><ul>
<li>地址：<a target="_blank" rel="noopener" href="http://localhost:7397/xxl-job-admin">http://localhost:7397/xxl-job-admin</a> <code>我修改端口为7397了，你按照自己的端口就可以</code></li>
<li>账号：admin</li>
<li>密码：123456</li>
</ul>
<h2 id="Day14："><a href="#Day14：" class="headerlink" title="Day14："></a>Day14：</h2><h3 id="扫描库表补偿发货单MQ消息"><a href="#扫描库表补偿发货单MQ消息" class="headerlink" title="扫描库表补偿发货单MQ消息"></a>扫描库表补偿发货单MQ消息</h3><ul>
<li>我们的任务流程，完成的就是整个抽奖活动中，关于中奖结果落库后，进行MQ后。出现问题时，进行补偿消息发送处理的部分。</li>
<li>在MQ消息补偿的过程中，会把发送失败的消息和迟迟没有发送的消息，都进行补偿，已保障全流程的可靠性。</li>
</ul>
<h4 id="目前流程启动流程"><a href="#目前流程启动流程" class="headerlink" title="目前流程启动流程"></a>目前流程启动流程</h4><ol>
<li>启动 zk、kafka，<em>总怕你忘记，如果你已经云服务器了，可以先部署上去。</em></li>
<li>启动 xxl-job</li>
<li>启动 lottery 使用debug模式，方便验证</li>
<li>修改库表中，user_strategy_export_001~004 中任意一个表的 MQ 状态为 2 表示发送 MQ 失败</li>
</ol>
<h2 id="Day15："><a href="#Day15：" class="headerlink" title="Day15："></a>Day15：</h2><h3 id="安装宝塔linux"><a href="#安装宝塔linux" class="headerlink" title="安装宝塔linux"></a>安装宝塔linux</h3><ol>
<li><p>在官网上获得centos的命令行在虚拟机中运行即可</p>
</li>
<li><pre><code>外网面板地址: https://101.35.210.50:28478/a612fca3
内网面板地址: https://10.0.4.11:28478/a612fca3
username: p7mm5wky
password: c587d4e6
</code></pre>
</li>
</ol>
<p><strong>遇到的问题：</strong></p>
<ul>
<li><p>最初在自己的虚拟机上面进行安装，发现无法获取连接</p>
<p>原因：</p>
<p><img src="/2023/06/20/Lottery/image-20230525113519894.png" alt="image-20230525113519894"></p>
</li>
<li><p>购买云服务器进行配置安装</p>
</li>
</ul>
<h3 id="本章内容："><a href="#本章内容：" class="headerlink" title="本章内容："></a>本章内容：</h3><ul>
<li>在云服务器搭建 Redis 服务，这样可以更加方便的使用</li>
<li>在抽奖系统中引入 Redis 模块，优化用户参与抽奖活动。因为只要有大量的用户参与抽奖，那么这个就属于秒杀场景。所以需要使用 Redis 分布式锁的方式来处理集中化库存扣减的问题，否则在 TPS 达到1k-2k，就会把数据库拖垮。</li>
<li>在设计秒杀流程时，优化锁的颗粒度力度，不要把锁直接放到活动编号上，这样在极端临界情况下会出现秒杀解锁失败，导致库存有剩余但不能下单的情况。所以需要增加锁的颗粒度，以滑动库存剩余编号的方式进行加锁，例如 100001_1、100001_2、100001_3，以此类推，具体看代码实现。</li>
<li>增加缓存扣减库存后，发送 MQ 消息进行异步更新数据库中活动库存，做最终数据一致性处理。<em>这一部分如果你的系统并发体量较大，还需要把 MQ 的数据不要直接对库更新，而是更新到缓存中，再由任务最阶段同步，以此减少对数据库表的操作</em></li>
</ul>
<h4 id="滑块库存锁设计"><a href="#滑块库存锁设计" class="headerlink" title="滑块库存锁设计"></a>滑块库存锁设计</h4><p><img src="/2023/06/20/Lottery/image-20230525114101914.png" alt="image-20230525114101914"></p>
<ul>
<li>如图所示，即使是使用 Redis 分布式锁，我们也不希望把锁的颗粒度放的太粗，否则还是会出现活动有库存但不能秒杀，提示“活动过于火爆”</li>
<li>那么我们就需要按照活动编号把库存锁的颗粒度缩小，实际操作也并不复杂，只是把<code>活动ID+库存扣减后的值</code>一起作为分布式锁的Key，这样就缩小了锁的颗粒度。</li>
</ul>
<h2 id="抽奖系统总体流程开发"><a href="#抽奖系统总体流程开发" class="headerlink" title="抽奖系统总体流程开发"></a>抽奖系统总体流程开发</h2><p><img src="/2023/06/20/Lottery/%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B.jpg" alt="抽奖系统总体流程"></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/hutao.jpg" alt="SPY"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SPY</p><p class="is-size-6 is-block">一个热爱并追求技术的小白</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Spy955" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Spy955"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-20T05:40:45.000Z">2023-06-20</time></p><p class="title"><a href="/2023/06/20/Lottery/">Lottery抽奖系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-25T01:44:48.000Z">2022-12-25</time></p><p class="title"><a href="/2022/12/25/Servlet/">关于 Servlet 的学习</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-22T04:13:36.000Z">2022-12-22</time></p><p class="title"><a href="/2022/12/22/HTML/">复习前端知识 HTML&amp;CSS&amp;JavaScript</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-20T13:43:06.000Z">2022-11-20</time></p><p class="title"><a href="/2022/11/20/SQL/">MySQL 易忘知识复习</a></p><p class="categories"><a href="/categories/MySQL/">MySQL</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-20T08:49:28.000Z">2022-11-20</time></p><p class="title"><a href="/2022/11/20/JavaWeb-review/">JavaWeb的复习</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java-Project/"><span class="tag">Java_Project</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web/"><span class="tag">Web</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.png" alt="SPY 的博客" height="28"></a><p class="is-size-7"><span>&copy; 2023 Sun Peiyuan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Spy955"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>