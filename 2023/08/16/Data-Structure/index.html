<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>数据结构 - SPY 的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SPY 的博客"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SPY 的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本篇内容：  对数据结构进行整体的复习 除了数据结构理论知识以外，本篇更注重实践，提供了各种数据结构的代码 对数据结构常见面试题进行分模块整理"><meta property="og:type" content="blog"><meta property="og:title" content="数据结构"><meta property="og:url" content="https://spy955.github.io/2023/08/16/Data-Structure/"><meta property="og:site_name" content="SPY 的博客"><meta property="og:description" content="本篇内容：  对数据结构进行整体的复习 除了数据结构理论知识以外，本篇更注重实践，提供了各种数据结构的代码 对数据结构常见面试题进行分模块整理"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230808091228370.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/fb2e937c088a462793a0b3ea44d3f64dtplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/b80a1b668b754d4bbf40372c9141c241tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/11baa42345494f23aa045fd99088a136tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230808122429694.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230808120939501.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230808121843836.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230808121913433.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230808122059457.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/algorithms-220824-12.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230808152750451.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230808152808965.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RoY2FvMTExMg==,size_16,color_FFFFFF,t_70.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RoY2FvMTExMg==,size_16,color_FFFFFF,t_70-16914781973725.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230808152218517.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/heap-01.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/heap-02.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/heap-03.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/heap-04.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/trie-01.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/Center.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-bst-03.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-avl-01.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230812160405153.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-avl-06.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-avl-08.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-avl-09.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-23-01.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-23-02.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-04.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-05.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-06.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-07-169197462974612.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-08.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-09.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230815165530506.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/disjoint-set-06.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/disjoint-set-07.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/disjoint-set-08.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/disjoint-set-09.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/disjoint-set-10.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-01.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-02.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-03.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-04.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-05.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-06.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-07.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-08.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-09.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-10.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-11.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-12.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-13.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/graph-14.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/e94e504adc5a75a2d7f562dc44166511.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/9ebde5c11ad69447314c216acf188fc8.png"><meta property="og:image" content="https://spy955.github.io/2023/08/16/Data-Structure/a3e7d217ecb825e94bdc577a467eb29d.png"><meta property="article:published_time" content="2023-08-16T06:11:29.000Z"><meta property="article:modified_time" content="2023-08-16T06:20:31.768Z"><meta property="article:author" content="Sun Peiyuan"><meta property="article:tag" content="Data Structure"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://spy955.github.io/2023/08/16/Data-Structure/image-20230808091228370.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://spy955.github.io/2023/08/16/Data-Structure/"},"headline":"数据结构","image":["https://spy955.github.io/2023/08/16/Data-Structure/image-20230808091228370.png","https://spy955.github.io/2023/08/16/Data-Structure/fb2e937c088a462793a0b3ea44d3f64dtplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp","https://spy955.github.io/2023/08/16/Data-Structure/b80a1b668b754d4bbf40372c9141c241tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp","https://spy955.github.io/2023/08/16/Data-Structure/11baa42345494f23aa045fd99088a136tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp","https://spy955.github.io/2023/08/16/Data-Structure/image-20230808122429694.png","https://spy955.github.io/2023/08/16/Data-Structure/image-20230808120939501.png","https://spy955.github.io/2023/08/16/Data-Structure/image-20230808121843836.png","https://spy955.github.io/2023/08/16/Data-Structure/image-20230808121913433.png","https://spy955.github.io/2023/08/16/Data-Structure/image-20230808122059457.png","https://spy955.github.io/2023/08/16/Data-Structure/algorithms-220824-12.png","https://spy955.github.io/2023/08/16/Data-Structure/image-20230808152750451.png","https://spy955.github.io/2023/08/16/Data-Structure/image-20230808152808965.png","https://spy955.github.io/2023/08/16/Data-Structure/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RoY2FvMTExMg==,size_16,color_FFFFFF,t_70.png","https://spy955.github.io/2023/08/16/Data-Structure/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RoY2FvMTExMg==,size_16,color_FFFFFF,t_70-16914781973725.png","https://spy955.github.io/2023/08/16/Data-Structure/image-20230808152218517.png","https://spy955.github.io/2023/08/16/Data-Structure/heap-01.png","https://spy955.github.io/2023/08/16/Data-Structure/heap-02.png","https://spy955.github.io/2023/08/16/Data-Structure/heap-03.png","https://spy955.github.io/2023/08/16/Data-Structure/heap-04.png","https://spy955.github.io/2023/08/16/Data-Structure/trie-01.png","https://spy955.github.io/2023/08/16/Data-Structure/Center.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-bst-03.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-avl-01.png","https://spy955.github.io/2023/08/16/Data-Structure/image-20230812160405153.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-avl-06.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-avl-08.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-avl-09.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-23-01.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-23-02.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-04.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-05.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-06.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-07-169197462974612.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-08.png","https://spy955.github.io/2023/08/16/Data-Structure/tree-rbt-09.png","https://spy955.github.io/2023/08/16/Data-Structure/image-20230815165530506.png","https://spy955.github.io/2023/08/16/Data-Structure/disjoint-set-06.png","https://spy955.github.io/2023/08/16/Data-Structure/disjoint-set-07.png","https://spy955.github.io/2023/08/16/Data-Structure/disjoint-set-08.png","https://spy955.github.io/2023/08/16/Data-Structure/disjoint-set-09.png","https://spy955.github.io/2023/08/16/Data-Structure/disjoint-set-10.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-01.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-02.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-03.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-04.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-05.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-06.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-07.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-08.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-09.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-10.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-11.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-12.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-13.png","https://spy955.github.io/2023/08/16/Data-Structure/graph-14.png","https://spy955.github.io/2023/08/16/Data-Structure/e94e504adc5a75a2d7f562dc44166511.png","https://spy955.github.io/2023/08/16/Data-Structure/9ebde5c11ad69447314c216acf188fc8.png","https://spy955.github.io/2023/08/16/Data-Structure/a3e7d217ecb825e94bdc577a467eb29d.png"],"datePublished":"2023-08-16T06:11:29.000Z","dateModified":"2023-08-16T06:20:31.768Z","author":{"@type":"Person","name":"Sun Peiyuan"},"publisher":{"@type":"Organization","name":"SPY 的博客","logo":{"@type":"ImageObject","url":"https://spy955.github.io/img/favicon.png"}},"description":"本篇内容：  对数据结构进行整体的复习 除了数据结构理论知识以外，本篇更注重实践，提供了各种数据结构的代码 对数据结构常见面试题进行分模块整理"}</script><link rel="canonical" href="https://spy955.github.io/2023/08/16/Data-Structure/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.png" alt="SPY 的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Spy955"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-08-16T06:11:29.000Z" title="2023/8/16 14:11:29">2023-08-16</time>发表</span><span class="level-item"><time dateTime="2023-08-16T06:20:31.768Z" title="2023/8/16 14:20:31">2023-08-16</time>更新</span><span class="level-item">3 小时读完 (大约28378个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">数据结构</h1><div class="content"><p><strong>本篇内容：</strong></p>
<ol>
<li>对数据结构进行整体的复习</li>
<li>除了数据结构理论知识以外，本篇更注重实践，提供了各种数据结构的代码</li>
<li>对数据结构常见面试题进行分模块整理</li>
</ol>
<span id="more"></span>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="1-链表简介"><a href="#1-链表简介" class="headerlink" title="1.链表简介"></a>1.链表简介</h3><h4 id="1-1链表是什么？"><a href="#1-1链表是什么？" class="headerlink" title="1.1链表是什么？"></a>1.1链表是什么？</h4><p>链表是<strong>数据元素的线性集合</strong>， 元素的线性顺序不是由它们在内存中的物理地址给出的，即<strong>链表的物理地址不连续</strong>。 它是由一组节点组成的数据结构， 每个元素指向下一个元素，每个节点由数据和指针（存放指向下一个节点的指针）两部分组成， 这种数据结构允许在迭代时有效地从序列中的任何位置插入或删除元素。这些节点一起，表示线性序列。  </p>
<h4 id="1-2链表的优点和缺点"><a href="#1-2链表的优点和缺点" class="headerlink" title="1.2链表的优点和缺点"></a>1.2链表的优点和缺点</h4><ul>
<li>优点：可以不需要扩容空间就<strong>更高效的插入和删除元素</strong>的操作。</li>
<li>缺点：在<strong>指定位置操作、或者访问任意元素</strong>下， 是需要循环遍历的， 这将导致时间复杂度的提升。</li>
</ul>
<p><strong>总结来说，链表适合插入和删除元素多的场景，不适合查找多的场景</strong>。</p>
<h3 id="2-链表分类"><a href="#2-链表分类" class="headerlink" title="2.链表分类"></a>2.链表分类</h3><h4 id="2-1单向链表"><a href="#2-1单向链表" class="headerlink" title="2.1单向链表"></a>2.1单向链表</h4><p>单链表由数据和指针构成，指针指向下一个节点。 可以对单链表执行的操作包括<strong>插入、 删除和遍历</strong>。  </p>
<h4 id="2-2双向链表"><a href="#2-2双向链表" class="headerlink" title="2.2双向链表"></a>2.2双向链表</h4><p>双向链表包括数据、指向下一个节点的字段和指向上一个节点的字段。</p>
<h4 id="2-3循环链表"><a href="#2-3循环链表" class="headerlink" title="2.3循环链表"></a>2.3循环链表</h4><p>循环链表是在单链表的基础上，将最后一个节点的指针指向了第一个节点，从而构成了一个环。</p>
<h3 id="3-常见面试问题"><a href="#3-常见面试问题" class="headerlink" title="3.常见面试问题"></a>3.常见面试问题</h3><ol>
<li><p>描述一下链表的数据结构？</p>
<p>链表是一组元素的线性集合，元素顺序不是由物理地址决定。单向链表是由数据+指向下一个节点的指针组成；双向链表是由数据+指向下一个节点的指针+指向上一个节点的指针组成；双向链表在单项链表的基础上，在最后一个元素添加指向第一个元素的指针。链表的数据结构便于插入和删除元素，其复杂度为 O(1)。</p>
</li>
<li><p>Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？</p>
<p><strong>双向链表</strong>。其节点是由 prev指针 + 数据 + next指针组成。</p>
</li>
<li><p>链表中数据的插入、删除、获取元素，时间复杂度是多少？</p>
<p>插入、删除单个元素：O(1)</p>
<p>删除多个、获取元素：O(n)</p>
</li>
<li><p>什么场景下使用链表更合适？  </p>
<p>经常进行插入和删除元素；很少进行查找操作的情况下。</p>
</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-数组的简介"><a href="#1-数组的简介" class="headerlink" title="1.数组的简介"></a>1.数组的简介</h3><h4 id="1-1什么是数组？"><a href="#1-1什么是数组？" class="headerlink" title="1.1什么是数组？"></a>1.1什么是数组？</h4><p>数组（Array） 是一种线性表数据结构。它用一组连续的内存空间， 来存储一组具有相同类型数据的集合。  </p>
<h4 id="1-2数组的特点"><a href="#1-2数组的特点" class="headerlink" title="1.2数组的特点"></a>1.2数组的特点</h4><p>数组的特点：</p>
<ul>
<li>数组是相同数据类型的元素集合（int 不能存放 double）</li>
<li>数组中各元素的存储是有先后顺序的，它们在内存中按照这个顺序连续存放到一起，内存地址连续。</li>
<li>数组获取元素的时间复杂度为 O(1)</li>
</ul>
<h3 id="2-数组的类型"><a href="#2-数组的类型" class="headerlink" title="2.数组的类型"></a>2.数组的类型</h3><h4 id="1-1一维数组"><a href="#1-1一维数组" class="headerlink" title="1.1一维数组"></a>1.1一维数组</h4><p>一维数组是最常用的数组， 其他很多数据结构的变种也都是从一维数组来的。 例如 HashMap 的拉链寻址结构， ThreadLocal 的开放寻址结构， 都是从一维数组上实现的。  </p>
<h4 id="1-2二维数组"><a href="#1-2二维数组" class="headerlink" title="1.2二维数组"></a>1.2二维数组</h4><h3 id="3-数组的实现"><a href="#3-数组的实现" class="headerlink" title="3.数组的实现"></a>3.数组的实现</h3><p>在 Java 的源码中，数组是一个非常常用的数据结构，很多其他数据结构也都有数组的影子。在一些数据存放和使用的场景中，基本也都是使用 ArrayList 而不是 LinkedList  </p>
<p><strong>ArrayList 实现过程：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> array_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始化空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 元素数组缓存区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List 集合元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认给个空的元素，当开始添加元素的时候在初始化长度</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保内部容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minCapacity</span> <span class="operator">=</span> size + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                newCapacity = minCapacity;</span><br><span class="line">            &#125;</span><br><span class="line">            elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) elementData[index];</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 从原始数组的某个位置，拷贝到目标对象的某个位置开始后n个元素</span></span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ArrayList&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;elementData=&quot;</span> + Arrays.toString(elementData) +</span><br><span class="line">                <span class="string">&quot;, size=&quot;</span> + size +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逐步解析：</strong></p>
<p><strong>add 方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="comment">// 确保内部容量</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">minCapacity</span> <span class="operator">=</span> size + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断扩容操作</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">           <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               newCapacity = minCapacity;</span><br><span class="line">           &#125;</span><br><span class="line">           elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 添加元素</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>minCapacity</code> 是表示当前<code>ArrayList</code>中元素的数量加上要添加的新元素数量。在<code>add</code>方法中，<code>minCapacity</code> 的计算方式是 <code>size + 1</code>，其中 <code>size</code> 表示当前<code>ArrayList</code>中已有元素的数量，而 <code>1</code> 表示要添加的新元素数量。</li>
<li>在 <code>ArrayList</code> 中，<code>size</code> 属性表示当前列表中已经存储的元素数量，而 <code>elementData</code> 是内部的数组用于存储元素。当我们向<code>ArrayList</code>中添加新元素时，会根据 <code>minCapacity</code> 来判断是否需要进行扩容操作，保证足够的容量来存放新的元素。</li>
<li>注意，在添加元素之前，<code>minCapacity</code> 需要考虑到当前已有元素的数量，因为我们要确保能够容纳新元素。所以，<code>minCapacity</code> 的值等于 <code>size + 1</code>，其中 <code>size</code> 是已有元素的数量，<code>1</code> 是要添加的新元素数量。如果 <code>minCapacity - elementData.length &gt; 0</code> 条件成立，说明当前容量不足以容纳要添加的新元素，需要进行扩容操作。</li>
<li>扩容操作：新容量 &#x3D; 旧容量 + （旧容量）&#x2F; 2</li>
<li>如果扩容之后仍然不满足条件，即容量小于包含的元素数量，即<code>newCapacity - minCapacity &lt; 0</code>，此时令<code>newCapacity = minCapacity;</code>，然后使用 <code>Arrays.copyOf(数据, 容量)</code>拷贝到新数组中。</li>
<li>执行添加元素操作</li>
</ul>
<p><strong>remove 方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) elementData[index];</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从原始数组的某个位置，拷贝到目标对象的某个位置开始后n个元素</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>System.arraycopy()</code>各参数的作用</li>
</ul>
<h3 id="4-常见面试题"><a href="#4-常见面试题" class="headerlink" title="4.常见面试题"></a>4.常见面试题</h3><ol>
<li><p>数据结构中有哪些是线性表数据结构？</p>
<p>链表、队列、数组、栈、哈希表</p>
</li>
<li><p>数组的元素删除和获取，时间复杂度是多少？</p>
<p>删除：O(n)</p>
<p>获取：O(1)</p>
</li>
<li><p>ArrayList 中默认的初始化长度是多少？</p>
<p>10</p>
</li>
<li><p>ArrayList 中扩容的范围是多大一次？</p>
<p>1.5倍。原始容量 + 原始容量 &#x2F; 2</p>
</li>
<li><p>ArrayList 是如何完成扩容的，System.arraycopy 各个入参的作用是什么？  </p>
<ul>
<li><p>每次添加元素前，size+1， 与当前容器长度进行比较，当增加一个后的容量大于当前容量，调用 <code>Arrays.copyOf</code> 方法进行扩容1.5倍，参数为原始链表，扩容后的容量，其本质是调用本地函数 System.arraycopy    </p>
</li>
<li><p>public static native void arraycopy(Object src,  int  srcPos,Object dest, int destPos,int length); </p>
<p>第一个参数 src ：原始容器 </p>
<p>第二个参数 srcPos：原始容器开始下标 </p>
<p>第三个参数 dest：新容器 </p>
<p>第四个参数 destPos：新容器开始下标 </p>
<p>第五个参数 length：要移动的个数</p>
</li>
</ul>
</li>
</ol>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="1-队列的简介"><a href="#1-队列的简介" class="headerlink" title="1.队列的简介"></a>1.队列的简介</h3><h4 id="1-1队列的简介"><a href="#1-1队列的简介" class="headerlink" title="1.1队列的简介"></a>1.1队列的简介</h4><p><strong>队列</strong>是一种特殊类型的抽象数据类型或集合（可以使用链表实现，也可以使用数组实现），集合中的实体对象按顺序保存。</p>
<p>将元素添加到队列后的操作称之为入队，从队列中移除的操作称之为出队。同时也包括有 peek、element 操作。队列的特点是<strong>先进先出（FIFO）</strong>。</p>
<h4 id="1-2队列的实现"><a href="#1-2队列的实现" class="headerlink" title="1.2队列的实现"></a>1.2队列的实现</h4><ul>
<li>理论上来说，队列没有特定的容量。不管包含多少元素，总能继续添加新元素。</li>
<li>队列既可以使用<strong>数组实现</strong>，也可以使用<strong>链表实现</strong>（后面详细叙述）</li>
<li>队列不只是可以单端从一个口入，一个口出，也可以是<strong>双端队列（Deque）</strong>。</li>
</ul>
<h5 id="1-2-1单端队列-Queue"><a href="#1-2-1单端队列-Queue" class="headerlink" title="1.2.1单端队列(Queue)"></a>1.2.1单端队列(Queue)</h5><p><code>Queue</code> 的实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>。最常用的实现类是 <code>LinkedList</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Queue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>常用的方法：</strong></p>
<ul>
<li>添加元素操作：add() 和 offer()<ul>
<li>相同点：当容量未满的时候，在队列末尾进行元素添加，返回被添加的元素</li>
<li>不同点：当容量满了之后，add 方法爆出异常，offer 方法返回 false</li>
</ul>
</li>
<li>删除元素操作：remove() 和 poll()<ul>
<li>相同点：当容量不为 0 的时候，删除并返回队尾被删除的元素</li>
<li>不同点：当容量为 0 的时候，remove 爆出异常，poll 方法返回 false</li>
</ul>
</li>
<li>取出队头元素：element() 和 peek()<ul>
<li>相同点：当容量不为 0 的时候，返回队头元素，但是不删除</li>
<li>不同点：当容量为 0 的时候，element()会抛出异常，peek()返回null</li>
</ul>
</li>
</ul>
<p>队列<strong>通常（但并非一定）</strong>以 FIFO（先进先出）的方式排序各个元素。不过<strong>优先级队列</strong>和 <strong>LIFO 队列（或堆栈）</strong>例外，前者根据<strong>提供的比较器或元素的自然顺序对元素进行排序</strong>，后者按 <strong>LIFO（后进先出）的方式</strong>对元素进行排序。无论使用哪种排序方式，队列的头都是调用 remove() 或 poll() 所移除的元素。在 FIFO 队列中，所有的新元素都插入队列的末尾。其他种类的队列可能使用不同的元素放置规则。每个 Queue 实现必须指定其顺序属性。</p>
<h5 id="1-2-2双端队列-Deque"><a href="#1-2-2双端队列-Deque" class="headerlink" title="1.2.2双端队列(Deque)"></a>1.2.2双端队列(Deque)</h5><p><strong>Deque</strong> 是一个双端队列接口，继承自 Queue 接口，Deque的实现类是 LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList 是最常用的。</p>
<p><strong>Deque 的用途：</strong></p>
<ul>
<li><p>普通队列（一端进一端出）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="type">Deque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();<span class="comment">// 双端队列也可以实现单端队列的功能</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>双端队列（两端都可进出）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Deque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Deque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：Java 堆栈 Stack 已经过时，Java 官方推荐使用 Deque 替代 Stack 使用。Deque 堆栈操作方法：push()、pop()、peek()。</p>
<p><img src="/2023/08/16/Data-Structure/image-20230808091228370.png" alt="image-20230808091228370"></p>
<p><strong>双端队列与单端队列方法映射关系</strong></p>
<table>
<thead>
<tr>
<th><strong>Queue方法</strong></th>
<th><strong>等效Deque方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>add(e)</td>
<td>addLast(e)</td>
</tr>
<tr>
<td>offer(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>poll()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p><strong>双端队列与堆栈的方法映射关系</strong></p>
<table>
<thead>
<tr>
<th><strong>堆栈方法</strong></th>
<th><strong>等效Deque方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFirst(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<h3 id="2-延迟队列的实现——实战"><a href="#2-延迟队列的实现——实战" class="headerlink" title="2.延迟队列的实现——实战"></a>2.延迟队列的实现——实战</h3><h3 id="3-常见面试题"><a href="#3-常见面试题" class="headerlink" title="3.常见面试题"></a>3.常见面试题</h3><ul>
<li><p>单端队列和双端队列，分别对应的实现类是哪个？</p>
<p>单端队列：LinkedList 和 PriorityList</p>
<p>双端队列：LinkedList 和 ArrayDeque</p>
</li>
<li><p>简述延迟队列&#x2F;优先队列的实现方式</p>
<p>DelayQueue 是一个 BlockingQueue（无界阻塞）队列，它封装了一个使用完全二叉堆排序元素的 PriorityQueue（优先队列）。在添加元素时使用 Delay（延迟时间）作为排序条件，延迟最小的元素会优先放到队首。并且在删除和添加元素的时候都会添加锁，从而保证线程安全。</p>
</li>
<li><p>二叉堆插入&#x2F;弹出元素的过程</p>
<p><strong>插入：</strong>首先二叉堆的性质是父节点的值小于等于子节点，因此在插入元素时，首先将其插入二叉堆末尾，然后判断该元素与父节点值的大小，如果小于父节点的值，则进行上移，指导满足二叉堆的性质</p>
<p><strong>弹出：</strong>元素的出队只要把根元素直接删除弹出即可。但是在根元素迁移走后，寻找另外的最小元素迁移到堆头。这个过程与入队正好相反，这是一个不断向下迁移的过程。</p>
</li>
<li><p>延迟队列的使用场景</p>
<p>定时任务调度、任务重试、延迟发送。</p>
<ol>
<li>延迟消费。比如：<ul>
<li>用户生成订单之后，需要过一段时间校验订单的支付状态，如果订单仍未支付则需要及时地关闭订单。</li>
<li>用户注册成功之后，需要过一段时间比如一周后校验用户的使用情况，如果发现用户活跃度较低，则发送邮件或者短信来提醒用户使用。</li>
</ul>
</li>
<li>延迟重试。比如消费者从队列里消费消息时失败了，但是想要延迟一段时间后自动重试。</li>
</ol>
</li>
<li><p>延迟队列为什么添加信号量</p>
<p>信号量（Semaphore）是一种用于控制对共享资源的访问的机制，它可以用来<strong>限制同时访问某一资源的线程或进程的数量</strong>。信号量常用于避免竞争条件，确保多个线程或进程能够有序地访问共享资源，从而防止数据损坏或不一致性。将信号量与延迟队列结合起来，可以在某些特定场景下实现更为复杂的业务逻辑。例如，在一个需要执行多个延迟任务的系统中，通过使用信号量可以控制同时执行这些任务的数量，以避免资源过度消耗，同时保证任务的有序执行。</p>
<ol>
<li><strong>限制并发执行数量</strong>：在某些情况下，你可能希望限制延迟队列中的任务并发执行的数量，以免资源被过度占用。信号量可以帮助你控制同时处理的任务数量，从而避免系统过载。</li>
<li><strong>平滑流量</strong>：如果你有一个大量的延迟任务需要执行，使用信号量可以使这些任务以适当的速率被执行，而不是一下子全部执行，从而平滑系统的负载。</li>
<li><strong>优先级控制</strong>：通过设置不同的信号量值，你可以为不同的延迟任务设定不同的优先级。这样，你可以确保高优先级的任务能够更快地得到执行。</li>
<li><strong>资源管理</strong>：延迟队列可能需要占用一些系统资源，通过信号量可以控制这些资源的使用，避免资源浪费或冲突。</li>
</ol>
</li>
</ul>
<h3 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h3><p><strong>逻辑移位</strong>和<strong>算数移位</strong></p>
<p><strong>逻辑移位：（&gt;&gt;&gt;）</strong></p>
<ul>
<li><strong>逻辑左移</strong>：将二进制数的所有位都向左移动，右侧填充0。这会使数值增大，相当于乘以2的移动次幂。</li>
<li><strong>逻辑右移</strong>：将二进制数的所有位都向右移动，左侧填充0。这会使数值减小，相当于除以2的移动次幂。</li>
</ul>
<p><strong>算数移位:（&gt;&gt;）</strong></p>
<ul>
<li><strong>算数左移</strong>：将二进制数的所有位都向左移动，右侧填充0。这类似于逻辑左移，但在最左侧的符号位不变。</li>
<li><strong>算数右移</strong>：将二进制数的所有位都向右移动，左侧使用最左侧的位来填充。这会保持符号位不变，但数值会减小，相当于除以2的移动次幂。</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="1-栈的简介"><a href="#1-栈的简介" class="headerlink" title="1.栈的简介"></a>1.栈的简介</h3><p>栈是一种 LIFO（后进先出）的线性的数据结构，或者更抽象说是一种顺序集合，push 和 pop 操作只发生在结构的一端，称为栈顶。</p>
<blockquote>
<p>注意：之前刷算法也确实存在这个问题。栈使用的时候一定不要使用 Stack 类，这个类是在 JDK1.0 的时候创建的，性能较差。应当使用 ArrayDeque 或者 LinkedList 来实现</p>
</blockquote>
<h3 id="2-ArrayDeque"><a href="#2-ArrayDeque" class="headerlink" title="2.ArrayDeque"></a>2.ArrayDeque</h3><p>ArrayDeque 是一个基于数组实现的栈数据结构，在数据存放时元素通过<strong>二进制与运算</strong>获取对应的索引存放元素。当数组长度超过初始空间后，进行<strong>2的n次幂左移一位扩容</strong>，并<strong>将数组内容的元素按照分半分别进行迁移</strong>。</p>
<p><strong>源码解析：</strong></p>
<p>由于Deque接口是双向队列，所以再进行添加元素的时候会指定head指针和tail尾指针，head指针指向数据元素的头部，tail指针指向数据元素的尾部，通过head指针和tail指针控制是从头部进行操作还是尾部进行操作，以下是ArrayDeque中的字段信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组存储的元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头指针。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾指针。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组的默认最小大小。长度必须是2的幂次方。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-1数组长度"><a href="#2-1数组长度" class="headerlink" title="2.1数组长度"></a>2.1数组长度</h4><p>首先我们来解决第一个问题，就是<strong>数组的长度的问题</strong>，数组长度前面说必须是2的幂次方，但是看到构造函数中可以指定数组的长度，既然可以指定数组的长度，那这里指定数组长度为10，这个数字也不是2的幂次方啊，其实我们指定的虽然不是2的幂次方，但是ArrayDeque内部会帮我进行调整，调整数组长度为2的幂次方，先看一下ArrarDeque的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认长度为16的数组。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span> &#123;</span><br><span class="line">    elements = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定数组长度，发现指定数组长度时，调用了allocateElements方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定集合并且初始化大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到，除了无参构造会构造一个默认长度的数组以外，其他构造方式都需要<code>allocateElements</code>函数来进行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化数组大小，调用calculateSize方法来调整容量大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">allocateElements</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">    elements = <span class="keyword">new</span> <span class="title class_">Object</span>[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>allocateElements</code> 又通过 <code>calculateSize</code> 来进行调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateSize</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">  	<span class="comment">// 获取最小的初始化容量大小。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">initialCapacity</span> <span class="operator">=</span> MIN_INITIAL_CAPACITY;</span><br><span class="line">	<span class="comment">// 如果容量大于最小的容量，则寻找一个2的幂次方的值。</span></span><br><span class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        initialCapacity++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 返回2的幂次方值。</span></span><br><span class="line">    <span class="keyword">return</span> initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们传入的参数值为 10，即 1010 。下面分析如何得到 2 的幂次方。</p>
<ul>
<li>判断条件 10 &gt; 8 成立，进入 if 语句判断中。<code>numElements</code> &#x3D; 10，<code>initialCapacity</code> &#x3D; 10;</li>
<li><code>initialCapacity</code> 向右移位 1，从而得到 0101，与 1010 进行或运算，得到 1111</li>
<li><code>initialCapacity</code> 向右挪动两位，再与 1111 做或运算，得到的依旧是 1111</li>
<li>直到最后，<code>initialCapacity</code> 保持 1111，然后对其进行 ++ 操作，得到 <code>initialCapacity</code> 为16</li>
</ul>
<p><strong>整体思路是每次移动将位数最高的值变成1，从而将二进制所有位数都变成1，变成1之后得到的十进制加上1之后得到值就是2的幂次方的值</strong>，这里的操作在JDK1.7版本中的HashMap扩容操作代码是类似的。</p>
<h4 id="2-2AddFirst方法"><a href="#2-2AddFirst方法" class="headerlink" title="2.2AddFirst方法"></a>2.2AddFirst方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时初始化时数组长度为16，头指针head和尾指针head默认是0，此时数组的内容如下所示：</p>
<img src="/2023/08/16/Data-Structure/fb2e937c088a462793a0b3ea44d3f64dtplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="添加队头元素图一" style="zoom:50%;">

<p>当执行addFirst方法插入数组元素5时，通过源码可以看到需要执行<code>elements[head = (head - 1) &amp; (elements.length - 1)] = e;</code>这一行代码，至于后面那个head=&#x3D;tail是为了扩容使用，也就是只有在队列满时才会对数组进行扩容操作，队列满的标识是head&#x3D;&#x3D;tail代表队列已经满了，这里先进行分析<code>elements[head = (head - 1) &amp; (elements.length - 1)] = e</code>，我们将其拆分成如下内容</p>
<ul>
<li>head&#x3D;head-1，此时的head&#x3D;0，那么head-1得到值15（二进制减法操作），15使用二进制表示为：1111</li>
<li>elements.length - 1，这里开始是初始化大小为10，通过calculateSize方法计算的到数组长度为16，16-1&#x3D;15，二进制表示方式也是1111。</li>
<li>1111&amp;1111依然是1111，此时数组的下标为15。即将元素插入到下标为 15 的位置</li>
</ul>
<img src="/2023/08/16/Data-Structure/b80a1b668b754d4bbf40372c9141c241tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="队头插入元素图二" style="zoom:50%;">

<h4 id="2-3AddLast方法"><a href="#2-3AddLast方法" class="headerlink" title="2.3AddLast方法"></a>2.3AddLast方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用<code> elements[tail] = e;</code>即可添加元素，然后将指针向后移动。此时数组中元素存储情况以及tail指针移动位置如图。</p>
<img src="/2023/08/16/Data-Structure/11baa42345494f23aa045fd99088a136tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="队尾添加元素图一" style="zoom:50%;">

<h4 id="2-4pollFirst方法"><a href="#2-4pollFirst方法" class="headerlink" title="2.4pollFirst方法"></a>2.4pollFirst方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">// 获取头指针。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="comment">// 获取头指针对应的数组元素值。</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[h];</span><br><span class="line">    <span class="comment">// Element is null if deque empty</span></span><br><span class="line">  	<span class="comment">// 如果为空则说明说明数组为空，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  	<span class="comment">// 将头指针值设置为空。</span></span><br><span class="line">    elements[h] = <span class="literal">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">  	<span class="comment">// 啊哈？这里是不是我们上面猜测的内容，头指针下一个位置。</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/16/Data-Structure/image-20230808122429694.png" alt="image-20230808122429694"></p>
<h4 id="2-5pollLast方法"><a href="#2-5pollLast方法" class="headerlink" title="2.5pollLast方法"></a>2.5pollLast方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">// 找到尾指针的前一个指针位置。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  	<span class="comment">// 获取尾部元素。</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[t];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  	<span class="comment">// 将尾部元素设置为空。</span></span><br><span class="line">    elements[t] = <span class="literal">null</span>;</span><br><span class="line">  	<span class="comment">// 调整尾指针位置。</span></span><br><span class="line">    tail = t;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6扩容操作"><a href="#2-6扩容操作" class="headerlink" title="2.6扩容操作"></a>2.6扩容操作</h4><p>如上分析，我们在队头或队尾添加元素的时候都会出现容量已满需要扩容的情况。由于今天学习的数据结构是栈，栈满足的条件是后进先出，添加元素的时候使用 push，而不是分队头队尾分别添加。</p>
<p>我们以向栈中一次加入1、2、3、4为例。</p>
<ol>
<li><p>首先假设最初栈数组长度为 2（仅限于举例，实际栈长度默认最小为 8）。</p>
<img src="/2023/08/16/Data-Structure/image-20230808120939501.png" alt="扩容操作图一" style="zoom: 80%;">

<ul>
<li><p>根据前面的分析，head 处于数组最后的位置，即 index 最大的位置向前进行元素添加。</p>
</li>
<li><p>在进行输出的时候，<code>head = (head + 1) &amp; (n - 1)</code> 也就是从下标小到大依次进行输出</p>
</li>
</ul>
</li>
<li><p>触发扩容操作之后，扩容操作分为两步，前半段和后半段</p>
<ul>
<li><p>ArrayDeque 每次都把 tail 设置为中点，那么只要 <code>head == tail</code>，那么head 就是中点，因此 head 之前的为前半段，head 之后的为后半段。第一次扩容由于tail 是 0。所以第一次扩容直接全部复制到新数组中。</p>
<img src="/2023/08/16/Data-Structure/image-20230808121843836.png" alt="image-20230808121843836" style="zoom: 80%;">
</li>
<li><p>之后扩容会将前半段和后半段分别进行复制操作<img src="/2023/08/16/Data-Structure/image-20230808121913433.png" alt="image-20230808121913433" style="zoom:80%;"></p>
</li>
</ul>
</li>
</ol>
<p><strong>栈的弹出操作：</strong></p>
<p><img src="/2023/08/16/Data-Structure/image-20230808122059457.png" alt="image-20230808122059457"></p>
<h3 id="3-常问面试题"><a href="#3-常问面试题" class="headerlink" title="3.常问面试题"></a>3.常问面试题</h3><ol>
<li><p>堆栈的使用场景？</p>
<p>适用于<strong>后进先出</strong>的数据结构使用场景。</p>
</li>
<li><p>为什么不是用 Stack 类？</p>
<ul>
<li><p>性能上看，Deque 性能优于 Stack 。</p>
<blockquote>
<p>Stack和Vector都是线程安全的，其实多数情况下并不需要做到线程安全，因此没有必要使用Stack。毕竟保证线程安全需要上锁，有额外的系统开销。</p>
</blockquote>
</li>
<li><p>Stack从Vector继承的一个副作用是，暴露了set&#x2F;get方法，可以进行随机位置的访问，这与Stack只能从尾巴上进行增减的本意相悖。此外，Deque在转成ArrayList或者stream的时候保持了“后进先出”的语义，而Stack因为是从Vector继承，没有这个语义。</p>
</li>
</ul>
</li>
<li><p>ArrayDeque 是基于什么实现的？</p>
<p>数组</p>
</li>
<li><p>ArrayDeque 数据结构使用过程叙述。</p>
<p>使用过程见上</p>
</li>
<li><p>ArrayDeque 为什么要初始化2的n次幂个长度？</p>
<p>保证了在后续计算元素索引位置时，可以进行与运算。也就说 2的n次幂 -1 得到的值是一个011111的范围，在与元素索引位置计算时候，找到两个值之间1的位置即可。</p>
</li>
</ol>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="1-哈希表的简介"><a href="#1-哈希表的简介" class="headerlink" title="1.哈希表的简介"></a>1.哈希表的简介</h3><blockquote>
<p>在计算机科学中，一个哈希表（hash table、hash map）是一种实现关联数组的抽象数据结构，该结构将键通过哈希计算映射到值。也就是说我们通过对一个 Key 值计算它的哈希并与长度为2的n次幂的数组减一做与运算，计算出槽位对应的索引，将数据存放到索引下。那么这样就解决了当获取指定数据时，只需要根据存放时计算索引ID的方式再计算一次，就可以把槽位上对应的数据获取处理，以此达到时间复杂度为O(1)的情况。</p>
</blockquote>
<p>哈希表也叫散列表，哈希表是一种根据关键码值 (key value) 而直接进行访问的数据结构。它提供了快速的插入操作和查找操作，无论哈希表总中有多少条数据，**插入和查找的时间复杂度都是为O(1)**，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表。</p>
<p>总结来说，哈希表的存在是为了解决能通过 O(1) 时间复杂度直接索引到指定元素。</p>
<p>理想的情况是所有存入 key 的哈希值都不相同，即位于不同的位置。但是随着元素的增多，很可能发生<strong>哈希冲突</strong>，或者哈希值波动不大导致索引计算相同，也就是一个索引位置出现多个元素情况。解决这个问题产生了许多不同的方案，如HashMap 中的拉链寻址 + 红黑树、扰动函数、负载因子、ThreadLocal 的开放寻址、合并散列、杜鹃散列、跳房子哈希、罗宾汉哈希等各类数据结构设计。</p>
<h3 id="2-哈希表的实现"><a href="#2-哈希表的实现" class="headerlink" title="2.哈希表的实现"></a>2.哈希表的实现</h3><h4 id="2-1哈希碰撞"><a href="#2-1哈希碰撞" class="headerlink" title="2.1哈希碰撞"></a>2.1哈希碰撞</h4><p>首先实现一个简单的 hashmap，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap01</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] tab = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        tab[idx] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (V) tab[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种结构会发生哈希碰撞</li>
<li>使用哈希散列必须解决的一个问题，无论是在已知元素数量的情况下，通过扩容数组长度解决，还是把碰撞的元素通过链表存放，都是可以的。</li>
</ul>
<h4 id="2-2拉链寻址"><a href="#2-2拉链寻址" class="headerlink" title="2.2拉链寻址"></a>2.2拉链寻址</h4><p>既然我们没法控制元素不碰撞，但我们可以对碰撞后的元素进行管理。比如像 HashMap 中拉链法一样，把碰撞的元素存放到链表上。这里我们就来简化实现一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap02BySeparateChaining</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Node&lt;K, V&gt;&gt;[] tab = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            tab[idx].add(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[idx].add(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K, V&gt; kvNode : tab[idx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(kvNode.getKey())) &#123;</span><br><span class="line">                <span class="keyword">return</span> kvNode.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为元素在存放到哈希桶上时，可能发生下标索引膨胀，所以这里我们把每一个元素都设定成一个 Node 节点，这些节点通过 LinkedList 链表关联，当然你也可以通过 Node 节点构建出链表 next 元素即可。</li>
<li>那么这时候在发生元素碰撞，相同位置的元素就都被存放到链表上了，获取的时候需要对存放多个元素的链表进行遍历获取。</li>
</ul>
<h4 id="2-3开放寻址"><a href="#2-3开放寻址" class="headerlink" title="2.3开放寻址"></a>2.3开放寻址</h4><p>除了对哈希桶上碰撞的索引元素进行拉链存放，还有不引入新的额外的数据结构，只是在哈希桶上存放碰撞元素的方式。它叫开放寻址，也就是 ThreaLocal 中运用斐波那契散列+开放寻址的处理方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap03ByOpenAddressing</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] tab = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; tab.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tab[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; tab.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tab[idx] != <span class="literal">null</span> &amp;&amp; tab[idx].key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> tab[idx].value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>开放寻址的设计会对碰撞的元素，寻找哈希桶上新的位置，这个位置从当前碰撞位置开始向后寻找，直到找到空的位置存放。</li>
<li>在 ThreadLocal 的实现中会使用斐波那契散列、索引计算累加、启发式清理、探测式清理等操作，以保证尽可能少的碰撞。</li>
</ul>
<h4 id="2-4合并散列"><a href="#2-4合并散列" class="headerlink" title="2.4合并散列"></a>2.4合并散列</h4><p>合并散列是开放寻址和单独链接的混合，碰撞的节点在哈希表中链接。此算法适合固定分配内存的哈希桶，通过存放元素时识别哈希桶上的最大空槽位来解决合并哈希中的冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap04ByCoalescedHashing</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] tab = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> tab.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tab[cursor] != <span class="literal">null</span> &amp;&amp; tab[cursor].key != key) &#123;</span><br><span class="line">            --cursor;</span><br><span class="line">        &#125;</span><br><span class="line">        tab[cursor] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将碰撞节点指向这个新节点</span></span><br><span class="line">        <span class="keyword">while</span> (tab[idx].idxOfNext != <span class="number">0</span>)&#123;</span><br><span class="line">            idx = tab[idx].idxOfNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[idx].idxOfNext = cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (tab[idx].key != key) &#123;</span><br><span class="line">            idx = tab[idx].idxOfNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab[idx].value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="type">int</span> idxOfNext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>合并散列的原理是，当发生哈希冲突之后，将冲突的元素加到哈希表的最后，然后将当前哈希值的指针指向冲突的元素。也就是将发生哈希碰撞的元素进行链接。</li>
<li>合并散列的最大目的在于将碰撞元素链接起来，避免因为需要寻找碰撞元素所发生的循环遍历。也就是A、B元素存放时发生碰撞，那么在找到A元素的时候可以很快的索引到B元素所在的位置。</li>
</ul>
<h4 id="2-5杜鹃散列"><a href="#2-5杜鹃散列" class="headerlink" title="2.5杜鹃散列"></a>2.5杜鹃散列</h4><p>这个名字起的比较有意思，也代表着它的数据结构。杜鹃鸟在孵化🐣的时候，雏鸟会将其他蛋或幼崽推出巢穴；类似的这个数据结构会使用2组key哈希表，将冲突元素推到另外一个key哈希表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">boolean</span> isRehash)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">k</span> <span class="operator">=</span> maskNull(key);</span><br><span class="line">    <span class="keyword">if</span> (containsKey(k)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (insertEntry(<span class="keyword">new</span> <span class="title class_">Entry</span>&lt;K, V&gt;((K) k, value))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRehash) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rehash(<span class="number">2</span> * table.length);</span><br><span class="line">    <span class="keyword">return</span> put((K) k, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">insertEntry</span><span class="params">(Entry&lt;K, V&gt; e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Entry&lt;K, V&gt; current = e;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(hash1, current.key);</span><br><span class="line">    <span class="keyword">while</span> (current != e || count &lt; table.length) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; temp = table[index];</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">            table[index] = current;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = current;</span><br><span class="line">        current = temp;</span><br><span class="line">        <span class="keyword">if</span> (index == hash(hash1, current.key)) &#123;</span><br><span class="line">            index = hash(hash2, current.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index = hash(hash1, current.key);</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/08/16/Data-Structure/algorithms-220824-12.png" alt="img" style="zoom:50%;">

<ul>
<li>当多个键映射到同一个单元格时会发生这种情况。杜鹃散列的基本思想是通过使用两个散列函数而不是仅一个散列函数来解决冲突。</li>
<li>这为每个键在哈希表中提供了两个可能的位置。在该算法的一种常用变体中，哈希表被分成两个大小相等的较小的表，每个哈希函数都为这两个表之一提供索引。两个散列函数也可以为单个表提供索引。</li>
<li>在实践中，杜鹃哈希比线性探测慢约 20-30%，线性探测是常用方法中最快的。然而，由于它对搜索时间的最坏情况保证，当需要实时响应率时，杜鹃散列仍然很有价值。杜鹃散列的一个优点是它的无链接列表属性，非常适合 GPU 处理。</li>
</ul>
<p><img src="/2023/08/16/Data-Structure/image-20230808152750451.png" alt="image-20230808152750451"></p>
<img src="/2023/08/16/Data-Structure/image-20230808152808965.png" alt="image-20230808152808965" style="zoom:80%;">

<h4 id="2-6跳房子散列"><a href="#2-6跳房子散列" class="headerlink" title="2.6跳房子散列"></a>2.6跳房子散列</h4><p>跳房子散列是一种基于开放寻址的算法，它结合了杜鹃散列、线性探测和链接的元素，通过桶邻域的概念——任何给定占用桶周围的后续桶，也称为“虚拟”桶。 该算法旨在在哈希表的负载因子增长超过 90% 时提供更好的性能；它还在并发设置中提供了高吞吐量，因此非常适合实现可调整大小的并发哈希表。</p>
<p>跳房子散列的思路：<strong>用事先确定的，对计算机底层体系结构而言最优的一个常数</strong>，给探测序列的最大长度加个上界。三大特点：线性探测、探测长度有上限、上限是提前确定的。</p>
<p><strong>举个例子进行理解：</strong></p>
<p>a）设置<strong>最大探测上界</strong> MAX_DIST &#x3D; 4</p>
<p>b）散列位置 hash(x)，则探测位置为 hash(x) + 0、hash(x) + 1、hash(x) + 2、hash(x) +3。</p>
<p>c）下例：<br><img src="/2023/08/16/Data-Structure/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RoY2FvMTExMg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p><img src="/2023/08/16/Data-Structure/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RoY2FvMTExMg==,size_16,color_FFFFFF,t_70-16914781973725.png" alt="在这里插入图片描述"></p>
<ul>
<li>插入 A 时，在 7 的位置没有元素，因此直接插入 <code>hash(x) + 0</code> 的位置，因此 Hop 为 1000，同理插入 B C</li>
<li>插入 D 的时候，发现 7 的位置已经存在元素，因此将其存入 hash(x) + 1的位置，并且将 A 的 Hop 值设置为 1100（表示hash + 0和 hash + 1的位置都有元素），D 的 Hop 设置为 0000.</li>
<li>插入 E 的时候，发现被 D 占有了，因此向下寻找，直到 10 这个位置，并将 D 的值设置为 0010 （代表hash(x) + 2 的位置）</li>
<li>添加 G F</li>
</ul>
<blockquote>
<p>问：如果线性探测，直到上界都无法插入呢？</p>
<p>答：当我们上界设置得不够大时，这种情况是必须考虑的。此时的插入流程将会稍微复杂。</p>
<p>例如：我们在上述例子中继续插入H，散列值为9。我们探测位置9、10、11、12都被占用，只能到13，但是位置13明显超过上界，即h a s h ( x ) + 3 hash(x)+3hash(x)+3都未能找到可插入点。那我们将找一个值y来替换掉。并把它重置到位置13。可以去到位置13的值只有散列值为10、11、12、13的值。如果我们检查Hop[10]，它的值为“0000”，没有可以替换的候选项，于是我们检查Hop[11],它的值为“1000”，其值为G，可以被放到位置13。于是我们将元素G放到位置13，将11空出来，插入H。</p>
</blockquote>
<h4 id="2-7罗宾汉哈希"><a href="#2-7罗宾汉哈希" class="headerlink" title="2.7罗宾汉哈希"></a>2.7罗宾汉哈希</h4><p>罗宾汉哈希法算法思想是，当我们进行插入时，如果发现单元格被其他键值对占用，那么就需要比较这俩人键距离其原本位置的距离。距离较远的键值对留下，距离较近的被迫后移。</p>
<p>举个例子：</p>
<p><img src="/2023/08/16/Data-Structure/image-20230808152218517.png" alt="image-20230808152218517"></p>
<ul>
<li>A B 正常插入</li>
<li>C 插入时，A 已经被占，C 被迫后移</li>
<li>D 插入时，C 已经被占，并且 C 的偏移量大于 D，因此 D 后移</li>
<li>E 插入时，在 A 处偏移量与 A 相同，所以 E 后移，到 C 的位置处，二者偏移量依旧相同，继续后移</li>
<li>到 D 位置的时候，此时 E 偏移量大于 D ，因此 D 后移</li>
</ul>
<h3 id="3-常见面试题-1"><a href="#3-常见面试题-1" class="headerlink" title="3.常见面试题"></a>3.常见面试题</h3><ol>
<li><p>介绍一下散列表</p>
<p>散列表，也称为哈希表或散列映射，是一种用于存储和检索数据的数据结构。它基于散列函数的原理，将键映射到值，从而实现快速的数据查找和插入操作。散列表在计算机科学中被广泛用于高效地管理大量数据。</p>
</li>
<li><p>为什么使用散列表</p>
<p>为了解决通过 O(1)时间复杂度直接索引到指定元素。</p>
</li>
<li><p>拉链寻址和开放寻址的区别</p>
<p>拉链寻址是把碰撞的元素存放到链表上。开放寻址是冲突的键值对被直接存储在散列表中，而不是存储在其他数据结构中。当冲突发生时，会寻找下一个可用的槽位，直到找到一个空槽或者散列表已满。常见的开放寻址方法包括线性探测、二次探测和双重散列等。</p>
</li>
<li><p>还有其他什么方式可以解决散列哈希索引冲突</p>
<p>合并散列、跳房子散列、罗宾汉散列、杜鹃散列</p>
</li>
<li><p>对应的Java源码中，对于哈希索引冲突提供了什么样的解决方案</p>
<p><strong>java源码哈希索引冲突是通过拉链寻址解决的。</strong></p>
</li>
</ol>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="1-堆的简介"><a href="#1-堆的简介" class="headerlink" title="1.堆的简介"></a>1.堆的简介</h3><p><strong>堆(heap)</strong> 的实现是一种基于树的特殊的数据结构，它可以在数组上构建出树的结构体，并满足堆的属性。常见的堆有二叉堆、最大堆、最小堆、斐波那契堆等等。</p>
<p><strong>最小堆：</strong></p>
<p>父节点的值始终小于子节点的值，则称之为最小堆。</p>
<img src="/2023/08/16/Data-Structure/heap-01.png" alt="img" style="zoom:50%;">

<p><strong>最大堆：</strong></p>
<p>父节点的值始终大于子节点的值，则称之为最大堆。</p>
<img src="/2023/08/16/Data-Structure/heap-02.png" alt="img" style="zoom:50%;">

<h3 id="2-堆的代码实现"><a href="#2-堆的代码实现" class="headerlink" title="2.堆的代码实现"></a>2.堆的代码实现</h3><p>堆的实现在 Java API 中主要体现在延迟队列的实现二叉堆上，这里单独把这部分代码拆分出来，了解下关于小堆和大堆的实现。</p>
<p>从对堆的数据结构介绍上可以看到，小堆和大堆的唯一区别仅是对元素的排序方式不同。所以也就是说在存放和获取元素的时候对元素的填充和摘除时，排序方式不同而已。</p>
<h4 id="2-1入堆方法"><a href="#2-1入堆方法" class="headerlink" title="2.1入堆方法"></a>2.1入堆方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】元素：&#123;&#125; 当前队列：&#123;&#125;&quot;</span>, JSON.toJSONString(x), JSON.toJSONString(queue));</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取父节点Idx，相当于除以2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        logger.info(<span class="string">&quot;【入队】寻找当前节点的父节点位置。k：&#123;&#125; parent：&#123;&#125;&quot;</span>, k, parent);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="comment">// 如果当前位置元素，大于父节点元素，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (compareTo(x, (E) e) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【入队】值比对，父节点：&#123;&#125; 目标节点：&#123;&#125;&quot;</span>, JSON.toJSONString(e), JSON.toJSONString(x));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相反父节点位置大于当前位置元素，则进行替换</span></span><br><span class="line">        logger.info(<span class="string">&quot;【入队】替换过程，父子节点位置替换，继续循环。父节点值：&#123;&#125; 存放到位置：&#123;&#125;&quot;</span>, JSON.toJSONString(e), k);</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">    logger.info(<span class="string">&quot;【入队】完成 Idx：&#123;&#125; Val：&#123;&#125; \r\n当前队列：&#123;&#125; \r\n&quot;</span>, k, JSON.toJSONString(x), JSON.toJSONString(queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>以入堆 2 作为例子来看。</p>
<img src="/2023/08/16/Data-Structure/heap-03.png" alt="img" style="zoom: 33%;">
</li>
<li><p>首先将元素2挂到队列尾部，之后通过 (k - 1) &gt;&gt;&gt; 1 计算父节点位置，与对应元素进行比对和判断交换。</p>
</li>
<li><p>交换过程包括 2-&gt;6、2-&gt;5，以此交换结束后元素保存完毕。</p>
</li>
</ul>
<h4 id="2-2出堆方法"><a href="#2-2出堆方法" class="headerlink" title="2.2出堆方法"></a>2.2出堆方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="comment">// 先找出中间件节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 找到左子节点和右子节点，两个节点进行比较，找出最大的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左子节点与右子节点比较，取最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; compareTo((E) c, (E) queue[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;【出队】左右子节点比对，获取最小值。left：&#123;&#125; right：&#123;&#125;&quot;</span>, JSON.toJSONString(c), JSON.toJSONString(queue[right]));</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值与c比较，当目标值小于c值，退出循环。说明此时目标值所在位置适合，迁移完成。</span></span><br><span class="line">        <span class="keyword">if</span> (compareTo(x, (E) c) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值小于c值，位置替换，继续比较</span></span><br><span class="line">        logger.info(<span class="string">&quot;【出队】替换过程，节点的值比对。上节点：&#123;&#125; 下节点：&#123;&#125; 位置替换&quot;</span>, JSON.toJSONString(queue[k]), JSON.toJSONString(c));</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把目标值放到对应位置</span></span><br><span class="line">    logger.info(<span class="string">&quot;【出队】替换结果，最终更换位置。Idx：&#123;&#125; Val：&#123;&#125;&quot;</span>, k, JSON.toJSONString(x));</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>出堆只要将根节点直接删除弹出即可，但是重要的是出堆之后其他节点的排序</p>
<img src="/2023/08/16/Data-Structure/heap-04.png" alt="img" style="zoom:50%;"></li>
</ul>
<p>这里以弹出元素1举例，之后将堆尾元素替换到相应的位置。整个过程分为6张图表述。</p>
<ol>
<li>图1到图2，找出根元素弹出。</li>
<li>图3到图4，将根元素向下迁移，与子元素比对，并替换位置。如果这个位置与8相比，小于8则继续向下迁移。</li>
<li>图4到图5，继续迁移，在原节点4的位置对应的两个子元素，都比8大，这个时候就可以停下来了。</li>
<li>图5到图6，更换元素位置，把队尾的元素替换到对应元素1向下迁移检测的位置。</li>
</ol>
<h4 id="2-3小堆的实现"><a href="#2-3小堆的实现" class="headerlink" title="2.3小堆的实现"></a>2.3小堆的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer firstElement, Integer secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstElement.compareTo(secondElement);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用正序比，也就是 first &gt; second 则返回true</li>
</ul>
<h4 id="2-4大堆的实现"><a href="#2-4大堆的实现" class="headerlink" title="2.4大堆的实现"></a>2.4大堆的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxHeap</span> <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer firstElement, Integer secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> secondElement.compareTo(firstElement);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用反序比，也就是 first &lt; second 则返回true</li>
</ul>
<h3 id="3-常见面试题-2"><a href="#3-常见面试题-2" class="headerlink" title="3.常见面试题"></a>3.常见面试题</h3><ol>
<li><p>堆的数据结构是什么样？</p>
<p><strong>堆(heap)</strong> 的实现是一种基于树的特殊的数据结构，它可以在数组上构建出树的结构体，并满足堆的属性。</p>
</li>
<li><p>堆的数据结构使用场景？</p>
<p>优先级队列、堆排序、动态中位数查找、最大最小堆</p>
</li>
<li><p>堆的数据结构实现方式有哪些？</p>
<p>最大堆和最小堆</p>
</li>
<li><p>最小堆和最大堆的区别是什么？</p>
<p>最大堆的父节点的值大于子节点；最小堆子节点的值大于父节点。</p>
</li>
<li><p>有了解斐波那契堆吗？</p>
<p>斐波那契堆(Fibonacci heap)是计算机科学中最小堆有序树的集合。它和二项式堆有类似的性质，但比二项式堆有更好的均摊时间。堆的名字来源于斐波那契数，它常用于分析运行时间。</p>
<p>有关的内容可以见<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013148167/article/details/54236076">斐波那契堆(Fibonacci heap)原理详解</a></p>
</li>
</ol>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><h3 id="1-字典树的简介"><a href="#1-字典树的简介" class="headerlink" title="1.字典树的简介"></a>1.字典树的简介</h3><p>在计算机科学中，字典树(Trie)也被称为”单词查找树“或”数字树“，有时候也被称为基数树或前缀树（因为可以通过前缀的方式进行索引）。—— 它是一种搜索树，一种已排序的数据结构，通常用于<strong>存储动态集或键为字符串的关联数组</strong>。</p>
<p>与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<img src="/2023/08/16/Data-Structure/trie-01.png" alt="img" style="zoom:50%;">

<ul>
<li>这是一个把 battle 单词字符串，按照字母拆分到字典树进行存放的图。</li>
</ul>
<h3 id="2-字典树的实现"><a href="#2-字典树的实现" class="headerlink" title="2.字典树的实现"></a>2.字典树的实现</h3><p><strong>树枝节点：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 形成一个链 */</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] slot = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字母 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 单词：数量 &gt; 0 表示一个单词 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前缀 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> prefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 单词：具体的一个单词字符串 */</span></span><br><span class="line">    <span class="keyword">public</span> String word;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 解释：单词的注释说明 */</span></span><br><span class="line">    <span class="keyword">public</span> String explain;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于有26个英文字母，因此使用数组大小设置为26</li>
</ul>
<p><strong>插入单词：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String words, String explain)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordsTree;</span><br><span class="line">    <span class="type">char</span>[] chars = words.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// - a 从 0 开始，参考 ASCII 码表</span></span><br><span class="line">        <span class="keyword">if</span> (root.slot[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            root.slot[idx] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.slot[idx];</span><br><span class="line">        root.c = c;</span><br><span class="line">        root.prefix++;</span><br><span class="line">    &#125;</span><br><span class="line">    root.explain = explain; <span class="comment">// 单词的注释说明信息</span></span><br><span class="line">    root.isWord = <span class="literal">true</span>;     <span class="comment">// 循环拆解单词后标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>insert 方法接收单词和注释信息，并对一个单词按照 char 进行拆分，拆分后则计算出索引位置并以此存放。存放完成后标记单词和附属上单词的注释信息。</li>
</ul>
<p><strong>前缀查找：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordsTree;</span><br><span class="line">    <span class="type">char</span>[] chars = prefix.toCharArray();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 精准匹配：根据前置精准查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">// 匹配为空</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt; root.slot.length || idx &lt; <span class="number">0</span> || root.slot[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        cache.append(c);</span><br><span class="line">        root = root.slot[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模糊匹配：根据前缀的最后一个单词，递归遍历所有的单词</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root.prefix != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; root.slot.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.slot[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                collect(root.slot[i], String.valueOf(cache) + c, list, <span class="number">15</span>);</span><br><span class="line">                <span class="keyword">if</span> (list.size() &gt;= <span class="number">15</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> list;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(TrieNode trieNode, String pre, List&lt;String&gt; queue, <span class="type">int</span> resultLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到单词</span></span><br><span class="line">    <span class="keyword">if</span> (trieNode.isWord) &#123;</span><br><span class="line">        trieNode.word = pre;</span><br><span class="line">        <span class="comment">// 保存检索到的单词到 queue</span></span><br><span class="line">        queue.add(trieNode.word + <span class="string">&quot; -&gt; &quot;</span> + trieNode.explain);</span><br><span class="line">        <span class="keyword">if</span> (queue.size() &gt;= resultLimit) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用，查找单词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; trieNode.slot.length; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (trieNode.slot[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            collect(trieNode.slot[i], pre + c, queue, resultLimit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从字典树从检索元素的过程分为2部分，第1部分是根据提供的索引前缀精准匹配到单词信息，第2部分是根据索引前缀的最后一个单词开始，循环递归遍历从当前位置所能关联到的字母直至判断为是单词标记为结束，通过这样的方式把所有匹配动的单词索引出来。</li>
<li>list.size() &gt;&#x3D; 15 是判定索引的最大长度，超过这个数量就停止索引了，毕竟这是一种O(n)时间复杂度的操作，如果加载数十万单词进行匹配，执行速度还是比较耗时的。</li>
</ul>
<h3 id="3-常见面试题-3"><a href="#3-常见面试题-3" class="headerlink" title="3.常见面试题"></a>3.常见面试题</h3><ol>
<li><p>简述字典树的数据结构</p>
<p>字典树的每一个节点代表一个字符，从根节点到叶子节点的路径表示一个字符串。字典树的树节点包含一个节点数组，假设字典树存储的是单词，那么节点数组的长度为26。</p>
</li>
<li><p>叙述你怎么来实现一个字典树</p>
<ul>
<li>定义一个节点。节点信息包括节点数组，节点数组的长度由保存的数据决定。如果是保存英文单词，则数组长度为26。同时节点信息还要设置一个标识符，用来判断是否结束。例如如果保存的是字符串，则根据标识符可以知道，读取到当前字符的路径所形成的字符串是否是一个保存进字典树的字符串  </li>
<li>定义字典树结构，实例化根节点  <ul>
<li>定义插入方法：假设保存的是字符串，则循环处理进行保存。如果当前字符对应的位置为空，则创建一个新节点；并且将指针移动到相应位置处的节点上，处理下一个节点；当所有字符全部处理完毕，则插入成功</li>
<li>定义查询方法。查询方法分为两步<ul>
<li>精确匹配。根据给出的前缀字符串按序循环判断</li>
<li>模糊匹配，根据索引前缀的最后一个单词开始，循环递归遍历从当前位置所能关联到的字母直到判断为是单词标记结束，从而将所有符合前缀的单词全部索引出来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字典树的实际业务场景举例【排序、全文搜索、网络搜索引擎、生物信息】</p>
<ul>
<li><strong>自动补全和搜索提示</strong>：通过构建包含所有可能搜索关键字的字典树，可以在用户输入搜索关键字时，快速找到所有具有相同前缀的字符串，并将其作为搜索建议显示给用户</li>
<li><strong>单词拼写检查器</strong>：通过在字典树中搜索用户输入的单词，可以检查其是否正确拼写，或者找到可能的正确拼写建议</li>
<li><strong>字符串匹配</strong>：在文本搜索和字符串匹配算法中，字典树可以用于高效地找到给定模式串在目标文本中的所有出现位置</li>
<li><strong>词频统计</strong>：通过在字典树中插入所有单词，并记录每个单词的出现次数，可以高效地实现词频统计</li>
<li><strong>电话号码前缀匹配</strong>：在电话通讯系统中，字典树可以用于快速匹配用户拨打的电话号码前缀，以确定应该转接到哪个地区或服务中心</li>
<li><strong>编译器符号表</strong>：在编译器和解释器中，字典树可以用于实现符号表，记录程序中定义的变量、函数等符号及其对应的作用域和类型信息</li>
</ul>
</li>
<li><p>字典树的存入和检索的时间复杂度</p>
<p>O(n)</p>
</li>
<li><p>还有哪些字典树的实现方式【<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Suffix_tree">后缀树 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hash_trie">哈希树 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HAT-trie">帽子树 (opens new window)</a>】</p>
<p><strong>后缀树：</strong>后缀树是一种特殊的字典树，用于高效地存储一个字符串的所有后缀。后缀树在字符串处理和模式匹配等领域中非常有用，可以在线性时间内构建</p>
<p><strong>哈希树：</strong>也称为哈希字典或哈希字典树，是一种结合了哈希表和字典树的数据结构。哈希树的基本思想是将字符串按照字符顺序进行哈希，然后构建一个树结构来存储这些哈希值。每个节点都对应一个哈希值，通过从根节点到叶子节点的路径表示一个字符串。在哈希树中，哈希值相同的字符串会落在同一个分支上，因此具有相同前缀的字符串在哈希树中具有相似的结构。</p>
<p>哈希树的节点查找过程和节点插入过程类似，就是对关键字用质数序列取余，根据余数确定下一节点的分叉路径，直到找到目标节点。如图，最小”哈希树(HashTree)在从4G个对象中找出所匹配的对象，比较次数不超过10次。也就是说：最多属于O(10)。在实际应用中，调整了质数的范围，使得比较次数一般不超过5次。也就是说：最多属于O(5)。因此可以根据自身需要在时间和空间上寻求一个平衡点。</p>
<p>哈希表每层存储数据数量按照<strong>质数</strong>依次增加，一般都是从2开始，即第一层的结点有2个子节点，第二层结点每个节点都有3个子节点，第三层每个节点有5个子节点，第四层结点每个节点都有7个子节点第五层每个节点有11个子节点，第六层结点每个节点都有13个子节点第七层每个节点有17子节点</p>
<p><img src="/2023/08/16/Data-Structure/Center.png" alt="这里写图片描述"></p>
</li>
</ol>
<h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><h3 id="1-二分搜索树的简介"><a href="#1-二分搜索树的简介" class="headerlink" title="1.二分搜索树的简介"></a>1.二分搜索树的简介</h3><p>二叉搜索树（Binary Search Tree），也称二叉查找树。有序二叉树（Ordered Binary tree）、排序二叉树（Sorted Binary Tree）都是二叉搜索树。</p>
<p><strong>二叉搜索树的特点：</strong></p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ul>
<p><strong>二叉搜索树的缺点：</strong></p>
<p>二叉搜索树也是一颗没有经过调衡的基础性数据结构，在一定概率上它完成有可能退化成链表，也就是从近似O(logn)的时间复杂度退化到O(n)。关于二叉搜索树的平衡解决方案，包括；AVL树、2-3树、红黑树等。</p>
<h3 id="2-二叉搜索树的实现"><a href="#2-二叉搜索树的实现" class="headerlink" title="2.二叉搜索树的实现"></a>2.二叉搜索树的实现</h3><p>二叉搜索树是整个树结构中最基本的树，同时也是树这个体系中实现起来最容易的数据结构。但之所以要使用基于二叉搜索树之上的其他树结构，主要是因为使用数据结构就是对数据的存放和读取。那么为了提高吞吐效率，则需要尽可能的平衡元素的排序，体现在树上则需要进行一些列操作，所以会有不同的结构树实现。</p>
<p><strong>定义树枝：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer value;</span><br><span class="line"><span class="keyword">public</span> Node parent;</span><br><span class="line"><span class="keyword">public</span> Node left;</span><br><span class="line"><span class="keyword">public</span> Node right;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>AVL 树需要定义树高，红黑树需要定义节点颜色</li>
</ul>
<p><strong>插入元素：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(e, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引出待插入元素位置，也就是插入到哪个父元素下</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">search</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (search != <span class="literal">null</span> &amp;&amp; search.value != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = search;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; search.value) &#123;</span><br><span class="line">            search = search.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            search = search.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(e, parent, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (parent.value &gt; newNode.value) &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先判断插入元素时候是否有树根，没有则会把当前节点创建出一颗树根来。</li>
<li>如果当前树是有树根的，则对插入元素与当前树进行一个节点遍历操作，找到元素可以插入的索引位置 parent（挂到这个父节点下）。也就是 search 搜索过程。</li>
<li>最后就是插入元素，通过给插入值创建一个 Node 节点，并绑定它的父元素，以及把新元素挂到索引到的 parent 节点下。</li>
</ul>
<p><strong>查找索引节点：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.value != <span class="literal">null</span> &amp;&amp; node.value != e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; node.value) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">delNode</span> <span class="operator">=</span> search(e);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == delNode) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> delete(delNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node delNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (delNode.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = transplant(delNode, delNode.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 因为删除的节点，有2个孩子节点，这个时候找到这条分支下，最左侧做小的节点。用它来替换删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">miniNode</span> <span class="operator">=</span> getMiniNode(delNode.right);</span><br><span class="line">        <span class="keyword">if</span> (miniNode.parent != delNode) &#123;</span><br><span class="line">            <span class="comment">// 交换位置，用miniNode右节点，替换miniNode</span></span><br><span class="line">            transplant(miniNode, miniNode.right);</span><br><span class="line">            <span class="comment">// 把miniNode 提升父节点，设置右子树并进行挂链。替代待删节点</span></span><br><span class="line">            miniNode.right = delNode.right;</span><br><span class="line">            miniNode.right.parent = miniNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换位置，删除节点和miniNode 可打印测试观察；System.out.println(this);</span></span><br><span class="line">        transplant(delNode, miniNode);</span><br><span class="line">        <span class="comment">// 把miniNode 提升到父节点，设置左子树并挂链</span></span><br><span class="line">        miniNode.left = delNode.left;</span><br><span class="line">        miniNode.left.parent = miniNode;</span><br><span class="line">        result = miniNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">getMinimum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">transplant</span><span class="params">(Node delNode, Node addNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除元素是左/右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delNode.parent.left == delNode) &#123;</span><br><span class="line">        delNode.parent.left = addNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delNode.parent.right = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置父节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != addNode) &#123;</span><br><span class="line">        addNode.parent = delNode.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分步骤解析删除节点操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">getMinimum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>寻找以 <code>node</code> 为根节点的子树中的最小节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">transplant</span><span class="params">(Node delNode, Node addNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断删除元素是左/右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delNode.parent.left == delNode) &#123;</span><br><span class="line">        delNode.parent.left = addNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delNode.parent.right = addNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置父节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != addNode) &#123;</span><br><span class="line">        addNode.parent = delNode.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将要删除的节点 <code>delNode</code> 替换为 <code>addNode</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node delNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (delNode.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果删除节点的左节点为空，则将右节点赋给删除节点</span></span><br><span class="line">        result = transplant(delNode, delNode.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果删除节点的右节点为空，则将左节点赋给删除节点</span></span><br><span class="line">        result = transplant(delNode, delNode.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 因为删除的节点，有2个孩子节点，这个时候找到这条分支下，最左侧做小的节点。用它来替换删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">miniNode</span> <span class="operator">=</span> getMiniNode(delNode.right);</span><br><span class="line">        <span class="keyword">if</span> (miniNode.parent != delNode) &#123;</span><br><span class="line">            <span class="comment">// 交换位置，用miniNode右节点，替换miniNode</span></span><br><span class="line">            transplant(miniNode, miniNode.right);</span><br><span class="line">            <span class="comment">// 把miniNode 提升父节点，设置右子树并进行挂链。替代待删节点</span></span><br><span class="line">            miniNode.right = delNode.right;</span><br><span class="line">            miniNode.right.parent = miniNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换位置，删除节点和miniNode 可打印测试观察；System.out.println(this);</span></span><br><span class="line">        transplant(delNode, miniNode);</span><br><span class="line">        <span class="comment">// 把miniNode 提升到父节点，设置左子树并挂链</span></span><br><span class="line">        miniNode.left = delNode.left;</span><br><span class="line">        miniNode.left.parent = miniNode;</span><br><span class="line">        result = miniNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>举例：</strong></p>
<img src="/2023/08/16/Data-Structure/tree-bst-03.png" alt="img" style="zoom:50%;">

<ul>
<li>待删除节点64，含有双子节点，则需要根据第一个右子节点查找最小左子节点。从89到72，如果有比72还小的左子节点，继续排查。</li>
<li>排查到节点72，将72这个准备替换待删元素的节点，与右子节点73进行位置交换，过程与 4.1 相同。使用交换函数 transplant</li>
<li>最后是进行节点72与待删节点64的交换过程，更换三角关系，父节点、左子节点、右子节点。</li>
</ul>
<h3 id="3-常见面试题-4"><a href="#3-常见面试题-4" class="headerlink" title="3.常见面试题"></a>3.常见面试题</h3><ul>
<li><p>二叉搜索树结构简述&amp;变T的可能也让手写</p>
<ul>
<li>若任意节点的左子树不为空，则左子树的所有元素的值均小于这个节点</li>
<li>若任意节点的右子树不为空，则右子树的所有元素的值均大于这个节点</li>
<li>任意节点的左子树和右子树都是二叉搜索树</li>
</ul>
</li>
<li><p>二叉搜索树的插入、删除、索引的时间复杂度</p>
<p>在二叉搜索树平衡的情况下，插入、删除、索引的时间复杂度均为 O(logn)。如果二叉搜索树平衡性较差，那么二叉搜索树退化成链表，则插入、删除、索引的时间复杂度均为 O(n)</p>
</li>
<li><p>二叉搜索树删除含有双子节点的元素过程叙述</p>
</li>
<li><p>二叉搜索树的节点都包括了哪些信息</p>
<p>值、左节点、右节点</p>
</li>
<li><p>为什么Java HashMap 中说过红黑树而不使用二叉搜索树</p>
<p>Java中的HashMap在哈希冲突处理的过程中，从JDK 8 开始引入了红黑树（Red-Black Tree）作为一种优化，来替代之前的链表。这是因为在某些情况下，链表的性能可能不够理想，而红黑树可以提供更好的性能。 </p>
<p>红黑树是一种自平衡二叉搜索树，具有以下特性： </p>
<ul>
<li>平衡性：红黑树保持了树的高度较低，使得树的查找、插入和删除操作的时间复杂度保持在O(log n)。 </li>
<li>插入和删除的高效性：红黑树的插入和删除操作的平均和最坏情况下都能保持在O(log n)的时间复杂度，这比一般的二叉搜索树要好。 </li>
<li>操作的稳定性：红黑树的操作（插入、删除）不会导致树的结构失衡，这与一些其他自平衡树可能会需要频繁的重新平衡操作不同。 </li>
<li>因此，红黑树在处理哈希冲突时，能够保持较好的性能，而链表可能在特定情况下会退化为很长，导致性能下降。Java中的HashMap使用了数组+链表（或红黑树）的方式来存储键值对，当哈希冲突较多时，将链表转换为红黑树，以保持性能的稳定和可预测性。 总之，红黑树在平衡性、插入和删除的高效性等方面相对于简单的二叉搜索树有明显的优势，所以在HashMap中采用了红黑树来处理哈希冲突。</li>
</ul>
</li>
</ul>
<h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><h3 id="1-AVL-树的简介"><a href="#1-AVL-树的简介" class="headerlink" title="1.AVL 树的简介"></a>1.AVL 树的简介</h3><p>AVL 自平衡二叉树的出现，其目的在于<strong>解决二叉搜索树退化成链表</strong>的问题。当我们向BST二叉搜索树顺序存入<code>1、2、3、4、5、6、7</code>个元素时，它会退化成一条链表，因而失去树查询的时间复杂度，所以我们需要AVL树平衡树高。如图所示</p>
<img src="/2023/08/16/Data-Structure/tree-avl-01.png" alt="img" style="zoom:50%;">

<p><strong>AVL 树如何实现平衡操作？</strong></p>
<p>当二叉树的左右分支树高差不为 1 时，需要进行左旋或者右旋，来调衡树高。</p>
<p><strong>AVL 实现平衡操作的四种情况：</strong></p>
<p><img src="/2023/08/16/Data-Structure/image-20230812160405153.png" alt="image-20230812160405153"></p>
<ul>
<li>节点树高：以节点4为说明，最长的左右分支节点个数，就是节点4的最大树高。这里节点4左右孩子节点最长路径都为2，所以它的树高为2。同理可计算其他节点树高。</li>
<li>平衡因子：通过当前节点的左右子节点作差计算平衡因子，之后AVL树通过平衡因子，定义了什么时候进行左旋和右旋。</li>
</ul>
<h3 id="2-AVL-树的实现"><a href="#2-AVL-树的实现" class="headerlink" title="2.AVL 树的实现"></a>2.AVL 树的实现</h3><p>要实现 AVL 树，首先要实现的核心逻辑是 AVL 树的自平衡，也就是使用左旋和右旋的方法来实现。</p>
<p><strong>左旋：</strong></p>
<p>适用于：平衡的节点位于父节点的右树枝，并且平衡节点的左子树为空。</p>
<img src="/2023/08/16/Data-Structure/tree-avl-06.png" alt="img" style="zoom: 50%;">

<ul>
<li>注意：当建立关系的时候，是双向的。既需要设置父节点的左右节点，也需要设置子节点的父节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.right;</span><br><span class="line">    temp.parent = node.parent;</span><br><span class="line">  </span><br><span class="line">    node.right = temp.left;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.right.parent = node;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    temp.left = node;</span><br><span class="line">    node.parent = temp;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (temp.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.parent.left == node) &#123;</span><br><span class="line">            temp.parent.left = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.parent.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>过程分为四步：要平衡的节点的右节点设置为 <code>temp</code>，要平衡的节点设置为 <code>node</code></p>
<ol>
<li><strong>与父节点建立关系</strong>：将 <code>temp</code> 的父节点设置为 <code>node</code> 的父节点</li>
<li><strong>交付子节点：</strong>将 <code>temp.left</code> 托付给 <code>node.right</code></li>
<li><strong>角色交换：</strong>将 <code>node</code> 节点的父节点设置为 <code>temp</code></li>
<li><strong>承认关系：</strong>父节点的子节点指向 <code>temp</code></li>
</ol>
<p><strong>右旋：</strong></p>
<p>适用于：平衡的节点位于父节点的左树枝，并且平衡节点的右子树为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node <span class="title function_">rotateRight</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">    temp.parent = node.parent;</span><br><span class="line">    node.left = temp.right;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.left.parent = node;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.right = node;</span><br><span class="line">    node.parent = temp;</span><br><span class="line">    <span class="keyword">if</span> (temp.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.parent.left == node) &#123;</span><br><span class="line">            temp.parent.left = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.parent.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>右旋操作与左旋类似</li>
</ul>
<p><strong>左旋+右旋：</strong></p>
<p>适用于：平衡节点位于父节点的左子树，并且平衡节点的右子树高度大于左子树（这里叙述的是其中一种情况而已）</p>
<img src="/2023/08/16/Data-Structure/tree-avl-08.png" alt="img" style="zoom: 50%;">

<ul>
<li>即 左旋+右旋 才能保证 AVL 树达到平衡状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (factor(node.left) &gt;= <span class="number">0</span>) &#123; <span class="comment">// 平衡节点左子树的高度大于右子树</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateRight(node);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateLeft(node.left);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">    node.left = temp;</span><br><span class="line">    </span><br><span class="line">    temp = <span class="built_in">super</span>.rotateRight(node);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">factor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> (node.left == <span class="literal">null</span>) ? -<span class="number">1</span> : (node.left).height;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> (node.right == <span class="literal">null</span>) ? -<span class="number">1</span> : (node.right).height;</span><br><span class="line">    <span class="keyword">return</span> leftHeight - rightHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>右旋+左旋：</strong></p>
<p>适用于：平衡节点位于父节点的右子树，并且平衡节点的左子树高度大于右子树（这里叙述的是其中一种情况而已）</p>
<p><img src="/2023/08/16/Data-Structure/tree-avl-09.png" alt="img"></p>
<ul>
<li>即右旋+左旋才能使得 AVL 树达到平衡</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (factor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateLeft(node);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">super</span>.rotateRight(node.right);</span><br><span class="line">    refreshHeight(temp.right);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">    node.right = temp;</span><br><span class="line">    </span><br><span class="line">    temp = <span class="built_in">super</span>.rotateLeft(node);</span><br><span class="line">    refreshHeight(temp.left);</span><br><span class="line">    refreshHeight(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-AVL-树常见面试题"><a href="#3-AVL-树常见面试题" class="headerlink" title="3.AVL 树常见面试题"></a>3.AVL 树常见面试题</h3><ol>
<li><p>AVL 树平衡因子怎么计算？</p>
<p>右子树的高度-左子树的高度 在AVL树中，每个节点的平衡因子只能是-1、0、1</p>
<p>如果平衡因子为 -1，表示左子树高度大于右子树；如果平衡因子为 1，表示右子树高度大于左子树</p>
</li>
<li><p>AVL 树左旋操作的目的是什么？</p>
<p>降低右子树的高度，从而达到平衡</p>
</li>
<li><p>AVL 树左旋操作的流程是什么？</p>
<p>过程分为四步：要平衡的节点的右节点设置为 <code>temp</code>，要平衡的节点设置为 <code>node</code></p>
<ol>
<li><strong>与父节点建立关系</strong>：将 <code>temp</code> 的父节点设置为 <code>node</code> 的父节点</li>
<li><strong>交付子节点：</strong>将 <code>temp.left</code> 托付给 <code>node.right</code></li>
<li><strong>角色交换：</strong>将 <code>node</code> 节点的父节点设置为 <code>temp</code></li>
<li><strong>承认关系：</strong>父节点的子节点指向 <code>temp</code></li>
</ol>
</li>
<li><p>AVL 树什么情况下要左旋+右旋？</p>
<p>单次左旋和右旋无法满足平衡条件。适用的情况有平衡节点位于父节点的右子树，并且平衡节点的左子树高度大于右子树；平衡节点位于父节点的左子树，并且平衡节点的右子树高度大于左子树</p>
</li>
<li><p>AVL 树的插入和读取的时间复杂度？</p>
<p>均为 O(logn)</p>
</li>
</ol>
<h2 id="2-3-树"><a href="#2-3-树" class="headerlink" title="2-3 树"></a>2-3 树</h2><h3 id="1-2-3树的简介"><a href="#1-2-3树的简介" class="headerlink" title="1.2-3树的简介"></a>1.2-3树的简介</h3><p>2-3树是一种树形数据结构，他通过一个节点存放 1-2 个元素来实现树的平衡。因此 2-3 树分为 2 叉和 3 叉。</p>
<img src="/2023/08/16/Data-Structure/tree-23-01.png" alt="img" style="zoom:50%;">

<p>在 BST 二叉搜索树可能退化成链表的基础上。引出了自平衡二叉树，包括 <strong>AVL 树</strong>和 Java API HashMap 中用到的<strong>红黑树</strong>，它们都属于 BalancedTree，统称为B树。</p>
<p>2-3 树中每个具有子节点（内部节点）的节点要么有两个子节点（2 节点）和一个数据元素（对应于2叉），要么有三个子节点（3 节点）和两个数据元素（3叉）。</p>
<p><strong>举例来看2-3树的插入过程</strong></p>
<img src="/2023/08/16/Data-Structure/tree-23-02.png" alt="img" style="zoom:50%;">

<ul>
<li>2-3 树的插入过程与 BST 树类似，会通过树的左右节点大小，找到自己的插入位置。</li>
<li>一个节点可以右 1-3 个元素，但当元素个数为 3 时，则需要调衡。把三个节点的中间节点晋升上来，其余两个节点为子节点。</li>
<li>如果进行一次调衡后，上一层父节点达到 3 个元素，则需要 2 次调衡，来满足2-3树的规则。</li>
</ul>
<h3 id="2-2-3树的实现"><a href="#2-2-3树的实现" class="headerlink" title="2.2-3树的实现"></a>2.2-3树的实现</h3><p><strong>节点定义：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2-3树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node_2_3</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义当前节点包含的元素</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span>[] items;</span><br><span class="line">        <span class="comment">// 序号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> number;</span><br><span class="line">        <span class="comment">// 定义当前节点的子节点</span></span><br><span class="line">        <span class="keyword">public</span> Node_2_3[] children;</span><br><span class="line">        <span class="comment">// 定义当前节点的父节点</span></span><br><span class="line">        <span class="keyword">public</span> Node_2_3 parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        第一种初始化方法</span></span><br><span class="line"><span class="comment">        元素个数初始化为3</span></span><br><span class="line"><span class="comment">        序号值初始化为0</span></span><br><span class="line"><span class="comment">        父节点初始化为null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node_2_3</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">            <span class="built_in">this</span>.number = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        第二种初始化方法：</span></span><br><span class="line"><span class="comment">       	元素第一个值初始化为item</span></span><br><span class="line"><span class="comment">       	序号值初始化为 1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node_2_3</span><span class="params">(<span class="type">int</span> item)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>();</span><br><span class="line">            <span class="built_in">this</span>.items[<span class="number">0</span>] = item;</span><br><span class="line">            <span class="built_in">this</span>.number = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        第三种初始化方法：</span></span><br><span class="line"><span class="comment">        当前元素的第一个子节点初始化为输入的 child 值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node_2_3</span><span class="params">(Node_2_3 child)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>();</span><br><span class="line">            <span class="built_in">this</span>.children[<span class="number">0</span>] = child;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// number初始化为0，表示当前节点中有几个数字，当插入一个数字的时候，需要对比查找当前数字应当插在哪个数字右边</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="built_in">this</span>.number - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.items[idx] &lt; e) <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">this</span>.items[idx + <span class="number">1</span>] = <span class="built_in">this</span>.items[idx];</span><br><span class="line">                --idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.items[idx + <span class="number">1</span>] = e;</span><br><span class="line">            ++<span class="built_in">this</span>.number;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断当前节点是否没有子节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.children[<span class="number">0</span>] == <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前节点的最小值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinItem</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前节点中间的值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMiddleItem</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前节点的最大值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxItem</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得子节点的最左边的值</span></span><br><span class="line">        <span class="keyword">public</span> Node_2_3 <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.children[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得子节点中间的值</span></span><br><span class="line">        <span class="keyword">public</span> Node_2_3 <span class="title function_">getMiddle</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.children[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得子节点的最右边的值</span></span><br><span class="line">        <span class="keyword">public</span> Node_2_3 <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.children[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>拆分节点操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拆分节点，中间节点上提，形成一个三角关系</span></span><br><span class="line"><span class="comment"> * [1,2,3]</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * /---- 3</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> * \---- 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node_2_3[] triangle(Node_2_3 node) &#123;</span><br><span class="line">    Node_2_3[] newNodes = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    newNodes[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node.items[<span class="number">0</span>]);</span><br><span class="line">    newNodes[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node.items[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!node.isLeaf()) &#123;</span><br><span class="line">        <span class="comment">// 左孩子</span></span><br><span class="line">        newNodes[<span class="number">0</span>].children[<span class="number">0</span>] = node.children[<span class="number">0</span>];</span><br><span class="line">        newNodes[<span class="number">0</span>].children[<span class="number">1</span>] = node.children[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 右孩子</span></span><br><span class="line">        newNodes[<span class="number">1</span>].children[<span class="number">0</span>] = node.children[<span class="number">2</span>];</span><br><span class="line">        newNodes[<span class="number">1</span>].children[<span class="number">1</span>] = node.children[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>方法实现，并排的三个节点，将中间的节点提取作为父节点并且左右节点作为子节点</li>
</ul>
<p><strong>替换旧节点：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceChild</span><span class="params">(Node_2_3 parent, Node_2_3 oldChild, Node_2_3 child01, Node_2_3 child02)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldChild == parent.children[<span class="number">0</span>]) &#123;</span><br><span class="line">            parent.children[<span class="number">3</span>] = parent.children[<span class="number">2</span>];</span><br><span class="line">            parent.children[<span class="number">2</span>] = parent.children[<span class="number">1</span>];</span><br><span class="line">            parent.children[<span class="number">1</span>] = child02;</span><br><span class="line">            parent.children[<span class="number">0</span>] = child01;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldChild == parent.children[<span class="number">1</span>]) &#123;</span><br><span class="line">            parent.children[<span class="number">3</span>] = parent.children[<span class="number">2</span>];</span><br><span class="line">            parent.children[<span class="number">2</span>] = child02;</span><br><span class="line">            parent.children[<span class="number">1</span>] = child01;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.children[<span class="number">3</span>] = child02;</span><br><span class="line">            parent.children[<span class="number">2</span>] = child01;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该操作将旧节点替换为新节点</li>
<li>如果要替换的是处于最左边的节点，那么需要将所有节点的位置都发生变化，以此类推</li>
</ul>
<p><strong>整体分割操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node_2_3 <span class="title function_">split</span><span class="params">(Node_2_3 node, Node_2_3 parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    parent.insert(node.getMiddleItem());</span><br><span class="line"></span><br><span class="line">    Node_2_3[] newNodes = <span class="built_in">this</span>.triangle(node);</span><br><span class="line">    <span class="built_in">this</span>.replaceChild(parent, node, newNodes[<span class="number">0</span>], newNodes[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先判断父节点是否为空，如果为空，那么将创造一个父节点</li>
<li>如果不为空，将中间节点插入</li>
<li>然后通过 triangle() 方法将长度为 3 的节点进行拆分</li>
<li>最后通过 replaceChild() 操作将旧节点替换</li>
</ul>
<p><strong>插入操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录元素</span></span><br><span class="line">    elementList.add(e);</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node_2_3</span>(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = insert(e, root);</span><br><span class="line">        <span class="keyword">if</span> (root.number == <span class="number">3</span>) &#123;</span><br><span class="line">            root = split(root, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归调用插入元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node_2_3 <span class="title function_">insert</span><span class="params">(<span class="type">int</span> e, Node_2_3 parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.isLeaf()) &#123;</span><br><span class="line">        parent.insert(e);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Node_2_3</span> <span class="variable">child</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent.number == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; parent.getMinItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getLeft());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = insert(e, parent.getMiddle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; parent.getMinItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getLeft());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &gt; parent.getMiddleItem()) &#123;</span><br><span class="line">            child = insert(e, parent.getRight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = insert(e, parent.getMiddle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child.number == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.split(child, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用递归插入元素，并且使得子节点的长度保持小于3</li>
<li>返回给 insert(int e) 方法，并且对 root 节点的长度进行判断，如果大于 3 则进行拆分</li>
</ul>
<h3 id="3-常见面试题-5"><a href="#3-常见面试题-5" class="headerlink" title="3.常见面试题"></a>3.常见面试题</h3><ol>
<li><p>2-3树的数据结构描述</p>
<p>2-3树是一种树形数据结构，他通过一个节点存放 1-2 个元素来实现树的平衡。因此 2-3 树分为 2 叉和 3 叉。</p>
</li>
<li><p>2-3树一个节点最多可以存放几个元素</p>
<p>2 个</p>
</li>
<li><p>2-3树插入节点时间复杂度</p>
<p>log(n)</p>
</li>
<li><p>2-3树一个节点有3个元素，如何迁移。<em>需要旋转吗</em></p>
<p>不需要旋转，迁移方法如下：</p>
<ul>
<li>首先将 3 个元素中处于中间位置的元素提取到父节点的位置，并且将左右两个元素的父节点设置为该元素</li>
<li>如果父节点的元素个数也等于 3，此时再对父节点进行节点提取操作</li>
</ul>
</li>
<li><p>2-3树，你能手写一下吗？</p>
</li>
</ol>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="1-红黑树的简介"><a href="#1-红黑树的简介" class="headerlink" title="1.红黑树的简介"></a>1.红黑树的简介</h3><p>建立在 BST 二叉搜索树的基础上，AVL、2-3树、红黑树都是自平衡二叉树。但相比于AVL树，高度平衡所带来的时间复杂度，红黑树对平衡的控制要宽松一些，红黑树只需要保证黑色节点平衡即可。也正因红黑树在插入和删除时不需要太多的平衡操作，也让它成为；Java中<strong>HashMap的元素碰撞后的转换</strong>、Linux的CFS进行调度算法、多路复用技术的Epoll等各类底层的数据结构实现。</p>
<h3 id="2-红黑树的性质"><a href="#2-红黑树的性质" class="headerlink" title="2.红黑树的性质"></a>2.红黑树的性质</h3><ol>
<li><strong>每个节点不是红色就是黑色。</strong><ul>
<li><strong>黑色决定平衡</strong>，红色不决定平衡。这对应了2-3树中一个节点内可以存放1~2个节点。</li>
</ul>
</li>
<li><strong>根是黑色的。</strong><ul>
<li>这条规则有时会被省略。由于<strong>根总是可以从红色变为黑色</strong>，但不一定相反，因此该规则对分析几乎没有影响。</li>
</ul>
</li>
<li><strong>所有叶子 (NIL) 都是黑色的。</strong>（NIL 即空节点）<ul>
<li>这里指的是<strong>红黑树都会有一个空的叶子节点</strong>，是红黑树自己的规则。</li>
</ul>
</li>
<li><strong>如果一个节点是红色的，那么它的两个子节点都是黑色的。</strong><ul>
<li>通常这条规则也叫不会有连续的红色节点。这体现在2-3树中，一个节点最多临时会有3个节点，中间是黑色节点，左右是红色节点。2-3树中出现这样的情况后，会进行节点迁移，中间节点成为父节点，左右节点成为子节点。</li>
</ul>
</li>
<li><strong>从给定节点到其任何后代 NIL 节点的每条路径都包含相同数量的黑色节点。</strong><ul>
<li>对应2-3树中，每一层都只是有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。</li>
</ul>
</li>
</ol>
<h3 id="3-红黑树的实现"><a href="#3-红黑树的实现" class="headerlink" title="3.红黑树的实现"></a>3.红黑树的实现</h3><h4 id="3-1左倾染色"><a href="#3-1左倾染色" class="headerlink" title="3.1左倾染色"></a>3.1左倾染色</h4><p>即当前新增节点的父节点是爷爷节点的左节点</p>
<img src="/2023/08/16/Data-Structure/tree-rbt-04.png" alt="img" style="zoom:50%;">

<p><strong>染色的步骤：</strong></p>
<ol>
<li>根据新增节点的父节点的父节点找到其叔叔节点</li>
<li>如果叔叔节点的颜色为红色，那么就将叔叔节点的颜色和父节点的颜色全部替换为黑色，并且将祖父节点替换为红色（如果祖父节点是根节点，则会进行判断改为黑色）</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> grandParent.right;</span><br><span class="line"><span class="comment">// 染色</span></span><br><span class="line"><span class="keyword">if</span> (uncle.color == Node.Color.RED)&#123;</span><br><span class="line">    parent.color = Node.Color.BLACK;</span><br><span class="line">    uncle.color = Node.Color.BLACK;</span><br><span class="line">    grandParent.color = Node.Color.RED;</span><br><span class="line">    current = grandParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2右倾染色"><a href="#3-2右倾染色" class="headerlink" title="3.2右倾染色"></a>3.2右倾染色</h4><p>即当前节点的父节点是爷爷节点的右节点</p>
<img src="/2023/08/16/Data-Structure/tree-rbt-05.png" alt="img" style="zoom:50%;">

<p><strong>染色的步骤：</strong></p>
<ol>
<li>根据新增节点的父节点的父节点找到其叔叔节点</li>
<li>如果叔叔节点的颜色为红色，那么就将叔叔节点的颜色和父节点的颜色全部替换为黑色，并且将祖父节点替换为红色（如果祖父节点是根节点，则会进行判断改为黑色）</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> grandParent.left;</span><br><span class="line"><span class="comment">// 染色</span></span><br><span class="line"><span class="keyword">if</span>(uncle.color == Node.Color.RED)&#123;</span><br><span class="line">    parent.color = Node.Color.BLACK;</span><br><span class="line">    uncle.color = Node.Color.BLACK;</span><br><span class="line">    grandParent.color = Node.Color.RED;</span><br><span class="line">    current= grandParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3左旋调衡"><a href="#3-3左旋调衡" class="headerlink" title="3.3左旋调衡"></a>3.3左旋调衡</h4><p><strong>一次左旋</strong></p>
<img src="/2023/08/16/Data-Structure/tree-rbt-06.png" alt="img" style="zoom:50%;">

<p>对照2-3树，只有当一个节点内有3个节点的时候，才需要调衡。那么红黑树则是判断当前节点的叔叔节点是否为红色节点，如果不是则没法通过染色调衡，也就是需要选择进行调衡。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateLeft(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>当你把红黑树对照理解成2-3树，如图中第1步骤下的左侧小图，新增的节点5倒置2-3树不平衡。</li>
<li>那么这个时候需要把2-3树中节点4提起来，而对应红黑树则需要先进行染色，待操作的节点4为黑色，两个孩子节点为红色。</li>
<li>最后是把节点3进行一次左旋操作，完成树的平衡。对应步骤3中的左侧小图是2-3树调衡后的结果。</li>
</ul>
<p><strong>右旋+左旋</strong></p>
<img src="/2023/08/16/Data-Structure/tree-rbt-07-169197462974612.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏左↙，先右旋一次调衡</span></span><br><span class="line"><span class="keyword">if</span> (current == parent.left)&#123;</span><br><span class="line">    current = parent;</span><br><span class="line">    <span class="built_in">super</span>.rotateRight(current);</span><br><span class="line">    parent = current.parent;</span><br><span class="line">&#125;</span><br><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateLeft(grandParent);</span><br></pre></td></tr></table></figure>

<h4 id="3-4右旋调衡"><a href="#3-4右旋调衡" class="headerlink" title="3.4右旋调衡"></a>3.4右旋调衡</h4><p><strong>一次右旋</strong></p>
<p>对照2-3树，只有当一个节点内有3个节点的时候，才需要调衡。那么红黑树则是判断当前节点的叔叔节点是否为红色节点，如果不是则没法通过染色调衡，也就是需要选择进行调衡。</p>
<img src="/2023/08/16/Data-Structure/tree-rbt-08.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateRight(grandParent);</span><br></pre></td></tr></table></figure>

<ul>
<li>当你把红黑树对照理解成2-3树，如图中第1步骤下的右侧小图，新增的节点1倒置2-3树不平衡。</li>
<li>那么这个时候需要把2-3树中节点2提起来，而对应红黑树则需要先进行染色，待操作的节点2为黑色，两个孩子节点为红色。</li>
<li>最后是把节点2进行一次右旋操作，完成树的平衡。对应步骤3中的右侧小图是2-3树调衡后的结果。</li>
</ul>
<p><strong>左旋+右旋</strong></p>
<p>当一次左旋没法调衡，需要左旋+右旋的情况，在AVL树中有同样的场景。本身树需要右旋操作，但整体分支树节点偏右，此时需要左旋调整树结构再右旋。</p>
<img src="/2023/08/16/Data-Structure/tree-rbt-09.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏右↘，先左旋一次调衡</span></span><br><span class="line"><span class="keyword">if</span> (current == parent.right)&#123;</span><br><span class="line">    current = parent;</span><br><span class="line">    <span class="built_in">super</span>.rotateLeft(current);</span><br><span class="line">    parent = current.parent;</span><br><span class="line">&#125;</span><br><span class="line">parent.color = Node.Color.BLACK;</span><br><span class="line">grandParent.color = Node.Color.RED;</span><br><span class="line"><span class="built_in">super</span>.rotateRight(grandParent);</span><br></pre></td></tr></table></figure>

<h3 id="4-常见面试题-1"><a href="#4-常见面试题-1" class="headerlink" title="4.常见面试题"></a>4.常见面试题</h3><ol>
<li><p>红黑树都有哪些使用场景？</p>
<p>红黑树在插入和删除时不需要太多的平衡操作，也让它成为：Java中<strong>HashMap的元素碰撞后的转换</strong>、Linux的CFS进行调度算法、多路复用技术的Epoll等各类底层的数据结构实现。</p>
</li>
<li><p>相比于BST树，红黑树有什么用途？</p>
<p>平衡性保证: 红黑树是一种自平衡二叉搜索树，它通过一系列的平衡性维护规则来确保树的高度始终保持在可控范围内。这样可以避免出现极端情况下的不平衡树，从而保持插入、删除和查找操作的高效性能。</p>
<p>平均复杂度保证: 红黑树的平均高度较低，这意味着它的插入、删除和查找操作的平均时间复杂度是 o(log n)。而在普通 BST中，最坏情况下，可能会出现链式结构，导致操作的平均复杂度变为 o(n)。<br>有序性保证: 与普通 BST 类似，红黑树也可以保持元素的有序性，这对于需要进行范围查找或范围操作的场景非常有用。需要注意的是，红黑树的自平衡操作会导致相对较高的常数开销，因此在某些情况下，对于小规模数据集或静态数据集，普通的 BST 也可能更加合适然而，在大多数情况下，红黑树提供了在平衡性、插入和删除操作上更好的性能保证。</p>
</li>
<li><p>B-树是什么意思，都包括哪些？</p>
<p>B-树 (B-tree) 是一种用于实现高效的动态数据集合的自平衡树数据结构。它被广泛应用于数据库系统、文件系统以及其他需要支持高效插入、删除和查找操作的场景。B-树具有以下特点:<br>有序性: 每个节点内的元素是有序的，这使得在节点内进行二分查找操作成为可能。<br>平衡性: B-树通过一系列的自平衡操作来保持树的平衡性。每次插入或删除操作后，B-树会根据一定的规则进行调整，确保树的高度始终在可接受范围内，从而保持高效的插入、删除和查找操作。</p>
<p>适应磁盘存储: B-树的设计考虑了磁盘存储的特点，适用于需要大量磁盘读写操作的场景。它通过每个节点存诸多个元素，减少了磁盘访问次数，提高了性能。<br>分裂和合并操作: 当节点的元素数量达到一定闻值时，B-树会进行分裂操作，将节点分成两个。当节点的元素数量过少时，B-树会进行合并操作，将相邻的节点合并为一个。这些操作有助于保持树的平衡性。</p>
<p>适用于范围查询: B-树支持范围查询，因为每个节点内的元素是有序的，可以在节点内进行二分查找。<br>常见变种: B-树有多个变种，如B+树、B*树等，它们在原始的B-树基础上做了一些改进，以适应不同的应用场景和优化性能。总之，B-树是一种用于实现高效的动态数据集合的数据结构，特别适用于需要大量插入、删除和查找操作的场景，如数据库系统和文件系统。</p>
</li>
<li><p>新增加一个节点后，什么情况下需要染色、什么情况要左旋、什么情况要左旋+右旋？</p>
<ul>
<li>普通染色：当新增节点的父节点（即新增节点为根节点）为空，直接染色为黑或者新增节点的父节点为黑色的时候，染红色</li>
<li>左倾染色：当新增节点的父节点（parent）位于爷爷节点的左子树并且叔叔节点（uncle）为红色，则进行左倾染色</li>
<li>右倾染色：当新增节点的父节点（parent）位于爷爷节点的右子树并且叔叔节点（uncle）为红色，则进行右倾染色</li>
<li>左旋调衡：<ul>
<li>一次左旋：当新增节点导致树发生失衡，并且新增节点位于父节点的右子树，新增节点的父节点位于爷爷节点的右子树，并且为红色节点</li>
<li>右旋+左旋：当新增节点导致树发生失衡，并且新增节点位于父节点的左子树，新增节点的父节点位于爷爷节点的右子树，并且为红色节点。单次调衡无法满足平衡条件</li>
</ul>
</li>
<li>右旋调衡：<ul>
<li>一次右旋：当新增节点导致树发生失衡，并且新增节点位于父节点的左子树，新增节点的父节点位于爷爷节点的左子树，并且为红色节点</li>
<li>左旋+右旋：当新增节点导致树发生失衡，并且新增节点位于父节点的右子树，新增节点的父节点位于爷爷节点的左子树，并且为红色节点。单次调衡无法满足平衡条件</li>
</ul>
</li>
</ul>
</li>
<li><p>红黑树的特点是什么？</p>
<ol>
<li>每个节点一定是红色或者黑色</li>
<li>红色节点的子节点一定是黑色</li>
<li>根节点一定是黑色</li>
<li>从任意节点到其叶子结点路径上的黑色节点数目相同</li>
<li>所有叶子结点是黑色的（NIL）</li>
</ol>
</li>
</ol>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="1-并查集的简介"><a href="#1-并查集的简介" class="headerlink" title="1.并查集的简介"></a>1.并查集的简介</h3><p>并查集数据结构（也称为联合-查找数据结构或合并-查找集）基于数组实现的一种跟踪元素的数据结构，这些元素被划分为多个不相交（非重叠）的子集。</p>
<p><strong>并查集的优点以及应用场景：</strong></p>
<p>并查集提供了近乎恒定的时间操作（以逆阿克曼函数为界）来添加新集合、合并现有集合以及确定元素是否在同一个集合中。</p>
<p>适用于：推荐算法、好友关系链、族谱等，并且并查集在 Kruskal 算法中扮演着关键角色，用于寻找无向边加权图的最小生成树。</p>
<h3 id="2-并查集合并的几种方式："><a href="#2-并查集合并的几种方式：" class="headerlink" title="2.并查集合并的几种方式："></a>2.并查集合并的几种方式：</h3><p><img src="/2023/08/16/Data-Structure/image-20230815165530506.png" alt="image-20230815165530506"></p>
<ul>
<li>并查集的实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line">	<span class="comment">// 元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="comment">// 数量【可选】</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] count;</span><br><span class="line">	<span class="comment">// 排序【可选】</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1默认合并（合并-1-8-）"><a href="#2-1默认合并（合并-1-8-）" class="headerlink" title="2.1默认合并（合并(1,8)）"></a>2.1默认合并（合并(1,8)）</h4><img src="/2023/08/16/Data-Structure/disjoint-set-06.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parentVal</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="type">int</span> <span class="variable">childVal</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentVal == childVal) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i ++)&#123;</span><br><span class="line">        <span class="comment">// 所有值等于原孩子节点对应值的都替换为新的父节点值</span></span><br><span class="line">        <span class="keyword">if</span> (items[i] == childVal)&#123;</span><br><span class="line">            items[i] = parentVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(1, 8) 将8的根节点合并到1的根节点</p>
<ul>
<li>union 是合并元素的方法，两个入参意思是把 child 指向的根节点，指向 parent 指向的根节点。后面所有案例中 union 方法属性字段意思相同。</li>
<li>find 找到元素对应的根节点值，之后使用 union 方法对 items 数组内的元素全部遍历，把所有值等于 child 的节点，都替换为 parent 节点值。</li>
<li>每次合并都for循环比较耗时，所以后续做了一些列的优化。</li>
</ul>
<h4 id="2-2粗暴合并（合并-1-8-）"><a href="#2-2粗暴合并（合并-1-8-）" class="headerlink" title="2.2粗暴合并（合并(1,8)）"></a>2.2粗暴合并（合并(1,8)）</h4><img src="/2023/08/16/Data-Structure/disjoint-set-07.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="comment">// 找到元素的根节点，当i == item[i]，就是自己指向自己，这个节点就是根节点</span></span><br><span class="line">    <span class="keyword">while</span> (i != items[i]) &#123;</span><br><span class="line">        i = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="comment">// 父亲节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parentRootIdx</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 孩子节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childRootIdx</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentRootIdx == childRootIdx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 孩子节点值替换为父节点值</span></span><br><span class="line">    items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(1, 8) 将8的根节点合并到1的根节点</p>
<ul>
<li>find 循环找到置顶节点的最终根节点，例如；8 → 6、6 → 6，那么说明8的根节点是6，因为6自己指向自己了，它就是根节点。</li>
<li>union 将 8 指向的根节点 6，更换为 1 指向的根节点 0。最终替换完就是 6 → 0，那么8的根节点有也是0了。</li>
<li>这样虽然减少了每次 for 循环更新，但粗暴的合并会对节点的索引带来一定的复杂度。所以还需要继续优化。</li>
</ul>
<h4 id="2-3数量合并（合并-1-8-）"><a href="#2-3数量合并（合并-1-8-）" class="headerlink" title="2.3数量合并（合并(1,8)）"></a>2.3数量合并（合并(1,8)）</h4><img src="/2023/08/16/Data-Structure/disjoint-set-08.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="comment">// 找到元素的根节点，当i == item[i]，就是自己指向自己，这个节点就是根节点</span></span><br><span class="line">    <span class="keyword">while</span> (i != items[i]) &#123;</span><br><span class="line">        i = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="comment">// 父亲节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parentRootIdx</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 孩子节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childRootIdx</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentRootIdx == childRootIdx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (count[parentRootIdx] &gt;= count[childRootIdx]) &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">        count[parentRootIdx] += count[childRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        items[parentRootIdx] = items[childRootIdx];</span><br><span class="line">        count[childRootIdx] += count[parentRootIdx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(1, 8) 将8的根节点合并到1的根节点 &amp; 基于节点的 count 值合并</p>
<ul>
<li>find 循环找到置顶节点的最终根节点，例如；8 → 6、6 → 6，那么说明8的根节点是6，因为6自己指向自己了，它就是根节点。</li>
<li>union 在进行元素的根节点合并时，会判断哪个根下的元素少，用少的元素合并到多的元素下。因为这样可以减少多的元素因为处于更低位置所带来的索引耗时。<em>树越深，子叶节点越多，越耗时。</em></li>
</ul>
<h4 id="2-4排序合并（合并-1-8-）"><a href="#2-4排序合并（合并-1-8-）" class="headerlink" title="2.4排序合并（合并(1,8)）"></a>2.4排序合并（合并(1,8)）</h4><img src="/2023/08/16/Data-Structure/disjoint-set-09.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="comment">// 找到元素的根节点，当i == item[i]，就是自己指向自己，这个节点就是根节点</span></span><br><span class="line">    <span class="keyword">while</span> (i != items[i]) &#123;</span><br><span class="line">        i = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="comment">// 父亲节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parentRootIdx</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 孩子节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childRootIdx</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentRootIdx == childRootIdx)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[parentRootIdx] &gt; rank[childRootIdx]) &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[parentRootIdx] &lt; rank[childRootIdx]) &#123;</span><br><span class="line">        items[parentRootIdx] = items[childRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">        rank[parentRootIdx]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(8, 1) 将1的根节点合并到8的根节点（其实效果和union(1,8)是一样的，之所以用union(8, 1)主要体现基于 rank 排序后的合并）&amp; 基于节点的 rank 值合并</p>
<ul>
<li>find 循环找到置顶节点的最终根节点，例如；8 → 6、6 → 6，那么说明8的根节点是6，因为6自己指向自己了，它就是根节点。</li>
<li>union 在进行元素的根节点合并时，会判断哪个根的排序小，用少的元素合并到大的根元素下。因为这样可以减少树深大的元素因为处于更低位置所带来的索引耗时。<em>树越深，子叶节点越多，越耗时。</em></li>
<li>那么此时基于 count、rank 都可以进行优化，不过优化过程中 1→0、0→2 还有2个树高，也可以优化。这就是压缩路径的作用</li>
</ul>
<h4 id="2-5压缩合并（合并-1-8-）"><a href="#2-5压缩合并（合并-1-8-）" class="headerlink" title="2.5压缩合并（合并(1,8)）"></a>2.5压缩合并（合并(1,8)）</h4><img src="/2023/08/16/Data-Structure/disjoint-set-10.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= items.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (i != items[i]) &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        items[i] = items[items[i]];</span><br><span class="line">        i = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">    <span class="comment">// 父亲节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">parentRootIdx</span> <span class="operator">=</span> find(parent);</span><br><span class="line">    <span class="comment">// 孩子节点的根节点下标值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childRootIdx</span> <span class="operator">=</span> find(child);</span><br><span class="line">    <span class="keyword">if</span> (parentRootIdx == childRootIdx)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[parentRootIdx] &gt; rank[childRootIdx]) &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[parentRootIdx] &lt; rank[childRootIdx]) &#123;</span><br><span class="line">        items[parentRootIdx] = items[childRootIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        items[childRootIdx] = items[parentRootIdx];</span><br><span class="line">        rank[parentRootIdx]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标</strong>：union(8, 1) 在rank合并下，压缩路径长度。</p>
<ul>
<li>这里的 union 方法与<code>4. 排序合并</code>相比并没有变化，变化的地方主要在 find 过程中压缩路径。</li>
<li>find 基于查找根元素时，对当前元素值对应的父节点值，替换给当前元素。减少一级路径，做到压缩路径的目的</li>
</ul>
<h3 id="3-常见面试题-6"><a href="#3-常见面试题-6" class="headerlink" title="3.常见面试题"></a>3.常见面试题</h3><ol>
<li><p>并查集叙述？</p>
<p>并查集数据结构是基于数组实现的一种跟踪元素的数据结构，这些元素被划分为多个不相交（非重叠）的子集。</p>
</li>
<li><p>并查集的使用场景？</p>
<p>推荐算法、好友关系链、族谱等，并且并查集在 Kruskal 算法中扮演着关键角色，用于寻找无向边加权图的最小生成树。</p>
</li>
<li><p>并查集怎么合并元素？</p>
<p>在并查集中，合并操作的目标是将两个元素所在的集合合并为一个集合。以下是并查集中合并元素的基本步骤： 找到代表元素： 对于每个元素，首先要找到它所在的集合的代表元素（也称为根节点）。 合并代表元素： 将一个元素的代表元素指向另一个元素的代表元素，从而将两个集合合并为一个集合。</p>
</li>
<li><p>并查集合并元素的优化策略？</p>
<p>数量合并，排序合并，压缩路径</p>
</li>
<li><p>如何压缩路径？</p>
<p>在执行查找操作时，除了找到元素的代表元素外，还可以将查找路径上的每个节点直接链接到根节点。这样，在之后的查找操作中，树的高度会减少，从而提高了查找操作的效率。</p>
</li>
</ol>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="1-图的简介"><a href="#1-图的简介" class="headerlink" title="1.图的简介"></a>1.图的简介</h3><p>图（Graph）结构是一种比树结构复杂的非线性的数据结构，图在实际生活中的例子非常多，比如；地铁线路网、微信好友关系链、计算机中的状态执行等，都可以抽象成图的结构。</p>
<p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E) &#x3D; 【G表示图、V表示顶点个数、E表示边的个数】。图的数据结构是多对多关系，就像你的微信好友可能也是我的微信好友，且相互交叉对应。与之对应的是树，树是1对多关系，所以树也是一种特殊的没有闭环的图。</p>
<h3 id="2-图的分类"><a href="#2-图的分类" class="headerlink" title="2.图的分类"></a>2.图的分类</h3><p>按照<strong>是否有方向</strong>和<strong>是否有权重</strong>，可以将图分成四种情况。</p>
<table>
<thead>
<tr>
<th align="center">U&#x2F;U</th>
<th align="center">U&#x2F;W</th>
<th align="center">D&#x2F;U</th>
<th align="center">D&#x2F;W</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/2023/08/16/Data-Structure/graph-01.png" alt="img"></td>
<td align="center"><img src="/2023/08/16/Data-Structure/graph-02.png" alt="img"></td>
<td align="center"><img src="/2023/08/16/Data-Structure/graph-03.png" alt="img"></td>
<td align="center"><img src="/2023/08/16/Data-Structure/graph-04.png" alt="img"></td>
</tr>
<tr>
<td align="center">无向图&amp;无权重</td>
<td align="center">无向图&amp;有权重</td>
<td align="center">有向图&amp;无权重</td>
<td align="center">有向图&amp;有权重</td>
</tr>
</tbody></table>
<ul>
<li>顶点：图中的任意节点都算作顶点，图中任意两个顶点间都可能存在连接，如果没有顶点间没有连线则称为空图。</li>
<li>无向图：图中任意两个顶点间都没有指向，则称这样的图为无向图。</li>
<li>有向图：图中任意两个顶点间都有指向边，则称这样的图为有向图。</li>
<li>无权重：图中任意两个顶点间的连线，没有权重值，则无权重。</li>
<li>有权重：图中任意两个顶点间的连线，包含权重值，则有权重。</li>
</ul>
<h3 id="3-图的实现"><a href="#3-图的实现" class="headerlink" title="3.图的实现"></a>3.图的实现</h3><p><strong>图的类实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的矩阵【数组】</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"><span class="comment">// 图的矩阵【链表】</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"><span class="comment">// 图的矩阵【红黑树】</span></span><br><span class="line"><span class="keyword">private</span> TreeSet&lt;Integer&gt;[] table;</span><br></pre></td></tr></table></figure>

<ul>
<li>图的数据存放可以通过 int 数组、LinkedList 链表、红黑树来实现</li>
</ul>
<h4 id="3-1数组实现"><a href="#3-1数组实现" class="headerlink" title="3.1数组实现"></a>3.1数组实现</h4><p><strong>无向图&amp;无权重：</strong></p>
<img src="/2023/08/16/Data-Structure/graph-05.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    table[x][y] = <span class="number">1</span>;</span><br><span class="line">    table[y][x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接矩阵通过数组存放元素，会有一些浪费空间，所有的空间都会填满。</li>
<li>在插入元素的时候，对称插入节点。例如：0→1、1→0，两个方向都插入元素。</li>
</ul>
<p><strong>有向图&amp;有权重</strong></p>
<img src="/2023/08/16/Data-Structure/graph-06.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span>[][] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    table[x][y] = weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接矩阵通过数组存放元素，会有一些浪费空间，所有的空间都会填满。</li>
<li>在插入元素的时候，插入单向节点，节点值为权重值。例如：0→2，权重值是4。</li>
</ul>
<h4 id="3-2链表实现"><a href="#3-2链表实现" class="headerlink" title="3.2链表实现"></a>3.2链表实现</h4><p><strong>无向图&amp;无权重</strong></p>
<img src="/2023/08/16/Data-Structure/graph-07.png" alt="img" style="zoom: 33%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，无方向，无权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    table[x].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;y&#125;);</span><br><span class="line">    table[y].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;x&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组+链表的实现方式可以减少非必要的元素存储，更加节省空间。</li>
<li>其实插入元素的过程和数组类似，无向无权重直接对称插入元素即可。</li>
</ul>
<p><strong>有向图&amp;有权重</strong></p>
<img src="/2023/08/16/Data-Structure/graph-08.png" alt="img" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的顶点数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> v;</span><br><span class="line"><span class="comment">// 图的边个数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> e;</span><br><span class="line"><span class="comment">// 图的矩阵</span></span><br><span class="line"><span class="keyword">protected</span> LinkedList&lt;Integer[]&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对称插入，有方向，有权重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    table[x].add(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;y, weight&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组+链表的实现方式可以减少非必要的元素存储，更加节省空间。</li>
<li>其实插入元素的过程和数组类似，有方向有权重则只插入单个指向，并需要通过数组或者对象的方式记录权重值。</li>
</ul>
<h4 id="3-3红黑树实现"><a href="#3-3红黑树实现" class="headerlink" title="3.3红黑树实现"></a>3.3红黑树实现</h4><p>图的最终实现是通过 TreeSet <strong>红黑树</strong>的方式，这样即<strong>节省空间</strong>，又能提高元素的<strong>索引和遍历效率</strong>。</p>
<p><strong>无向图 vs 有向图</strong></p>
<table>
<thead>
<tr>
<th align="center">无向图</th>
<th align="center">有向图</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/2023/08/16/Data-Structure/graph-09.png" alt="img"></td>
<td align="center"><img src="/2023/08/16/Data-Structure/graph-10.png" alt="img"></td>
</tr>
<tr>
<td align="center">对称插入：table[x].add(y); table[y].add(x);</td>
<td align="center">单向插入：table[x].add(y);</td>
</tr>
</tbody></table>
<p><strong>广度遍历 vs 深度遍历</strong></p>
<table>
<thead>
<tr>
<th align="center">U&#x2F;U</th>
<th align="center">U&#x2F;U</th>
<th align="center">D&#x2F;U</th>
<th align="center">D&#x2F;U</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/2023/08/16/Data-Structure/graph-11.png" alt="img"></td>
<td align="center"><img src="/2023/08/16/Data-Structure/graph-12.png" alt="img"></td>
<td align="center"><img src="/2023/08/16/Data-Structure/graph-13.png" alt="img"></td>
<td align="center"><img src="/2023/08/16/Data-Structure/graph-14.png" alt="img"></td>
</tr>
<tr>
<td align="center">深度遍历</td>
<td align="center">广度遍历</td>
<td align="center">深度遍历</td>
<td align="center">广度遍历</td>
</tr>
</tbody></table>
<ol>
<li>深度遍历，不断地向下探测。广度遍历横行探测。</li>
<li>当有权重时候，则深度和广度会按照权重进行选择优先遍历的顺序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    queue.add(s);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">        order.add(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                queue.add(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 深度优先，前序遍历</span></span><br><span class="line">    pre.add(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w : graph.adj(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 深度优先，后序遍历</span></span><br><span class="line">    post.add(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>广度优先算法</strong>：</p>
<ol>
<li><p>首先，一个队列 <code>queue</code> 被创建用于存储待访问的节点。</p>
</li>
<li><p>然后，起始节点 <code>s</code> 被标记为已访问，并加入到队列中。</p>
</li>
<li><p>进入 <code>while</code> 循环，只要队列不为空，就一直执行以下步骤： </p>
<p>a. 移除队列头部的节点，将其作为当前要处理的节点。 </p>
<p>b. 将当前节点添加到遍历顺序列表 <code>order</code> 中，以记录遍历的顺序。 </p>
<p>c. 遍历当前节点的所有相邻节点（使用 <code>G.adj(v)</code> 获取当前节点的相邻节点列表）。</p>
<ul>
<li>如果相邻节点尚未被访问过，将其加入队列并标记为已访问。</li>
</ul>
</li>
<li><p>循环结束后，遍历顺序列表 <code>order</code> 中包含了按照广度优先遍历得到的节点访问顺序。</p>
</li>
</ol>
<p><strong>深度优先算法</strong>：</p>
<ol>
<li>递归的深度优先遍历函数 <code>dfs</code> 接受一个节点编号 <code>v</code> 作为参数。</li>
<li>首先，将当前节点 <code>v</code> 标记为已访问，表示正在访问这个节点。</li>
<li>在前序遍历位置，将当前节点编号 <code>v</code> 添加到前序遍历顺序列表 <code>pre</code> 中，以记录前序遍历顺序。</li>
<li>进入一个 <code>for</code> 循环，遍历当前节点的所有相邻节点（使用 <code>graph.adj(v)</code> 获取当前节点的相邻节点列表）。<ul>
<li>如果相邻节点尚未被访问过（即 <code>visited[w]</code> 为 <code>false</code>），则递归调用 <code>dfs(w)</code> 对相邻节点进行深度优先遍历。</li>
</ul>
</li>
<li>在后序遍历位置，将当前节点编号 <code>v</code> 添加到后序遍历顺序列表 <code>post</code> 中，以记录后序遍历顺序。</li>
</ol>
<h3 id="4-常见面试题-2"><a href="#4-常见面试题-2" class="headerlink" title="4.常见面试题"></a>4.常见面试题</h3><ol>
<li><p>图的使用场景是什么？</p>
<p>地铁线路网、微信好友关系链、计算机中的状态执行等，都可以抽象成图的结构。</p>
</li>
<li><p>图有的分类？</p>
<p>根据有无权重和有无方向可以分为四种，分别是：无权重无向图、无权重有向图、有权重无向图、有权重有向图。</p>
</li>
<li><p>图怎么存放权重值？</p>
<p>邻接矩阵、邻接表、关联矩阵</p>
</li>
<li><p>图的广度遍历</p>
<ol>
<li>从起始节点开始，将其入队列</li>
<li>对于当前队列中的节点，依次出队列并进行处理</li>
<li>遍历当前节点的所有未被访问的邻居节点，并且将其入队</li>
<li>重复步骤2和3知道队列为空</li>
</ol>
</li>
<li><p>图的深度遍历</p>
<ol>
<li>从起始节点开始，首先将其设置为已访问</li>
<li>之后遍历其相邻节点，如果节点未被访问过，则递归调用深度遍历</li>
</ol>
</li>
</ol>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="1-布隆过滤器的简介"><a href="#1-布隆过滤器的简介" class="headerlink" title="1.布隆过滤器的简介"></a>1.布隆过滤器的简介</h3><p>布隆过滤器是一种节省空间的概率数据结构，包括一个很长的二进制向量和一些列随机映射函数。</p>
<p>布隆过滤器是一个基于数组和哈希函数散列元素的结构，很像 HashMap 的哈希桶。布隆过滤器<strong>可以用于检测一个元素是否在集合中</strong>。它的优点是<strong>空间效率和查询时间比一般算法要好</strong>很多，但也有一定概率的<strong>误判性</strong>。<em>如HashMap出现哈希碰撞</em></p>
<p><strong>布隆过滤器的优点：</strong></p>
<ul>
<li>时间复杂度低，增加和查询元素的时间复杂为O(N)，（N为哈希函数的个数，通常情况比较小）</li>
<li>保密性强，布隆过滤器不存储元素本身</li>
<li>存储空间小，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如Set集合）</li>
</ul>
<p><strong>布隆过滤器的缺点：</strong></p>
<ul>
<li>有一定的误判率，但是可以通过调整参数来降低</li>
<li>无法获取元素本身</li>
<li>很难删除元素</li>
</ul>
<h3 id="2-布隆过滤器使用场景"><a href="#2-布隆过滤器使用场景" class="headerlink" title="2.布隆过滤器使用场景"></a>2.布隆过滤器使用场景</h3><p>布隆过滤器可以告诉我们<strong>“某样东西一定不存在或者可能存在”</strong>，也就是说布隆过滤器说<strong>这个数不存在则一定不存</strong>，布隆过滤器说<strong>这个数存在可能不存在</strong>，利用这个判断是否存在的特点可以做很多事情。例如</p>
<ul>
<li><strong>解决Redis缓存穿透问题（面试重点）</strong></li>
<li>邮件过滤，使用布隆过滤器来做邮件黑名单过滤</li>
<li>对爬虫网址进行过滤，爬过的不再爬</li>
<li>解决新闻推荐过的不再推荐(类似抖音刷过的往下滑动不再刷到)</li>
<li>HBase\RocksDB\LevelDB等数据库内置布隆过滤器，用于判断数据是否存在，可以减少数据库的IO请求</li>
</ul>
<h3 id="3-布隆过滤器的原理"><a href="#3-布隆过滤器的原理" class="headerlink" title="3.布隆过滤器的原理"></a>3.布隆过滤器的原理</h3><h4 id="3-1数据结构"><a href="#3-1数据结构" class="headerlink" title="3.1数据结构"></a>3.1数据结构</h4><p>布隆过滤器它实际上是一个很长的二进制向量和一系列随机映射函数。以 Redis 中的布隆过滤器实现为例，Redis 中的布隆过滤器底层是<strong>一个大型位数组（二进制数组）+多个无偏hash函数。</strong></p>
<p><strong>一个大型的二进制数组：</strong></p>
<img src="/2023/08/16/Data-Structure/e94e504adc5a75a2d7f562dc44166511.png" alt="位数组.png" style="zoom:50%;">

<p><strong>多个无偏的 hash 函数：</strong></p>
<p>无偏 hash 函数就是能<strong>把元素的 hash 值计算的比较均匀的 hash 函数</strong>，能使得计算后的元素下标比较均匀的映射到位数组中。</p>
<p>如下就是一个简单的布隆过滤器示意图，其中k1、k2代表增加的元素，a、b、c即为无偏hash函数，最下层则为二进制数组。</p>
<img src="/2023/08/16/Data-Structure/9ebde5c11ad69447314c216acf188fc8.png" alt="布隆过滤器.png" style="zoom:50%;">

<h4 id="3-2空间计算"><a href="#3-2空间计算" class="headerlink" title="3.2空间计算"></a>3.2空间计算</h4><p>在布隆过滤器增加元素之前，<strong>首先需要初始化布隆过滤器的空间</strong>，也就是上面说的二进制数组，除此之外还需要<strong>计算无偏 hash 函数的个数</strong>。布隆过滤器提供了两个参数，分别是预计加入元素的大小n，运行的错误率f。布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小l，以及无偏hash函数的个数k。它们之间的关系比较简单：</p>
<ul>
<li>错误率越低，位数组越长，控件占用较大</li>
<li>错误率越低，无偏hash函数越多，计算耗时较长</li>
</ul>
<h4 id="3-3增加元素"><a href="#3-3增加元素" class="headerlink" title="3.3增加元素"></a>3.3增加元素</h4><p>往布隆过滤器增加元素，添加的 key 需要根据 k 个无偏 hash 函数计算得到多个 hash 值，然后对数组长度进行取模得到数组下标的位置，然后将对应数组下标的位置的值置为 1。详细步骤如下：</p>
<ol>
<li>通过k个无偏hash函数计算得到k个hash值</li>
<li>依次取模数组长度，得到数组索引</li>
<li>将计算得到的数组索引下标位置数据修改为1</li>
</ol>
<p>例如，key &#x3D; Liziba，无偏hash函数的个数 k&#x3D;3，分别为 hash1、hash2、hash3。三个hash函数计算后得到三个数组下标值，并将其值修改为 1。如图所示：<br><img src="/2023/08/16/Data-Structure/a3e7d217ecb825e94bdc577a467eb29d.png" alt="增加元素.png" style="zoom:50%;"></p>
<h4 id="3-4查询元素"><a href="#3-4查询元素" class="headerlink" title="3.4查询元素"></a>3.4查询元素</h4><p>布隆过滤器最大的用处就在于判断某样东西一定不存在或者可能存在，而这个就是查询元素的结果。其查询元素的过程如下：</p>
<ol>
<li>通过k个无偏hash函数计算得到k个hash值</li>
<li>依次取模数组长度，得到数组索引</li>
<li>判断索引处的值是否全部为1，如果全部为1则存在（这种存在可能是误判），如果存在一个0则必定不存在</li>
</ol>
<p>关于误判，其实非常好理解，hash函数再怎么好，也无法完全避免hash冲突，也就是说可能会存在多个元素计算的 hash 值是相同的，那么它们取模数组长度后的到的数组索引也是相同的，这就是误判的原因。例如李子捌和李子柒的 hash 值取模后得到的数组索引都是1，但其实这里只有李子捌，如果此时判断李子柒在不在这里，误判就出现啦！因此布隆过滤器最大的缺点误判只要知道其判断元素是否存在的原理就很容易明白了！</p>
<h4 id="3-5修改-amp-删除元素"><a href="#3-5修改-amp-删除元素" class="headerlink" title="3.5修改&amp;删除元素"></a>3.5修改&amp;删除元素</h4><p>布隆过滤器对元素的修改和删除不太支持，目前有一些变形的特定布隆过滤器支持元素的删除！关于为什么对修改和删除不太支持，其实也非常好理解，hash 冲突必然存在，修改和删除肯定是很苦难的！</p>
<h3 id="4-布隆过滤器的实现"><a href="#4-布隆过滤器的实现" class="headerlink" title="4.布隆过滤器的实现"></a>4.布隆过滤器的实现</h3><p><strong>布隆过滤器类实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashGenerator.HashGroup[] GROUPS = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>.HashGroup[]&#123;HashGenerator.HashGroup.G1, HashGenerator.HashGroup.G2, HashGenerator.HashGroup.G3, HashGenerator.HashGroup.G4&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitSet bits;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> HashGenerator[] generators;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多个无偏的 hash 函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG1</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">        hash &amp;= hash;</span><br><span class="line">        hash = Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % (seed * size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG2</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">7397</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash % seed * (size - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG3</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; value.length(); idx++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> value.charAt(idx);</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) + hash + c;</span><br><span class="line">        hash += c;</span><br><span class="line">        hash &amp;= hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash % (seed * size - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashG4</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (value == <span class="literal">null</span>) ? <span class="number">0</span> : Math.abs(seed * (size - <span class="number">1</span>) &amp; ((h = value.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里提供了四种哈希计算的方式，相当于每一个哈希计算都是一次扰动处理。一个元素的存放可以经过四次哈希，尽量让元素值做到散列。</li>
</ul>
<p><strong>构建容器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span>[] seeds)</span> &#123;</span><br><span class="line">    bits = <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">    generators = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>[seeds.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; seeds.length; i++) &#123;</span><br><span class="line">        generators[i] = <span class="keyword">new</span> <span class="title class_">HashGenerator</span>(size, seeds[i], GROUPS[i % GROUPS.length]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数根据所需创建的容器大小和哈希种子来初始化布隆过滤器。</li>
</ul>
<p><strong>添加元素：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (HashGenerator generator : generators) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> generator.doHash(value);</span><br><span class="line">        bits.set(hash, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加元素时按照元素初始化时的哈希计算种类，获取哈希并存放。</li>
</ul>
<p><strong>比对元素：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String value)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashGenerator generator : generators) &#123;</span><br><span class="line">        ret = ret &amp;&amp; bits.get(generator.doHash(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>比对元素时用的是同一类哈希计算方式，并且把这些哈希值 <code>&amp;&amp;</code> 计算。<em>用N个比特位置记录一个值更准确</em></li>
</ul>
<h3 id="5-常见面试题"><a href="#5-常见面试题" class="headerlink" title="5.常见面试题"></a>5.常见面试题</h3><ol>
<li><p>布隆过滤器的使用场景？</p>
<p>布隆过滤器用于检验一个元素是否存在集合中，布隆过滤器的特点是根据其判断不存在集合中的元素一定不存在集合中，判断其存在集合中的元素不一定存在。其具体应用场景有：</p>
<ul>
<li><strong>解决Redis缓存穿透问题（面试重点）</strong></li>
<li>邮件过滤，使用布隆过滤器来做邮件黑名单过滤</li>
<li>对爬虫网址进行过滤，爬过的不再爬</li>
<li>解决新闻推荐过的不再推荐(类似抖音刷过的往下滑动不再刷到)</li>
<li>HBase\RocksDB\LevelDB等数据库内置布隆过滤器，用于判断数据是否存在，可以减少数据库的IO请求</li>
</ul>
</li>
<li><p>布隆过滤器的实现原理和方式？</p>
<p>布隆过滤器底层是一个<strong>基于大型位数组（二进制数组）+多个无偏哈希函数</strong>实现的。其添加元素的方法是通过不同的哈希函数，将要添加的元素映射到数组的不同的位置上，并且将对应的位置设置为1。在判断元素是否存在的时候，同样通过不同的哈希函数将其映射到位数组上，并检查对应的位置是否均为1，若所有位置都为1，则表示该元素存在（存在误判）；如果有任何一个位置为0，则认为该元素不存在。</p>
</li>
<li><p>如何提高布隆过滤器的准确性？</p>
<ul>
<li>适当选择哈希函数数量: 哈希函数的数量对于布隆过滤器的准确性很重要。较多的哈希函数可以减少冲突和误判的可能性。但同时也会增加计算开销需要权衡。</li>
<li>使用高质量的哈希函数: 使用具有低冲突率和较好分布性的哈希函数可以减少误判。一些通用的哈希函数，如 MurmurHash、CityHash等，通常在布隆过滤器中表现良好。</li>
<li>动态调整位数组大小: 可以根据预期的元素数量和期望的误判率来动态调整位数组的大小。较大的位数组可以降低误判率，但也会增加空间消耗使用多人独立的布隆过滤器: 使用多人布隆过滤器，每个布隆过滤器使用不同的哈希函数和参数。将查询结果通过多个布隆过滤器的结果进行逻辑操作，可以减少误判。</li>
<li>组合其他数据结构: 可以将布隆过滤器与其他数据结构结合使用，例如使用个小的布隆过滤器进行快速筛选，然后再通过一个精确的数据结构 (如散列表)来进行最终的判断</li>
<li>定期重建: 定期重建布隆过滤器，清除旧的元素，可以有效减少误判。但这会增加计算开销。</li>
</ul>
</li>
<li><p>有哪些中哈希计算方式？</p>
<ul>
<li>除留余数法(Division Hashing)：这是一种简单的哈希函数，将输入值除以个素数，然后取余数作为哈希值。通常票要选择一个适当的素数作为除数，以避免哈希碰撞。</li>
<li>乘法哈希 (Multiplicative Hashing) : 这种方法首先将输入值乘以一个常数A，提取乘积的小数部分，然后乘以哈希表大小 M，并取整得到最终哈希值。常数 A 通常取一个个于 0 和 1之间的数。</li>
<li>加法哈希 (Additive Hashing) : 将输入值的每个字符 (或字节) 转化为数值，然后将所有数值相加，最后取和的模作为哈希值。</li>
<li>旋转哈希 (Rotating Hash) : 对输入值的二进制表示进行循环移位(旋转)，然后将每一位都参与哈希计算。</li>
<li>位运算哈希(Bitwise Hashing) : 使用位运算(如异或、与、或等)对输入值的不同部分进行组合，得到哈希值。</li>
</ul>
</li>
<li><p>都有哪些类型的布隆过滤器实现？<em>Google 开源的 Guava 中自带的布隆过滤器、Redis 中的布隆过滤器</em></p>
</li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>数据结构</p><p><a href="https://spy955.github.io/2023/08/16/Data-Structure/">https://spy955.github.io/2023/08/16/Data-Structure/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Sun Peiyuan</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-08-16</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-08-16</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Data-Structure/">Data Structure</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/07/12/%E8%AE%A1%E7%BD%91/"><span class="level-item">计算机基础——计算机网络</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://spy955.github.io/2023/08/16/Data-Structure/';
            this.page.identifier = '2023/08/16/Data-Structure/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'SPY' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/hutao.jpg" alt="SPY"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SPY</p><p class="is-size-6 is-block">一个热爱并追求技术的小白</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Spy955" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Spy955"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-16T06:11:29.000Z">2023-08-16</time></p><p class="title"><a href="/2023/08/16/Data-Structure/">数据结构</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-12T05:28:39.000Z">2023-07-12</time></p><p class="title"><a href="/2023/07/12/%E8%AE%A1%E7%BD%91/">计算机基础——计算机网络</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-07T05:58:29.000Z">2023-07-07</time></p><p class="title"><a href="/2023/07/07/Lottery-API/">Lottery-API</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-07T05:15:40.000Z">2023-07-07</time></p><p class="title"><a href="/2023/07/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-2/">代码随想录刷题笔记——栈、队列、二叉树篇</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-03T04:38:56.000Z">2023-07-03</time></p><p class="title"><a href="/2023/07/03/MySQL/">MySQL 原理的学习</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Computer-Basics/"><span class="tag">Computer Basics</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Data-Structure/"><span class="tag">Data Structure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java-Project/"><span class="tag">Java_Project</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web/"><span class="tag">Web</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.png" alt="SPY 的博客" height="28"></a><p class="is-size-7"><span>&copy; 2023 Sun Peiyuan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Spy955"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>