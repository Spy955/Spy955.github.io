<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>计算机基础——计算机网络 - SPY 的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SPY 的博客"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SPY 的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本篇内容：  计算机网络的学习，包括基础知识和HTTP、TCP、IP 等基础知识点的介绍 在使用中可能出现的问题的探讨与研究"><meta property="og:type" content="blog"><meta property="og:title" content="计算机基础——计算机网络"><meta property="og:url" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/"><meta property="og:site_name" content="SPY 的博客"><meta property="og:description" content="本篇内容：  计算机网络的学习，包括基础知识和HTTP、TCP、IP 等基础知识点的介绍 在使用中可能出现的问题的探讨与研究"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/tcpip参考模型.drawio.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/osi-7-model.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230723161537862.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/6.jpg"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/11.jpg"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230708171420428.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230708180534715.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/6-五大类HTTP状态码.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/缓存etag.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/计网/http缓存.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/22-数字证书工作流程.jpeg"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpeg"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/证书的校验.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710141612761.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/TCP三次握手.drawio.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/fe898053d2e93abac950b1637645943f.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/isn相同.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/format,png-20230309230622886.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/format,png-20230309230614791.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710171216945.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710171336442.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710174424203.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710174726817.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230711135806652.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/95592346a9a747819cd27741a660213c.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/3.jpg"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/ae18cbf6071c47b98014a68d05c37d16.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/4cad213f5125432693e0e2a512c2d1a1.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230712135256746.png"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/9.jpg"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/41.jpg"><meta property="og:image" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/17.png"><meta property="article:published_time" content="2023-07-12T05:28:39.000Z"><meta property="article:modified_time" content="2023-07-23T08:15:46.829Z"><meta property="article:author" content="Sun Peiyuan"><meta property="article:tag" content="Computer Basics"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/tcpip参考模型.drawio.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/"},"headline":"计算机基础——计算机网络","image":["https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/tcpip参考模型.drawio.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/osi-7-model.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230723161537862.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/6.jpg","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/11.jpg","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230708171420428.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230708180534715.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/6-五大类HTTP状态码.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/缓存etag.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/计网/http缓存.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/证书的校验.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710141612761.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/TCP三次握手.drawio.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/fe898053d2e93abac950b1637645943f.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/isn相同.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/format,png-20230309230622886.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/format,png-20230309230614791.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710171216945.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710171336442.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710174424203.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710174726817.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230711135806652.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/95592346a9a747819cd27741a660213c.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/3.jpg","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/ae18cbf6071c47b98014a68d05c37d16.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/4cad213f5125432693e0e2a512c2d1a1.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230712135256746.png","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/9.jpg","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/41.jpg","https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/17.png"],"datePublished":"2023-07-12T05:28:39.000Z","dateModified":"2023-07-23T08:15:46.829Z","author":{"@type":"Person","name":"Sun Peiyuan"},"publisher":{"@type":"Organization","name":"SPY 的博客","logo":{"@type":"ImageObject","url":"https://spy955.github.io/img/favicon.png"}},"description":"本篇内容：  计算机网络的学习，包括基础知识和HTTP、TCP、IP 等基础知识点的介绍 在使用中可能出现的问题的探讨与研究"}</script><link rel="canonical" href="https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.png" alt="SPY 的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Spy955"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-07-12T05:28:39.000Z" title="2023/7/12 13:28:39">2023-07-12</time>发表</span><span class="level-item"><time dateTime="2023-07-23T08:15:46.829Z" title="2023/7/23 16:15:46">2023-07-23</time>更新</span><span class="level-item">4 小时读完 (大约35057个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">计算机基础——计算机网络</h1><div class="content"><p><strong>本篇内容：</strong></p>
<ol>
<li>计算机网络的学习，包括基础知识和HTTP、TCP、IP 等基础知识点的介绍</li>
<li>在使用中可能出现的问题的探讨与研究</li>
</ol>
<span id="more"></span>

<h2 id="基础知识篇"><a href="#基础知识篇" class="headerlink" title="基础知识篇"></a>基础知识篇</h2><h3 id="1-TCP-x2F-IP-模型有几层"><a href="#1-TCP-x2F-IP-模型有几层" class="headerlink" title="1.TCP&#x2F;IP 模型有几层"></a>1.TCP&#x2F;IP 模型有几层</h3><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/tcpip参考模型.drawio.png" alt="img" style="zoom:50%;">

<p><strong>答：</strong>TCP&#x2F;IP模型分为应用层、传输层、网络层和网络接口层四层。各部分的作用是：</p>
<ul>
<li><strong>应用层</strong>专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</li>
<li>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。在该层主要有两个传输协议：TCP和UDP。网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。</li>
<li><strong>网络层</strong>主要实现的是传输功能。该层的传输协议是 IP 协议。网络层负责对子网间的数据包进行路由选择。</li>
<li><strong>网络接口层</strong>主要为网络层提供<strong>链路级别</strong>传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</li>
</ul>
<h4 id="1-1追问：OSI七层模型"><a href="#1-1追问：OSI七层模型" class="headerlink" title="1.1追问：OSI七层模型"></a>1.1追问：OSI七层模型</h4><p><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/osi-7-model.png" alt="OSI 七层模型"></p>
<h4 id="1-2追问：两种模型的对应关系？"><a href="#1-2追问：两种模型的对应关系？" class="headerlink" title="1.2追问：两种模型的对应关系？"></a>1.2追问：两种模型的对应关系？</h4><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230723161537862.png" alt="image-20230723161537862" style="zoom:50%;">

<h3 id="2-为什么既需要传输层，也需要网络层？"><a href="#2-为什么既需要传输层，也需要网络层？" class="headerlink" title="2.为什么既需要传输层，也需要网络层？"></a>2.为什么既需要传输层，也需要网络层？</h3><ol>
<li>实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而<strong>传输层的设计理念是简单、高效、专注</strong>，如果传输层还负责这一块功能就有点违背设计原则了。</li>
<li>也就是说，<strong>我们不希望传输层协议处理太多的事情，只需要服务好应用即可</strong>，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是<strong>网络层</strong>。</li>
</ol>
<h3 id="3-为什么需要网络接口层？"><a href="#3-为什么需要网络接口层？" class="headerlink" title="3.为什么需要网络接口层？"></a>3.为什么需要网络接口层？</h3><ol>
<li>以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。</li>
<li>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</li>
<li>所以说，<strong>网络接口层主要为网络层提供「链路级别」传输的服务</strong>，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</li>
</ol>
<h3 id="4-键入网址到网页显示，期间发生了什么？"><a href="#4-键入网址到网页显示，期间发生了什么？" class="headerlink" title="4.键入网址到网页显示，期间发生了什么？"></a>4.键入网址到网页显示，期间发生了什么？</h3><ol>
<li>对 <code>URL</code> 进行解析，从而生成发送给 <code>Web</code> 服务器的请求信息（即 HTTP 请求信息）。</li>
<li>在发送之前，需要使用 DNS 查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</li>
<li>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。<ol>
<li>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</li>
<li>TCP 分割传输数据，生成 TCP 报文。</li>
<li>IP 模块包装数据，生成 IP 报文。</li>
<li>添加 MAC 包，在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</li>
</ol>
</li>
<li>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。最后网卡会将包转为电信号，通过网线发送出去。</li>
<li>到达交换机之后，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</li>
<li>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</li>
<li>经过不断地路由器转换操作，到达目标路由器。完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。之后根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</li>
<li>数据包抵达服务器后，服务器会一层层将数据包进行去皮操作，最终将 HTTP 中的请求进行返回。返回操作类似发送。</li>
</ol>
<h3 id="5-DNS-如何进行查询？"><a href="#5-DNS-如何进行查询？" class="headerlink" title="5.DNS 如何进行查询？"></a>5.DNS 如何进行查询？</h3><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/6.jpg" alt="域名解析的工作流程" style="zoom: 50%;">

<p>层级查询，从根节点进行查询。</p>
<h3 id="6-什么是-MTU-和-MSS？"><a href="#6-什么是-MTU-和-MSS？" class="headerlink" title="6.什么是 MTU 和 MSS？"></a>6.什么是 MTU 和 MSS？</h3><ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li>
</ul>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/11.jpg" alt="MTU 与 MSS" style="zoom:50%;">

<p><strong>追问：既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</strong></p>
<ul>
<li>如果只采用 IP 层进行分片，<strong>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。</li>
<li>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</li>
</ul>
<h3 id="7-如何获取对方的-MAC-地址呢？"><a href="#7-如何获取对方的-MAC-地址呢？" class="headerlink" title="7.如何获取对方的 MAC 地址呢？"></a>7.如何获取对方的 MAC 地址呢？</h3><ol>
<li>首先在 <strong>ARP缓存</strong>中寻找是否有目标路由的MAC地址。</li>
<li>使用<code>ARP</code> 协议帮我们找到路由器的 MAC 地址。</li>
<li>ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备进行广播，从而得到目标路由器的 MAC 地址。</li>
<li>把本次查询结果放到一块叫做 <strong>ARP 缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。</li>
</ol>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230708171420428.png" alt="image-20230708171420428" style="zoom:50%;">

<p><strong>追问：如果不在同一子网，那么如何找 MAC 地址？</strong></p>
<p>在发送数据包时，如果目标主机不是本地局域网，填入的 MAC 地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现目标 IP 地址是自己局域网内的主机，就会 ARP 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。</p>
<h3 id="8-在交换机中，当-MAC-地址表找不到指定的-MAC-地址会怎么样？"><a href="#8-在交换机中，当-MAC-地址表找不到指定的-MAC-地址会怎么样？" class="headerlink" title="8.在交换机中，当 MAC 地址表找不到指定的 MAC 地址会怎么样？"></a>8.在交换机中，当 MAC 地址表找不到指定的 MAC 地址会怎么样？</h3><ol>
<li>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</li>
<li>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</li>
<li>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</li>
</ol>
<h3 id="9-路由器的基本原理？"><a href="#9-路由器的基本原理？" class="headerlink" title="9.路由器的基本原理？"></a>9.路由器的基本原理？</h3><ol>
<li>路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。</li>
<li>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</li>
</ol>
<h3 id="10-路由器接收包的操作？"><a href="#10-路由器接收包的操作？" class="headerlink" title="10.路由器接收包的操作？"></a>10.路由器接收包的操作？</h3><ol>
<li>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</li>
<li>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</li>
<li>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</li>
</ol>
<h3 id="11-路由器发送包的操作？"><a href="#11-路由器发送包的操作？" class="headerlink" title="11.路由器发送包的操作？"></a>11.路由器发送包的操作？</h3><ol>
<li><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p>
<p>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</p>
<p>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</p>
</li>
<li><p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p>
<ul>
<li>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</li>
</ul>
</li>
<li><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p>
</li>
<li><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p>
</li>
<li><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p>
</li>
<li><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p>
</li>
</ol>
<h3 id="12-小林读者提问"><a href="#12-小林读者提问" class="headerlink" title="12.小林读者提问"></a>12.小林读者提问</h3><h4 id="1-笔记本的是自带交换机的吗？交换机现在我还不知道是什么"><a href="#1-笔记本的是自带交换机的吗？交换机现在我还不知道是什么" class="headerlink" title="1.笔记本的是自带交换机的吗？交换机现在我还不知道是什么"></a>1.笔记本的是自带交换机的吗？交换机现在我还不知道是什么</h4><p>笔记本不是交换机，交换机通常是2个网口以上。</p>
<p>现在家里的路由器其实有了交换机的功能了。交换机可以简单理解成一个设备，三台电脑网线接到这个设备，这三台电脑就可以互相通信了，交换机嘛，交换数据这么理解就可以。</p>
<h4 id="2-是不是有了MAC地址就能给你发消息了？"><a href="#2-是不是有了MAC地址就能给你发消息了？" class="headerlink" title="2.是不是有了MAC地址就能给你发消息了？"></a>2.是不是有了MAC地址就能给你发消息了？</h4><p>Mac 地址只能是两个设备之间传递时使用的，如果你要从大老远给我发消息，是离不开 IP 地址的。</p>
<h3 id="13-Linux-接收网络包的流程"><a href="#13-Linux-接收网络包的流程" class="headerlink" title="13.Linux 接收网络包的流程"></a>13.Linux 接收网络包的流程</h3><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230708180534715.png" alt="image-20230708180534715" style="zoom: 67%;">

<ol>
<li>首先，应用程序会调用 Socket 发送数据包的接口，从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</li>
<li>接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</li>
<li>如果使用的是 TCP 传输协议发送数据，那么<strong>先拷贝一个新的 sk_buff 副本</strong> ，（这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。）</li>
<li>接着，对 sk_buff 填充 TCP 头。（这里提一下，sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。）</li>
<li>然后交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</li>
<li>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。</li>
<li>这一些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</li>
<li>当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存。</li>
<li>最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 sk_buff 。</li>
</ol>
<h4 id="13-1-为什么全部数据包只用一个结构体来描述呢？"><a href="#13-1-为什么全部数据包只用一个结构体来描述呢？" class="headerlink" title="13.1 为什么全部数据包只用一个结构体来描述呢？"></a>13.1 为什么全部数据包只用一个结构体来描述呢？</h4><p>协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。</p>
<p>于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 <code>data</code> 的指针，比如：</p>
<ul>
<li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li>
<li>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li>
</ul>
<h4 id="13-2-怎么告诉操作系统这个网络包已经到达了呢？"><a href="#13-2-怎么告诉操作系统这个网络包已经到达了呢？" class="headerlink" title="13.2 怎么告诉操作系统这个网络包已经到达了呢？"></a>13.2 怎么告诉操作系统这个网络包已经到达了呢？</h4><p>最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。</p>
<p><strong>追问：这种方式的缺点是什么？</strong></p>
<p>在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。</p>
<p><strong>追问：那么Linux采取了哪种解决办法来解决这个问题？</strong></p>
<p>Linux 内核在 2.6 版本中引入了 <strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</p>
<p>当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p>
<p>硬件中断处理函数会做如下的事情：</p>
<ul>
<li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li>
<li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li>
</ul>
<p><strong>具体流程：</strong></p>
<ol>
<li>网络包到达：当网络包到达网卡时，网卡会将数据包存储在其接收缓冲区中。</li>
<li>DMA传输：使用DMA控制器，网卡通过总线（如PCI或PCIe）将数据包的内容直接传输到内存中，而无需CPU的介入。DMA控制器负责管理数据传输过程，将数据包写入内存指定的地址。</li>
<li>硬件中断请求：在数据包写入完成后，网卡会向CPU发起硬件中断请求。这是通过向CPU发送中断信号（如IRQ）来触发的。</li>
<li>中断处理函数调用：当CPU接收到硬件中断请求后，它会根据中断表中的配置，确定对应的中断处理函数。CPU会保存当前的上下文，并跳转到预先注册的中断处理函数的地址。</li>
<li>中断处理函数执行：中断处理函数会被执行，它负责处理接收到的网络包。处理函数会读取DMA传输的数据包内容，并进行相应的操作，如解析网络协议、进行数据处理、触发事件等。</li>
<li>中断处理完成：中断处理函数执行完毕后，CPU会恢复之前保存的上下文，并继续执行之前的任务。</li>
</ol>
<p><strong>好处：</strong></p>
<p>通过使用DMA技术，<strong>将网络包的数据直接写入内存，可以减少CPU的负载，因为数据传输的过程不需要CPU直接参与每个数据字节的传输</strong>。</p>
<h4 id="13-3发送网络数据的时候，涉及几次内存拷贝操作？"><a href="#13-3发送网络数据的时候，涉及几次内存拷贝操作？" class="headerlink" title="13.3发送网络数据的时候，涉及几次内存拷贝操作？"></a>13.3发送网络数据的时候，涉及几次内存拷贝操作？</h4><ol>
<li>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li>
<li>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</li>
<li>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff</li>
</ol>
<h2 id="HTTP篇"><a href="#HTTP篇" class="headerlink" title="HTTP篇"></a>HTTP篇</h2><h3 id="1-HTTP是什么？"><a href="#1-HTTP是什么？" class="headerlink" title="1.HTTP是什么？"></a>1.HTTP是什么？</h3><p>HTTP 全称是<strong>超文本传输协议</strong>。<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<h3 id="2-HTTP-常见状态码有哪些？"><a href="#2-HTTP-常见状态码有哪些？" class="headerlink" title="2.HTTP 常见状态码有哪些？"></a>2.HTTP 常见状态码有哪些？</h3><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/6-五大类HTTP状态码.png" alt=" 五大类 HTTP 状态码 " style="zoom:67%;">

<ul>
<li><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>
</li>
<li><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
</li>
<li><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li><p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p>
</li>
<li><p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p>
</li>
<li><p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</p>
</li>
</ul>
</li>
</ul>
<p>​			301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。	</p>
<ul>
<li><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li><p>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</p>
</li>
<li><p>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</p>
</li>
<li><p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p>
</li>
</ul>
</li>
<li><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li><p>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p>
</li>
<li><p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p>
</li>
<li><p>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p>
</li>
<li><p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-HTTP-常见字段有哪些？"><a href="#3-HTTP-常见字段有哪些？" class="headerlink" title="3.HTTP 常见字段有哪些？"></a>3.HTTP 常见字段有哪些？</h3><ul>
<li><p><em>Host</em> 字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.A.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>Content-Length 字段</em></p>
<p>服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p>
<p><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong>。</p>
</li>
<li><p><em>Connection 字段</em></p>
<p>用于请求复用，常见的字段值——Keep-Alive（长连接）</p>
</li>
<li><p><em>Content-Type 字段</em></p>
<p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; Charset=utf-8</span><br></pre></td></tr></table></figure>

<p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p>
<p>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>

<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p>
</li>
<li><p><em>Content-Encoding 字段</em></p>
<p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>

<p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p>
<p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-在HTTP请求中，GET-和-POST-有什么区别？"><a href="#4-在HTTP请求中，GET-和-POST-有什么区别？" class="headerlink" title="4.在HTTP请求中，GET 和 POST 有什么区别？"></a>4.在HTTP请求中，GET 和 POST 有什么区别？</h3><ul>
<li>GET 的语义是从服务器获取指定的资源</li>
<li>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</li>
</ul>
<p><strong>追问：GET 和 POST 方法都是安全和幂等的吗？</strong></p>
<p>答：GET 的语义是请求获取指定的资源。GET 方法是<strong>安全、幂等</strong>、可被缓存的。</p>
<p>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST <strong>不安全，不幂等</strong>，（大部分实现）不可缓存。</p>
<p>但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：</p>
<ul>
<li>可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。</li>
<li>可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。</li>
</ul>
<h3 id="5-HTTP-缓存有哪些实现方式？"><a href="#5-HTTP-缓存有哪些实现方式？" class="headerlink" title="5.HTTP 缓存有哪些实现方式？"></a>5.HTTP 缓存有哪些实现方式？</h3><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
<p> <strong>简述一下强制缓存？</strong></p>
<p>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。控制强制缓存有两个字段，分别是<code>Cache-Control</code>和<code>Expires</code>，其中</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p><code>Cache-control</code> 选项更多，设置更加精细，所以一般使用 Cache-Control 来实现强缓存。使用该方式实现流程如下：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>
</ul>
<p><strong>简述一下协商缓存？</strong></p>
<p><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/缓存etag.png" alt="img" style="zoom:50%;">

<p>该方法也有两种控制方式，现在一般使用请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段进行标识与判断。</p>
<p>其中，</p>
<ul>
<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
<p><strong>两种缓存有什么关系？</strong></p>
<p>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p>
<img src="计网/http缓存.png" alt="img" style="zoom: 50%;">

<h3 id="6-HTTP-的特性"><a href="#6-HTTP-的特性" class="headerlink" title="6.HTTP 的特性"></a>6.HTTP 的特性</h3><h4 id="6-1-HTTP有哪些优点？"><a href="#6-1-HTTP有哪些优点？" class="headerlink" title="6.1 HTTP有哪些优点？"></a>6.1 HTTP有哪些优点？</h4><ul>
<li><strong>简单：</strong>HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong></li>
<li><strong>灵活且易于扩展：</strong>各类请求方法、URI&#x2F;URL、状态码、头字段等都可以自定义组成和扩充</li>
<li><strong>应用广泛和跨平台</strong></li>
</ul>
<h4 id="6-2-HTTP-x2F-1-1相比于HTTP-x2F-1-0有哪些优势？自身还有哪些不足？"><a href="#6-2-HTTP-x2F-1-1相比于HTTP-x2F-1-0有哪些优势？自身还有哪些不足？" class="headerlink" title="6.2 HTTP&#x2F;1.1相比于HTTP&#x2F;1.0有哪些优势？自身还有哪些不足？"></a>6.2 HTTP&#x2F;1.1相比于HTTP&#x2F;1.0有哪些优势？自身还有哪些不足？</h4><p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的<strong>改进</strong>：</p>
<ul>
<li>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li>
<li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ul>
<p>HTTP&#x2F;1.1 还存在的不足有：</p>
<ul>
<li><strong>头部信息冗长</strong>。请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次<strong>互相发送相同的首部造成的浪费较多</strong>；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li>
<li><strong>没有请求优先级控制</strong>；</li>
<li><strong>请求只能从客户端开始，服务器只能被动响应</strong>。</li>
</ul>
<h5 id="6-2-1-如何优化-HTTP-x2F-1-1？"><a href="#6-2-1-如何优化-HTTP-x2F-1-1？" class="headerlink" title="6.2.1 如何优化 HTTP&#x2F;1.1？"></a>6.2.1 如何优化 HTTP&#x2F;1.1？</h5><ul>
<li><em>尽量避免发送 HTTP 请求</em>；<ul>
<li>通过缓存技术来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。</li>
</ul>
</li>
<li><em>在需要发送 HTTP 请求时，考虑如何减少请求次数</em>；<ul>
<li><em>减少重定向请求次数</em>；将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；</li>
<li><em>合并请求</em>；将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；（这种方法的缺陷：<strong>当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件</strong>，这显然带来了额外的网络消耗。）</li>
<li><em>延迟发送请求</em>；请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源</li>
</ul>
</li>
<li><em>减少服务器的 HTTP 响应的数据大小</em>；对响应的资源进行<strong>压缩</strong>，这样就可以减少响应的数据大小，从而提高网络传输的效率。</li>
</ul>
<h4 id="6-3-HTTP-x2F-2-进行了哪些改进？还存在哪些不足？"><a href="#6-3-HTTP-x2F-2-进行了哪些改进？还存在哪些不足？" class="headerlink" title="6.3 HTTP&#x2F;2 进行了哪些改进？还存在哪些不足？"></a>6.3 HTTP&#x2F;2 进行了哪些改进？还存在哪些不足？</h4><p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的<strong>改进</strong>：</p>
<ul>
<li><p>基于HTTPS，具有<strong>安全性</strong></p>
</li>
<li><p><strong>头部压缩：</strong>采用<code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p>
</li>
<li><p><strong>二进制格式：</strong>全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p>
</li>
<li><p><strong>并发传输：</strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。</p>
</li>
<li><p><strong>服务器主动推送资源：</strong>服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p>
<p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>
</li>
</ul>
<p>HTTP&#x2F;2 还存在的<strong>不足</strong>：</p>
<p>没有真正解决队头阻塞问题。HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</p>
<p><strong>追问：两种队头阻塞有什么不同？</strong></p>
<ul>
<li>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li>
<li>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li>
</ul>
<h5 id="6-3-1-如何优化-HTTP-x2F-2？"><a href="#6-3-1-如何优化-HTTP-x2F-2？" class="headerlink" title="6.3.1 如何优化 HTTP&#x2F;2？"></a>6.3.1 如何优化 HTTP&#x2F;2？</h5><ul>
<li><p><strong>头部压缩。</strong>常见的 HTTP 头部通过<strong>静态表和 Huffman 编码</strong>的方式进行压缩，而且针对后续的请求头部，还可以建立<strong>动态表</strong>，大大提高了编码效率，同时节约了带宽资源。</p>
<p>不过，动态表并非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP&#x2F;2 连接时长或者请求次数。</p>
</li>
<li><p><strong>HTTP&#x2F;2 实现了 Stream 并发</strong>，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 可以并发，即使乱序发送帧也没问题，但是同一个 Stream 里的帧必须严格有序。</p>
<p>另外，可以根据资源的渲染顺序来设置 Stream 的<strong>优先级</strong>，从而提高用户体验。</p>
</li>
<li><p><strong>服务器支持主动推送资源</strong>，大大提升了消息的传输性能，（服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。）</p>
</li>
</ul>
<h4 id="6-4-HTTP-x2F-3-进行了哪些改进？还存在哪些不足？"><a href="#6-4-HTTP-x2F-3-进行了哪些改进？还存在哪些不足？" class="headerlink" title="6.4 HTTP&#x2F;3 进行了哪些改进？还存在哪些不足？"></a>6.4 HTTP&#x2F;3 进行了哪些改进？还存在哪些不足？</h4><p>HTTP&#x2F;3采用基于 UDP 的 <strong>QUIC 协议</strong></p>
<p>相比于HTTP&#x2F;2，存在的<strong>优势</strong>：</p>
<ul>
<li><p><strong>无队头阻塞：</strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。</p>
</li>
<li><p><strong>更快的连接建立：</strong>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p>
<p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p>
<p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商。</p>
<p>在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p>
</li>
<li><p><strong>连接迁移：</strong>在HTTP&#x2F;2和HTTP&#x2F;1.1中，一条TCP连接是通过源 IP、源端口、目的 IP、目的端口来进行确定，因此，有时只是切换网络就会造成IP地址发生变化，从而断开连接再重新建立连接，造成网络卡顿。QUIC 协议通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使网络变化导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
</li>
</ul>
<h3 id="7-HTTP-与-HTTPS-具有哪些区别？"><a href="#7-HTTP-与-HTTPS-具有哪些区别？" class="headerlink" title="7. HTTP 与 HTTPS 具有哪些区别？"></a>7. HTTP 与 HTTPS 具有哪些区别？</h3><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h4 id="7-1-HTTPS-解决了-HTTP哪些问题？"><a href="#7-1-HTTPS-解决了-HTTP哪些问题？" class="headerlink" title="7.1 HTTPS 解决了 HTTP哪些问题？"></a>7.1 HTTPS 解决了 HTTP哪些问题？</h4><ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p> <strong>如何解决的？</strong></p>
<ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
<p><strong>追问</strong></p>
<ol>
<li><p>混合加密如何实现？</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
</li>
<li><p>对称加密和非对称加密分别具有哪些特性？</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
</li>
<li><p>摘要算法 + 数字签名是如何实现的？</p>
<p>在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p>
<p><strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong></p>
</li>
<li><p>公钥加密、私钥解密和私钥加密、公钥解密有什么区别？</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
<li><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/22-数字证书工作流程.jpeg" alt="数子证书工作流程" style="zoom: 67%;"></li>
</ul>
</li>
</ol>
<h4 id="7-2-HTTPS-是如何建立连接的？其间交互了什么？"><a href="#7-2-HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="7.2 HTTPS 是如何建立连接的？其间交互了什么？"></a>7.2 HTTPS 是如何建立连接的？其间交互了什么？</h4><p>有两种算法：RSA 和 ECDHE</p>
<p><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpeg" alt="HTTPS 连接建立过程"></p>
<p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。</p>
<h5 id="7-2-1-RSA-算法和-ECDHE-算法有什么区别？"><a href="#7-2-1-RSA-算法和-ECDHE-算法有什么区别？" class="headerlink" title="7.2.1 RSA 算法和 ECDHE 算法有什么区别？"></a>7.2.1 RSA 算法和 ECDHE 算法有什么区别？</h5><ul>
<li><p>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</p>
<ul>
<li>若服务器端私钥泄露，则可以用其来解密所有的过去的会话信息；不断拦截公钥以及协商数据，可能破解出私钥</li>
<li>ECDHE 的临时私钥是每个会话独特的，即使服务端私钥丢失，也不会造成过去会话全部被破解；不断拦截也无法破解（目前计算机无法做到）</li>
</ul>
</li>
<li><p>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间（这个是 RFC 文档规定的，具体原因文档没有说明，所以这点我也不太明白）；</p>
</li>
<li><p>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；</p>
</li>
</ul>
<h5 id="7-2-2-为什么-TLS1-3只需要1RTT？"><a href="#7-2-2-为什么-TLS1-3只需要1RTT？" class="headerlink" title="7.2.2 为什么 TLS1.3只需要1RTT？"></a>7.2.2 为什么 TLS1.3只需要1RTT？</h5><p>客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥。</p>
<p>服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了。</p>
<p>而且，TLS1.3 对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法。</p>
<h5 id="7-2-3客户端校验数字证书的流程是怎样的？"><a href="#7-2-3客户端校验数字证书的流程是怎样的？" class="headerlink" title="7.2.3客户端校验数字证书的流程是怎样的？"></a>7.2.3客户端校验数字证书的流程是怎样的？</h5><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/证书的校验.png" alt="img" style="zoom:50%;">

<p>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
<h4 id="7-3-HTTPS-的应用数据是如何保证完整性的？"><a href="#7-3-HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="7.3 HTTPS 的应用数据是如何保证完整性的？"></a>7.3 HTTPS 的应用数据是如何保证完整性的？</h4><ul>
<li>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li>
<li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li>
<li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li>
<li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li>
</ul>
<h4 id="7-4-HTTPS-一定是安全可靠的吗？"><a href="#7-4-HTTPS-一定是安全可靠的吗？" class="headerlink" title="7.4 HTTPS 一定是安全可靠的吗？"></a>7.4 HTTPS 一定是安全可靠的吗？</h4><p><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p>
<h4 id="7-5-为什么抓包工具能截取-HTTPS-数据？"><a href="#7-5-为什么抓包工具能截取-HTTPS-数据？" class="headerlink" title="7.5 为什么抓包工具能截取 HTTPS 数据？"></a>7.5 为什么抓包工具能截取 HTTPS 数据？</h4><p>使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用</p>
<h4 id="7-6-HTTPS-可以如何优化？"><a href="#7-6-HTTPS-可以如何优化？" class="headerlink" title="7.6 HTTPS 可以如何优化？"></a>7.6 HTTPS 可以如何优化？</h4><p>对于硬件优化的方向，因为 HTTPS 是属于计算密集型，应该选择计算力更强的 CPU，而且最好选择<strong>支持 AES-NI 特性的 CPU</strong>，这个特性可以在硬件级别优化 AES 对称加密算法，加快应用数据的加解密。</p>
<p>对于软件优化的方向，如果可以，把软件升级成较新的版本，比如将 Linux 内核 2.X 升级成 4.X，将 openssl 1.0.1 升级到 1.1.1，因为新版本的软件不仅会提供新的特性，而且还会修复老版本的问题。</p>
<p>对于协议优化的方向：</p>
<ul>
<li>密钥交换算法应该选择 <strong>ECDHE 算法</strong>，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。</li>
<li>将 TLS1.2 升级 <strong>TLS1.3</strong>，因为 TLS1.3 的握手过程只需要 1 RTT，而且安全性更强。</li>
</ul>
<p>对于证书优化的方向：</p>
<ul>
<li>服务器应该选用 <strong>ECDSA 证书</strong>，而非 RSA 证书，因为在相同安全级别下，ECC 的密钥长度比 RSA 短很多，这样可以提高证书传输的效率；</li>
<li>服务器应该开启 <strong>OCSP Stapling</strong> 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；（服务器向 CA 周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它。）</li>
</ul>
<p>对于重连 HTTPS 时，我们可以使用一些技术让客户端和服务端使用上一次 HTTPS 连接使用的会话密钥，直接恢复会话，而不用再重新走完整的 TLS 握手过程。</p>
<p>常见的<strong>会话重用</strong>技术有 Session ID 和 Session Ticket，用了会话重用技术，当再次重连 HTTPS 时，只需要 1 RTT 就可以恢复会话。对于 TLS1.3 使用 Pre-shared Key 会话重用技术，只需要 0 RTT 就可以恢复会话。</p>
<p>这些会话重用技术虽然好用，但是存在一定的安全风险，它们不仅不具备前向安全，而且有重放攻击的风险，所以应当对会话密钥设定一个合理的过期时间。</p>
<p><strong>追问：简述一下 Session ID 、 Session Ticket 和 Pre-shared Key 会话重用技术，以及各自的优缺点？</strong></p>
<ul>
<li><p>Session ID 的工作原理是，<strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>，Session ID 和会话密钥相当于 key-value 的关系。当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信。当然为了安全性，内存中的会话密钥会定期失效。</p>
<ul>
<li>该方法的缺点是：<ol>
<li>服务器必须保持每一个客户端的会话密钥，随着客户端的增多，<strong>服务器的内存压力也会越大</strong>。</li>
<li>现在网站服务一般是由多台服务器通过负载均衡提供服务的，<strong>客户端再次连接不一定会命中上次访问过的服务器</strong>，于是还要走完整的 TLS 握手过程；</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>Session Ticket 的工作原理是服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。</p>
<p>客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。对于集群服务器的话，<strong>要确保每台服务器加密 「会话密钥」的密钥是一致的</strong>，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话。</p>
<p>Session ID 和 Session Ticket <strong>都不具备前向安全性</strong>，因为一旦加密「会话密钥」的密钥被破解或者服务器泄漏「会话密钥」，前面劫持的通信密文都会被破解。</p>
</li>
<li><p>Pre-shared Key 原理与 Ticket 原理类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端，这种方式叫 <strong>Pre-shared Key</strong>。对于重连只需要 <strong>0RTT</strong> 即可。</p>
</li>
</ul>
<p><strong>追问：上述三种方法是否存在重放攻击？</strong></p>
<p>上述三种方法都存在重放攻击。</p>
<p>简述重放攻击：假设 Alice 想向 Bob 证明自己的身份。 Bob 要求 Alice 的密码作为身份证明，爱丽丝应尽全力提供（可能是在经过如哈希函数的转换之后）。与此同时，Eve 窃听了对话并保留了密码（或哈希）。</p>
<p>交换结束后，Eve（冒充 Alice ）连接到 Bob。当被要求提供身份证明时，Eve 发送从 Bob 接受的最后一个会话中读取的 Alice 的密码（或哈希），从而授予 Eve 访问权限。</p>
<p>重放攻击的危险之处在于，如果中间人截获了某个客户端的 Session ID 或 Session Ticket 以及 POST 报文，而一般 POST 请求会改变数据库的数据，中间人就可以利用此截获的报文，不断向服务器发送该报文，这样就会导致数据库的数据被中间人改变了，而客户是不知情的。</p>
<p>避免重放攻击的方式就是需要<strong>对会话密钥设定一个合理的过期时间</strong>。</p>
<h3 id="8-既然已经存在-HTTP-协议，那么为何还需要-RPC-协议？"><a href="#8-既然已经存在-HTTP-协议，那么为何还需要-RPC-协议？" class="headerlink" title="8.既然已经存在 HTTP 协议，那么为何还需要 RPC 协议？"></a>8.既然已经存在 HTTP 协议，那么为何还需要 RPC 协议？</h3><ul>
<li>纯裸 TCP 是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li>
<li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li>
<li>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合</strong>。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li>
<li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP&#x2F;1.1 <strong>性能</strong>要更好，所以大部分公司内部都还在使用 RPC。</li>
<li><strong>HTTP&#x2F;2.0</strong> 在 <strong>HTTP&#x2F;1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li>
</ul>
<h3 id="9-既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#9-既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="9.既然有 HTTP 协议，为什么还要有 WebSocket？"></a>9.既然有 HTTP 协议，为什么还要有 WebSocket？</h3><ul>
<li>TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP&#x2F;1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。</li>
<li>在 HTTP&#x2F;1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。</li>
<li>对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。</li>
<li>WebSocket 和 socket 几乎没有任何关系，只是叫法相似。</li>
<li>正因为各个浏览器都支持 HTTP协议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。</li>
</ul>
<hr>
<h2 id="TCP篇"><a href="#TCP篇" class="headerlink" title="TCP篇"></a>TCP篇</h2><h3 id="1-什么是-TCP-？为什么需要-TCP-协议？"><a href="#1-什么是-TCP-？为什么需要-TCP-协议？" class="headerlink" title="1.什么是 TCP ？为什么需要 TCP 协议？"></a>1.什么是 TCP ？为什么需要 TCP 协议？</h3><ul>
<li>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</li>
<li><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></li>
</ul>
<p><strong>追问：简述 TCP 的三个特性？</strong></p>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li>
</ul>
<p><strong>什么是 TCP 连接？</strong></p>
<ul>
<li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 <strong>Socket、序列号和窗口大小</strong>称为连接。</li>
</ul>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710141612761.png" alt="image-20230710141612761" style="zoom:50%;">

<h3 id="2-UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#2-UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="2.UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>2.UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3><p><strong>TCP 和 UDP 区别：</strong></p>
<p><em>1. 连接</em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议。</li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em>6. 传输方式</em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em>7. 分片不同</em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<p><strong>TCP 和 UDP 应用场景：</strong></p>
<p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输；</li>
<li>HTTP &#x2F; HTTPS；</li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>
<h4 id="2-1为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><a href="#2-1为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？" class="headerlink" title="2.1为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？"></a>2.1为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</h4><p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p>
<h4 id="2-2为什么-UDP-头部有「包长度」字段，而-TCP-头部则没有「包长度」字段呢？"><a href="#2-2为什么-UDP-头部有「包长度」字段，而-TCP-头部则没有「包长度」字段呢？" class="headerlink" title="2.2为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？"></a>2.2为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</h4><p>因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code> 字节的整数倍。如果去掉 UDP 的「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以我觉得这可能是为了补全 UDP 首部长度是 <code>4</code> 字节的整数倍，才补充了「包长度」字段。</p>
<h4 id="2-3TCP-和-UDP-可以使用同一个端口吗？"><a href="#2-3TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="2.3TCP 和 UDP 可以使用同一个端口吗？"></a>2.3TCP 和 UDP 可以使用同一个端口吗？</h4><p><strong>可以</strong>。</p>
<ul>
<li>TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。</li>
<li>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</li>
<li>因此， TCP&#x2F;UDP 各自的端口号也相互独立，互不影响。</li>
</ul>
<h4 id="2-4追问-多个TCP可以绑定同一个端口吗"><a href="#2-4追问-多个TCP可以绑定同一个端口吗" class="headerlink" title="2.4追问:多个TCP可以绑定同一个端口吗?"></a>2.4追问:多个TCP可以绑定同一个端口吗?</h4><p>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。</p>
<p>如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。</p>
<p><strong>追问:重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？</strong></p>
<p>TIME_WAIT 状态还未结束。要解决这个问题，我们可以对 socket 设置 SO_REUSEADDR 属性。</p>
<h4 id="2-5客户端的端口可以重复使用吗？"><a href="#2-5客户端的端口可以重复使用吗？" class="headerlink" title="2.5客户端的端口可以重复使用吗？"></a>2.5客户端的端口可以重复使用吗？</h4><p>在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。</p>
<p>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。</p>
<h3 id="3-简述-TCP-三次握手？"><a href="#3-简述-TCP-三次握手？" class="headerlink" title="3.简述 TCP 三次握手？"></a>3.简述 TCP 三次握手？</h3><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/TCP三次握手.drawio.png" alt="TCP 三次握手" style="zoom:50%;">

<ol>
<li>一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态</li>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，<strong>这次报文可以携带客户到服务端的数据</strong>，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ol>
<h4 id="3-1为什么使用三次握手，而不是两次或者四次？"><a href="#3-1为什么使用三次握手，而不是两次或者四次？" class="headerlink" title="3.1为什么使用三次握手，而不是两次或者四次？"></a>3.1为什么使用三次握手，而不是两次或者四次？</h4><ul>
<li><p>三次握手才可以阻止重复历史连接的初始化（主要原因）</p>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/fe898053d2e93abac950b1637645943f.png" alt="两次握手无法阻止历史连接" style="zoom:50%;">

<p>如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</p>
<p>因此，<strong>要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p>
<p>所以，<strong>TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。</strong></p>
</li>
<li><p>三次握手才可以同步双方的初始序列号</p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
</li>
<li><p>三次握手才可以避免资源浪费</p>
<p>如果只有「两次握手」，当客户端发生的 <code>SYN</code> 报文在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，<strong>由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 <code>ACK</code> 报文，所以服务端每收到一个 <code>SYN</code> 就只能先主动建立一个连接</strong>，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
</li>
</ul>
<p>因此，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<h4 id="3-2为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#3-2为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="3.2为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>3.2为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h4><ul>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li>
</ul>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/isn相同.png" alt="img" style="zoom:50%;">

<h4 id="3-3第一次握手丢失了，会发生什么？"><a href="#3-3第一次握手丢失了，会发生什么？" class="headerlink" title="3.3第一次握手丢失了，会发生什么？"></a>3.3第一次握手丢失了，会发生什么？</h4><ul>
<li>如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</li>
<li>客户端的 SYN 报文最大重传次数由 <code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。第二次重传超时时间是前一次的二倍。</li>
<li>在达到最大重传次数之后，再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li>
</ul>
<h4 id="3-4第二次握手丢失了，会发生什么？"><a href="#3-4第二次握手丢失了，会发生什么？" class="headerlink" title="3.4第二次握手丢失了，会发生什么？"></a>3.4第二次握手丢失了，会发生什么？</h4><ul>
<li>如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</li>
<li>如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</li>
<li>因此，当第二次握手丢失了，客户端和服务端都会重传：<ul>
<li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</li>
<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li>
</ul>
</li>
<li>如果达到各自最大重传次数之后，等待一段时间之后就会断开连接。</li>
</ul>
<h4 id="3-5第三次握手丢失了，会发生什么？"><a href="#3-5第三次握手丢失了，会发生什么？" class="headerlink" title="3.5第三次握手丢失了，会发生什么？"></a>3.5第三次握手丢失了，会发生什么？</h4><p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p>
<p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<h4 id="3-6什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#3-6什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="3.6什么是 SYN 攻击？如何避免 SYN 攻击？"></a>3.6什么是 SYN 攻击？如何避免 SYN 攻击？</h4><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务。</p>
<p><strong>避免 SYN 攻击可以采用以下四种方法：</strong></p>
<ul>
<li>调大 netdev_max_backlog；（当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值）</li>
<li>增大 TCP 半连接队列；</li>
<li>开启 tcp_syncookies；在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</li>
<li>减少 SYN+ACK 重传次数，加快处于 SYN_REVC 状态的 TCP 连接断开。</li>
</ul>
<p><strong>什么是半连接队列和全连接队列？</strong></p>
<p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accept 队列；</li>
</ul>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/format,png-20230309230622886.png" alt="正常流程" style="zoom:50%;">

<p>SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p>
<p><strong>如果SYN半连接队列满了，那么连接只能丢弃吗？</strong></p>
<p>并不是这样，<strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</strong>，在前面我们源码分析也可以看到这点，当开启了 syncookies 功能就不会丢弃连接。</p>
<p>syncookies 参数主要有以下三个值：</p>
<ul>
<li>0 值，表示关闭该功能；</li>
<li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li>
<li>2 值，表示无条件开启功能；</li>
</ul>
<h3 id="4-简述-TCP-四次挥手？"><a href="#4-简述-TCP-四次挥手？" class="headerlink" title="4.简述 TCP 四次挥手？"></a>4.简述 TCP 四次挥手？</h3><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:50%;">

<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，所以必须要得继续 read 接收缓冲区已接收的数据</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h4 id="4-1为什么挥手需要四次？"><a href="#4-1为什么挥手需要四次？" class="headerlink" title="4.1为什么挥手需要四次？"></a>4.1为什么挥手需要四次？</h4><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p>
<h4 id="4-2第一次挥手丢失会发生什么？"><a href="#4-2第一次挥手丢失会发生什么？" class="headerlink" title="4.2第一次挥手丢失会发生什么？"></a>4.2第一次挥手丢失会发生什么？</h4><ul>
<li>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</li>
<li>当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 <code>close</code> 状态。</li>
</ul>
<h4 id="4-3第二次挥手丢失了，会发生什么？"><a href="#4-3第二次挥手丢失了，会发生什么？" class="headerlink" title="4.3第二次挥手丢失了，会发生什么？"></a>4.3第二次挥手丢失了，会发生什么？</h4><ul>
<li>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</li>
<li>ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</li>
<li>当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 <code>close</code> 状态。</li>
</ul>
<p><strong>注意点：</strong></p>
<ul>
<li>如果采用的是 close 方法调用关闭的话，那么客户端处于 FIN_WAIT_2 的时间有限，超出时间限制则直接进行关闭。</li>
<li>如果采用的是 shutdown方法调用关闭的话，就会一直进行等待。</li>
</ul>
<h4 id="4-4第三次挥手丢失了，会发生什么？"><a href="#4-4第三次挥手丢失了，会发生什么？" class="headerlink" title="4.4第三次挥手丢失了，会发生什么？"></a>4.4第三次挥手丢失了，会发生什么？</h4><ul>
<li>服务端重传第三次挥手报文、</li>
<li>当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</li>
<li>客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。</li>
</ul>
<p><strong>如果采用的是shutdown的话呢？</strong></p>
<p>个人认为会死等</p>
<h4 id="4-5第四次挥手丢失了，会发生什么？"><a href="#4-5第四次挥手丢失了，会发生什么？" class="headerlink" title="4.5第四次挥手丢失了，会发生什么？"></a>4.5第四次挥手丢失了，会发生什么？</h4><ul>
<li>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</li>
<li>达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。</li>
<li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</li>
</ul>
<h4 id="4-5为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#4-5为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="4.5为什么 TIME_WAIT 等待的时间是 2MSL？"></a>4.5为什么 TIME_WAIT 等待的时间是 2MSL？</h4><ul>
<li><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</li>
<li>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</li>
<li>相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</li>
<li>如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</li>
</ul>
<p><strong>简述MSL和TLL的区别？</strong></p>
<ul>
<li><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</li>
<li><code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</li>
<li>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</li>
<li><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</li>
</ul>
<h4 id="4-6为什么需要-TIME-WAIT-状态？"><a href="#4-6为什么需要-TIME-WAIT-状态？" class="headerlink" title="4.6为什么需要 TIME_WAIT 状态？"></a>4.6为什么需要 TIME_WAIT 状态？</h4><p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；<ul>
<li>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></li>
</ul>
</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；<ul>
<li>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong>也就是当 ACK 报文丢失的时候，进行重传，恰好最大时间为 2MSL。</li>
</ul>
</li>
</ul>
<h4 id="4-7TIME-WAIT-过多有什么危害？"><a href="#4-7TIME-WAIT-过多有什么危害？" class="headerlink" title="4.7TIME_WAIT 过多有什么危害？"></a>4.7TIME_WAIT 过多有什么危害？</h4><ul>
<li><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。</li>
<li><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</li>
</ul>
<p><strong>追问：简述客户端的端口可否重复使用？</strong></p>
<ul>
<li>在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。</li>
<li>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。</li>
<li>所以，如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</li>
</ul>
<h4 id="4-8如何优化-TIME-WAIT？"><a href="#4-8如何优化-TIME-WAIT？" class="headerlink" title="4.8如何优化 TIME_WAIT？"></a>4.8如何优化 TIME_WAIT？</h4><ol>
<li><p>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</p>
<ul>
<li><p>打开 net.ipv4.tcp_tw_reuse则可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p>
<p>有一点需要注意的是，<strong>tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong></p>
</li>
<li><p>net.ipv4.tcp_timestamps 用于 TCP 时间戳的支持</p>
</li>
</ul>
</li>
<li><p><em>net.ipv4.tcp_max_tw_buckets</em></p>
<p>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong></p>
</li>
<li><p><em>程序中使用 SO_LINGER</em></p>
<p>TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p>
</li>
</ol>
<p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p>
<p><strong>追问:为什么一般不开启tcp_tw_reuse</strong></p>
<p>tcp_tw_reuse 的作用是让客户端快速复用处于 TIME_WAIT 状态的端口，相当于跳过了 TIME_WAIT 状态，这可能会出现这样的两个问题：</p>
<ul>
<li>历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。</li>
<li>如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;</li>
</ul>
<p>虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。</p>
<h4 id="4-9什么场景下服务端会主动断开连接呢？"><a href="#4-9什么场景下服务端会主动断开连接呢？" class="headerlink" title="4.9什么场景下服务端会主动断开连接呢？"></a>4.9什么场景下服务端会主动断开连接呢？</h4><ul>
<li>HTTP 没有使用长连接<ul>
<li><strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</li>
</ul>
</li>
<li>HTTP 长连接超时<ul>
<li>假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，<strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong>。</li>
</ul>
</li>
<li>HTTP 长连接的请求数量达到上限<ul>
<li>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</li>
<li><strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</li>
<li>解决方法是调大 keepalive_requests</li>
</ul>
</li>
</ul>
<p><strong>追问：不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong></p>
<ul>
<li>当客户端禁用了 HTTP Keep-Alive，这时候 HTTP 请求的 header 就会有 <code>Connection:close</code> 信息，这时服务端在发完 HTTP 响应后，就会主动关闭连接。HTTP 是请求-响应模型，发起方一直是客户端，HTTP Keep-Alive 的初衷是<strong>为客户端后续的请求重用连接</strong>，如果我们<strong>在某次 HTTP 请求-响应模型中，请求的 header 定义了 <code>connection：close</code> 信息，那不再重用这个连接的时机就只有在服务端了</strong>，所以我们在 HTTP 请求-响应这个周期的「末端」关闭连接是合理的。</li>
<li>当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。在服务端主动关闭连接的情况下，只要调用一次 close() 就可以释放连接，剩下的工作由内核 TCP 栈直接进行了处理，整个过程只有一次 syscall；如果是要求 客户端关闭，则服务端在写完最后一个 response 之后需要把这个 socket 放入 readable 队列，调用 select &#x2F; epoll 去等待事件；然后调用一次 read() 才能知道连接已经被关闭，这其中是两次 syscall，多一次用户态程序被激活执行，而且 socket 保持时间也会更长。</li>
</ul>
<h4 id="4-10如何应对服务端出现大量-CLOSE-WAIT-状态？"><a href="#4-10如何应对服务端出现大量-CLOSE-WAIT-状态？" class="headerlink" title="4.10如何应对服务端出现大量 CLOSE_WAIT 状态？"></a>4.10如何应对服务端出现大量 CLOSE_WAIT 状态？</h4><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p>
<h3 id="5-TCP-异常断开的几种可能"><a href="#5-TCP-异常断开的几种可能" class="headerlink" title="5.TCP 异常断开的几种可能"></a>5.TCP 异常断开的几种可能</h3><h4 id="5-1如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#5-1如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="5.1如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>5.1如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p><strong>TCP 保活机制</strong>。原理是定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<p><strong>追问：保活机制可能的三种情况</strong></p>
<ul>
<li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>第二种，对端主机宕机并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</li>
<li>第三种，是对端主机宕机（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<h4 id="5-2如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#5-2如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="5.2如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>5.2如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h4><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<h4 id="5-3TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#5-3TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="5.3TCP 连接，一端断电和进程崩溃有什么区别？"></a>5.3TCP 连接，一端断电和进程崩溃有什么区别？</h4><h4 id="5-4已建立连接的TCP，收到SYN会发生什么？"><a href="#5-4已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="5.4已建立连接的TCP，收到SYN会发生什么？"></a>5.4已建立连接的TCP，收到SYN会发生什么？</h4><p>即一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 Established 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？</p>
<ol>
<li><p><strong>客户端的 SYN 报文里的端口号与历史连接不相同</strong>。此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。旧的连接有两种情况。</p>
<ul>
<li>服务端发消息发现宕机，则断开连接</li>
<li>服务器不发消息，等待保活机制发现</li>
</ul>
</li>
<li><p><strong>客户端的 SYN 报文里的端口号与历史连接相同</strong></p>
<p><strong>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</strong></p>
<p><strong>接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</strong></p>
</li>
</ol>
<h4 id="5-5客户端主机宕机，又迅速重启"><a href="#5-5客户端主机宕机，又迅速重启" class="headerlink" title="5.5客户端主机宕机，又迅速重启"></a>5.5客户端主机宕机，又迅速重启</h4><p>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。</p>
<p>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</p>
<ul>
<li>如果客户端主机上<strong>没有</strong>进程绑定该 TCP 报文的目标端口号，那么客户端内核就会<strong>回复 RST 报文，重置该 TCP 连接</strong>；</li>
<li>如果客户端主机上<strong>有</strong>进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li>
</ul>
<p>所以，<strong>只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</strong>。</p>
<h4 id="5-6客户端主机宕机，一直没有重启"><a href="#5-6客户端主机宕机，一直没有重启" class="headerlink" title="5.6客户端主机宕机，一直没有重启"></a>5.6客户端主机宕机，一直没有重启</h4><p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p>
<h4 id="5-7拔掉网线几秒，再插回去，原本的-TCP-连接还存在吗？"><a href="#5-7拔掉网线几秒，再插回去，原本的-TCP-连接还存在吗？" class="headerlink" title="5.7拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？"></a>5.7拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？</h4><p>有数据传输的情况：</p>
<ul>
<li>在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。</li>
<li>在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。</li>
</ul>
<p>没有数据传输的情况：</p>
<ul>
<li>如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</li>
<li>如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</li>
</ul>
<h3 id="6-为什么说TCP是可靠的？"><a href="#6-为什么说TCP是可靠的？" class="headerlink" title="6.为什么说TCP是可靠的？"></a>6.为什么说TCP是可靠的？</h3><p> TCP 的<strong>乱序重排、应答确认、报文重传和流量控制四种机制。</strong></p>
<ol>
<li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>
<li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为丢失并进行重传。</li>
<li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>
<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li>
</ol>
<h4 id="6-1追问：重传机制有哪几种？"><a href="#6-1追问：重传机制有哪几种？" class="headerlink" title="6.1追问：重传机制有哪几种？"></a>6.1追问：重传机制有哪几种？</h4><ul>
<li><p>超时重传。超时时间RTO一般通过数据往返一次的时间RTT来进行函数求得，<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
</li>
<li><p>快速重传。<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710171216945.png" alt="image-20230710171216945" style="zoom:50%;">

<p>缺点：如果Seq2和Seq3均发生丢失，那么如何告知将二者均进行重传</p>
</li>
<li><p>SACK。这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710171336442.png" alt="image-20230710171336442" style="zoom:50%;">
</li>
<li><p>D-SACK。主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p>
<ul>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ul>
</li>
</ul>
<h4 id="6-2追问：窗口大小怎么确定？"><a href="#6-2追问：窗口大小怎么确定？" class="headerlink" title="6.2追问：窗口大小怎么确定？"></a>6.2追问：窗口大小怎么确定？</h4><p>所以，通常窗口的大小是由接收方的窗口大小来决定的。<strong>发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<h4 id="6-3追问：接收窗口和发送窗口的大小是相等的吗？"><a href="#6-3追问：接收窗口和发送窗口的大小是相等的吗？" class="headerlink" title="6.3追问：接收窗口和发送窗口的大小是相等的吗？"></a>6.3追问：接收窗口和发送窗口的大小是相等的吗？</h4><ul>
<li>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。在引入拥塞控制之后，发送窗口等于接收窗口和拥塞窗口的最小值。</li>
<li>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</li>
</ul>
<h4 id="6-4追问：窗口关闭是什么？有哪些风险？"><a href="#6-4追问：窗口关闭是什么？有哪些风险？" class="headerlink" title="6.4追问：窗口关闭是什么？有哪些风险？"></a>6.4追问：窗口关闭是什么？有哪些风险？</h4><p>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</p>
<p><strong>窗口关闭潜在的危险：</strong>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。。</p>
<h4 id="6-5追问：TCP-是如何解决窗口关闭时，潜在的死锁现象呢？"><a href="#6-5追问：TCP-是如何解决窗口关闭时，潜在的死锁现象呢？" class="headerlink" title="6.5追问：TCP 是如何解决窗口关闭时，潜在的死锁现象呢？"></a>6.5追问：TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</h4><ul>
<li><p>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p>
</li>
<li><p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<ul>
<li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li>
<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li>
</ul>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p>
</li>
</ul>
<h4 id="6-6追问：简述糊涂窗口综合症"><a href="#6-6追问：简述糊涂窗口综合症" class="headerlink" title="6.6追问：简述糊涂窗口综合症"></a>6.6追问：简述糊涂窗口综合症</h4><ul>
<li><strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</li>
<li>要知道，我们的 <code>TCP + IP</code> 头有 <code>40</code> 个字节，为了传输那几个字节的数据，要搭上这么大的开销，这太不经济了。</li>
</ul>
<p><strong>解决办法：</strong></p>
<ul>
<li><p>让接收方不通告小窗口给发送方</p>
<ul>
<li><p>当「窗口大小」小于 min( MSS，缓存空间&#x2F;2 ) ，也就是小于 MSS 与 1&#x2F;2 缓存大小中的最小值时，就会向发送方通告窗口为 <code>0</code>，也就阻止了发送方再发数据过来。</p>
<p>等到接收方处理了一些数据后，窗口大小 &gt;&#x3D; MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p>
</li>
</ul>
</li>
<li><p>让发送方避免发送小数据</p>
<ul>
<li>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：<ul>
<li>条件一：要等到窗口大小 &gt;&#x3D; <code>MSS</code> 并且 数据大小 &gt;&#x3D; <code>MSS</code>；</li>
<li>条件二：收到之前发送数据的 <code>ack</code> 回包；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>因此，接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</strong>。</p>
</li>
</ul>
<h4 id="6-7为什么要有拥塞控制，不是有流量控制了吗？"><a href="#6-7为什么要有拥塞控制，不是有流量控制了吗？" class="headerlink" title="6.7为什么要有拥塞控制，不是有流量控制了吗？"></a>6.7为什么要有拥塞控制，不是有流量控制了吗？</h4><ul>
<li><p>前流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p>
</li>
<li><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p>
</li>
<li><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
</li>
<li><p>所以，TCP 定义了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p>
</li>
</ul>
<h4 id="6-8什么是拥塞窗口？和发送窗口有什么关系呢？"><a href="#6-8什么是拥塞窗口？和发送窗口有什么关系呢？" class="headerlink" title="6.8什么是拥塞窗口？和发送窗口有什么关系呢？"></a>6.8什么是拥塞窗口？和发送窗口有什么关系呢？</h4><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口 <code>cwnd</code> 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li>
<li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li>
</ul>
<h4 id="6-9如何定义当前网络是否出现了拥塞？"><a href="#6-9如何定义当前网络是否出现了拥塞？" class="headerlink" title="6.9如何定义当前网络是否出现了拥塞？"></a>6.9如何定义当前网络是否出现了拥塞？</h4><p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<h4 id="6-10拥塞控制有哪些控制算法？"><a href="#6-10拥塞控制有哪些控制算法？" class="headerlink" title="6.10拥塞控制有哪些控制算法？"></a>6.10拥塞控制有哪些控制算法？</h4><ul>
<li><p>慢启动</p>
<p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710174424203.png" alt="image-20230710174424203" style="zoom:50%;">

<ul>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」。一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</li>
</ul>
</li>
<li><p>拥塞避免</p>
<p>拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
</li>
<li><p>拥塞发生</p>
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li><p>超时重传</p>
<p>当发生了「超时重传」，则就会使用拥塞发生算法。这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li>
</ul>
</li>
<li><p>快速重传</p>
<p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
</li>
</ul>
</li>
<li><p>快速恢复</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
</li>
</ul>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230710174726817.png" alt="image-20230710174726817" style="zoom:50%;">

<h3 id="7-如何优化-TCP？"><a href="#7-如何优化-TCP？" class="headerlink" title="7.如何优化 TCP？"></a>7.如何优化 TCP？</h3><p><strong>TCP三次握手性能优化：</strong></p>
<ul>
<li><p><strong>客户端的优化：</strong>当客户端发起 SYN 包时，可以通过 <code>tcp_syn_retries</code> 控制其重传的次数。</p>
</li>
<li><p><strong>服务端的优化：</strong></p>
<ul>
<li>当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以调整 SYN 半连接队列的大小。</li>
<li>把 <code>tcp_syncookies</code> 参数设置为 1，表示在 SYN 队列满后开启 syncookie 功能，保证正常的连接成功建立。</li>
<li>把 <code>tcp_abort_on_overflow</code> 设置为 1 ，当全连接队列满了之后用 RST 通知客户端连接建立失败。</li>
<li>如果 accpet 队列溢出严重，可以提高队列的大小。</li>
</ul>
<p>附录：调整的参数表</p>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230711135806652.png" alt="image-20230711135806652" style="zoom:50%;">
</li>
<li><p><strong>绕过三次握手</strong>：TCP Fast Open 功能可以绕过三次握手，使得 HTTP 请求减少了 1 个 RTT 的时间，Linux 下可以通过 <code>tcp_fastopen</code> 开启该功能，同时必须保证服务端和客户端同时支持。</p>
</li>
</ul>
<p><strong>TCP四次挥手性能优化：</strong></p>
<ul>
<li>减少重传次数</li>
<li>防止 TIME_WAIT 状态占用太多的资源，定义处于该状态的最大数量，超过数量则直接释放连接。</li>
<li>将 TIME_WAIT 状态的<strong>端口复用</strong>于作为客户端的新连接。</li>
</ul>
<h3 id="8-TCP-是面向字节流的协议，UDP-是面向报文的协议？"><a href="#8-TCP-是面向字节流的协议，UDP-是面向报文的协议？" class="headerlink" title="8.TCP 是面向字节流的协议，UDP 是面向报文的协议？"></a>8.TCP 是面向字节流的协议，UDP 是面向报文的协议？</h3><p>这是因为操作系统对 TCP 和 UDP 协议的<strong>发送方的机制不同</strong>。</p>
<ul>
<li>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。</li>
<li>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。</li>
</ul>
<p>如何解决TCP粘包问题？</p>
<p>一般有三种方式分包的方式：</p>
<ul>
<li>固定长度的消息；</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构。</li>
</ul>
<h4 id="9-为什么-TCP-每次建立连接时，初始化序列号都要不一样呢？"><a href="#9-为什么-TCP-每次建立连接时，初始化序列号都要不一样呢？" class="headerlink" title="9.为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？"></a>9.为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？</h4><p>主要原因是为了防止历史报文被下一个相同四元组的连接接收。</p>
<p><strong>追问：可以完全避免吗？</strong></p>
<p>不可以，因为<strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况</strong>。</p>
<p><strong>追问：那么如何解决这个问题？</strong></p>
<p>引入时间戳，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p>
<p><strong>追问：如果时间戳也回绕了怎么办？</strong></p>
<p>这种情况发生的可能性比较小，但是也不能完全排除。那么可以采用增大时间戳的方法来解决。</p>
<h3 id="10-SYN-报文什么时候情况下会被丢弃？"><a href="#10-SYN-报文什么时候情况下会被丢弃？" class="headerlink" title="10.SYN 报文什么时候情况下会被丢弃？"></a>10.SYN 报文什么时候情况下会被丢弃？</h3><p>TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃</p>
<ul>
<li>在未开启 <strong>syncookies</strong> 时，当半连接队列满了，就会造成 SYN 报文丢失。</li>
<li><strong>accpet 队列满了 ，后续的连接就会被丢弃</strong></li>
</ul>
<h3 id="11-如何断开一个TCP连接？"><a href="#11-如何断开一个TCP连接？" class="headerlink" title="11.如何断开一个TCP连接？"></a>11.如何断开一个TCP连接？</h3><p>最简单的方法就是杀掉进程。</p>
<p><strong>追问：有什么坏处？</strong></p>
<ul>
<li>在客户端杀掉进程的话，就会发送 FIN 报文，来断开这个客户端进程与服务端建立的所有 TCP 连接，这种方式影响范围只有这个客户端进程所建立的连接，而其他客户端或进程不会受影响。</li>
<li>而在服务端杀掉进程影响就大了，此时所有的 TCP 连接都会被关闭，服务端无法继续提供访问服务。</li>
</ul>
<p><strong>那还有其他办法吗？</strong></p>
<p>killcx：</p>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/95592346a9a747819cd27741a660213c.png" alt="img" style="zoom:50%;">

<ul>
<li>用 Challenge ACK 里的确认号伪造 RST 报文发送给服务端，服务端收到 RST 报文后就会释放连接。</li>
<li>用 Challenge ACK 里的序列号伪造 RST 报文发送给客户端，客户端收到 RST 也会释放连接。</li>
</ul>
<p>tcpkill：</p>
<ul>
<li>tcpkill 工具是在双方进行 TCP 通信时，拿到对方下一次期望收到的序列号，然后将序列号填充到伪造的 RST 报文，并将其发送给对方，达到关闭 TCP 连接的效果。（不适用于不活跃的TCP连接）</li>
<li>killcx 工具是主动发送一个 SYN 报文，对方收到后会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK，这时就可以拿到对方下一次期望收到的序列号，然后将序列号填充到伪造的 RST 报文，并将其发送给对方，达到关闭 TCP 连接的效果。</li>
</ul>
<h3 id="12-在-TCP-正常挥手过程中，处于-TIME-WAIT-状态的连接，收到相同四元组的-SYN-后会发生什么？"><a href="#12-在-TCP-正常挥手过程中，处于-TIME-WAIT-状态的连接，收到相同四元组的-SYN-后会发生什么？" class="headerlink" title="12.在 TCP 正常挥手过程中，处于 TIME_WAIT 状态的连接，收到相同四元组的 SYN 后会发生什么？"></a>12.在 TCP 正常挥手过程中，处于 TIME_WAIT 状态的连接，收到相同四元组的 SYN 后会发生什么？</h3><ul>
<li>如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong>SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。那么就会重用该四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。</li>
<li>如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong>SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。那么就会<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号，就回 RST 报文给服务端</strong>。</li>
</ul>
<p><strong>在 TIME_WAIT 状态，收到 RST 会断开连接吗？</strong></p>
<ul>
<li>如果 <code>net.ipv4.tcp_rfc1337</code> 参数为 0，则提前结束 TIME_WAIT 状态，释放连接。</li>
<li>如果 <code>net.ipv4.tcp_rfc1337</code> 参数为 1，则会丢掉该 RST 报文。</li>
</ul>
<h3 id="13-HTTP的Keep-Alive和TCP的Keepalive的区别"><a href="#13-HTTP的Keep-Alive和TCP的Keepalive的区别" class="headerlink" title="13.HTTP的Keep-Alive和TCP的Keepalive的区别"></a>13.HTTP的Keep-Alive和TCP的Keepalive的区别</h3><ul>
<li>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</li>
<li>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</li>
</ul>
<h3 id="14-目前TCP协议存在哪些缺陷"><a href="#14-目前TCP协议存在哪些缺陷" class="headerlink" title="14.目前TCP协议存在哪些缺陷?"></a>14.目前TCP协议存在哪些缺陷?</h3><ul>
<li>升级 TCP 的工作很困难；</li>
<li>TCP 建立连接的延迟；</li>
<li>TCP 存在队头阻塞问题；</li>
<li>网络迁移需要重新建立 TCP 连接；</li>
</ul>
<h3 id="15-建立TCP连接的几种情况"><a href="#15-建立TCP连接的几种情况" class="headerlink" title="15.建立TCP连接的几种情况"></a>15.建立TCP连接的几种情况</h3><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/3.jpg" alt="半连接队列与全连接队列" style="zoom:50%;">

<h4 id="15-1不使用-listen-，可以建立-TCP-连接吗？"><a href="#15-1不使用-listen-，可以建立-TCP-连接吗？" class="headerlink" title="15.1不使用 listen ，可以建立 TCP 连接吗？"></a>15.1不使用 listen ，可以建立 TCP 连接吗？</h4><p>是可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。</p>
<h4 id="15-2那没有listen，还有半连接队列吗？为什么还能建立连接？"><a href="#15-2那没有listen，还有半连接队列吗？为什么还能建立连接？" class="headerlink" title="15.2那没有listen，还有半连接队列吗？为什么还能建立连接？"></a>15.2那没有listen，还有半连接队列吗？为什么还能建立连接？</h4><ul>
<li>显然没有，因为客户端没有执行listen，因为半连接队列和全连接队列都是在执行 listen 方法时，内核自动创建的。</li>
<li>我们知道执行 listen 方法时，会创建半连接队列和全连接队列。三次握手的过程中会在这两个队列中暂存连接信息。所以形成连接，前提是你得有个地方存放着，方便握手的时候能根据 IP + 端口等信息找到对应的 socket。但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。</li>
</ul>
<h4 id="15-3没有-accept，能建立-TCP-连接吗？"><a href="#15-3没有-accept，能建立-TCP-连接吗？" class="headerlink" title="15.3没有 accept，能建立 TCP 连接吗？"></a>15.3没有 accept，能建立 TCP 连接吗？</h4><ul>
<li><strong>每一个</strong><code>socket</code>执行<code>listen</code>时，内核都会自动创建一个半连接队列和全连接队列。</li>
<li>第三次握手前，TCP连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。</li>
<li><code>accept方法</code>只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎<strong>毫无关系</strong>。</li>
<li>出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了<strong>哈希表</strong>，而全连接队列本质是链表。</li>
<li>全连接队列满了，再来第三次握手也会丢弃，此时如果<code>tcp_abort_on_overflow=1</code>，还会直接发<code>RST</code>给客户端。</li>
<li>半连接队列满了，可能是因为受到了<code>SYN Flood</code>攻击，可以设置<code>tcp_syncookies</code>，绕开半连接队列。</li>
<li>客户端没有半连接队列和全连接队列，但有一个<strong>全局hash</strong>，可以通过它实现自连接或TCP同时打开。</li>
</ul>
<h3 id="16-用了-TCP-协议，数据一定不会丢吗？"><a href="#16-用了-TCP-协议，数据一定不会丢吗？" class="headerlink" title="16.用了 TCP 协议，数据一定不会丢吗？"></a>16.用了 TCP 协议，数据一定不会丢吗？</h3><ul>
<li>数据从发送端到接收端，链路很长，任何一个地方都可能发生丢包，几乎可以说丢包不可避免。</li>
<li>平时没事也不用关注丢包，大部分时候TCP的重传机制保证了消息可靠性。</li>
<li>当你发现服务异常的时候，比如接口延时很高，总是失败的时候，可以用ping或者mtr命令看下是不是中间链路发生了丢包。</li>
<li>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</li>
</ul>
<h3 id="17-TCP-四次挥手中，能不能把第二次的-ACK-报文，-放到第三次-FIN-报文一起发送？"><a href="#17-TCP-四次挥手中，能不能把第二次的-ACK-报文，-放到第三次-FIN-报文一起发送？" class="headerlink" title="17.TCP 四次挥手中，能不能把第二次的 ACK 报文， 放到第三次 FIN 报文一起发送？"></a>17.TCP 四次挥手中，能不能把第二次的 ACK 报文， 放到第三次 FIN 报文一起发送？</h3><p><strong>结论：在一些情况下， TCP 四次挥手是可以变成 TCP 三次挥手的</strong>。</p>
<p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，<strong>但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</strong>：</p>
<ul>
<li>如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；</li>
<li>如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</li>
</ul>
<p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
<h4 id="追问：什么是-TCP-延迟确认机制？"><a href="#追问：什么是-TCP-延迟确认机制？" class="headerlink" title="追问：什么是 TCP 延迟确认机制？"></a>追问：什么是 TCP 延迟确认机制？</h4><p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li>
<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>
<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li>
</ul>
<h3 id="18-TCP-序列号和确认号是如何变化的？"><a href="#18-TCP-序列号和确认号是如何变化的？" class="headerlink" title="18.TCP 序列号和确认号是如何变化的？"></a>18.TCP 序列号和确认号是如何变化的？</h3><p><strong>发送的 TCP 报文：</strong></p>
<ul>
<li><strong>公式一：序列号 &#x3D; 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></li>
<li><strong>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></li>
</ul>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/ae18cbf6071c47b98014a68d05c37d16.png" alt="在这里插入图片描述" style="zoom:67%;">

<h3 id="19-如何基于UDP协议实现可靠传输？"><a href="#19-如何基于UDP协议实现可靠传输？" class="headerlink" title="19.如何基于UDP协议实现可靠传输？"></a>19.如何基于UDP协议实现可靠传输？</h3><p><strong>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</strong>，摆脱了TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题。</p>
<ol>
<li><p>Packet Number 单调递增，有两个好处：</p>
<ul>
<li><p>可以更加精确计算 RTT，没有 TCP 重传的歧义性问题；</p>
</li>
<li><p>可以支持乱序确认，因为丢包重传将当前窗口阻塞在原地，而 TCP 必须是顺序确认的，丢包时会导致窗口不滑动；</p>
</li>
</ul>
</li>
</ol>
<h4 id="19-1QUIC-是如何解决-TCP-队头阻塞问题的？"><a href="#19-1QUIC-是如何解决-TCP-队头阻塞问题的？" class="headerlink" title="19.1QUIC 是如何解决 TCP 队头阻塞问题的？"></a>19.1QUIC 是如何解决 TCP 队头阻塞问题的？</h4><p><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p>
<h4 id="19-2QUIC-是如何做流量控制的？"><a href="#19-2QUIC-是如何做流量控制的？" class="headerlink" title="19.2QUIC 是如何做流量控制的？"></a>19.2QUIC 是如何做流量控制的？</h4><p>QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：</p>
<ul>
<li><strong>Stream 级别的流量控制</strong>：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</li>
<li><strong>Connection 流量控制</strong>：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</li>
</ul>
<h4 id="19-3QUIC对拥塞控制的改进？"><a href="#19-3QUIC对拥塞控制的改进？" class="headerlink" title="19.3QUIC对拥塞控制的改进？"></a>19.3QUIC对拥塞控制的改进？</h4><p>QUIC 协议当前默认使用了 TCP 的 Cubic 拥塞控制算法（我们熟知的慢开始、拥塞避免、快重传、快恢复策略），同时也支持 CubicBytes、Reno、RenoBytes、BBR、PCC 等拥塞控制算法，相当于将 TCP 的拥塞控制算法照搬过来了。</p>
<p>QUIC 是如何改进 TCP 的拥塞控制算法的呢？</p>
<p>QUIC 是处于应用层的，应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，所以 TCP 拥塞控制算法迭代速度是很慢的。而 <strong>QUIC 可以随浏览器更新，QUIC 的拥塞控制算法就可以有较快的迭代速度</strong>。</p>
<p>TCP 更改拥塞控制算法是对系统中所有应用都生效，无法根据不同应用设定不同的拥塞控制策略。但是因为 QUIC 处于应用层，所以就<strong>可以针对不同的应用设置不同的拥塞控制算法</strong>，这样灵活性就很高了。</p>
<h4 id="19-4QUIC的连接迁移？"><a href="#19-4QUIC的连接迁移？" class="headerlink" title="19.4QUIC的连接迁移？"></a>19.4QUIC的连接迁移？</h4><p>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/4cad213f5125432693e0e2a512c2d1a1.png" alt="img" style="zoom:50%;">

<p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
<hr>
<h2 id="IP篇"><a href="#IP篇" class="headerlink" title="IP篇"></a>IP篇</h2><h3 id="1-网络层（IP）与数据链路层（MAC）有什么关系呢？"><a href="#1-网络层（IP）与数据链路层（MAC）有什么关系呢？" class="headerlink" title="1.网络层（IP）与数据链路层（MAC）有什么关系呢？"></a>1.网络层（IP）与数据链路层（MAC）有什么关系呢？</h3><p> IP 的作用是主机之间通信用的，而 <strong>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</strong></p>
<p>在传输过程中<strong>源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。</strong></p>
<p><strong>一个小问题：现在不仅电脑配了 IP 地址， 手机、IPad 等电子设备都配了 IP 呀，照理来说肯定会超过 43 亿啦，那是怎么能够支持这么多 IP 的呢？</strong></p>
<p>因为会根据一种可以更换 IP 地址的技术 <code>NAT</code>，使得可连接计算机数超过 43 亿台。</p>
<h3 id="2-IP地址基础知识"><a href="#2-IP地址基础知识" class="headerlink" title="2.IP地址基础知识"></a>2.IP地址基础知识</h3><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/image-20230712135256746.png" alt="image-20230712135256746" style="zoom:50%;">

<h4 id="2-1如何计算最大主机数？"><a href="#2-1如何计算最大主机数？" class="headerlink" title="2.1如何计算最大主机数？"></a>2.1如何计算最大主机数？</h4><p>最大主机个数，就是要看主机号的位数，如 C 类地址的主机号占 8 位，那么 C 类地址的最大主机个数：</p>
<p><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/9.jpg" alt="img"></p>
<p><strong>为什么要减 2 呢？</strong></p>
<p>因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。</p>
<ul>
<li>主机号全为 1 指定某个网络下的所有主机，用于广播</li>
<li>主机号全为 0 指定某个网络</li>
</ul>
<h4 id="2-2广播地址用于什么？"><a href="#2-2广播地址用于什么？" class="headerlink" title="2.2广播地址用于什么？"></a>2.2广播地址用于什么？</h4><p>广播地址用于在<strong>同一个链路中相互连接的主机之间发送数据包</strong>。广播地址可以分为本地广播和直接广播两种。</p>
<ul>
<li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0&#x2F;24 以外的其他链路上。</li>
<li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的主机向 192.168.1.255&#x2F;24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0&#x2F;24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。） 。</li>
</ul>
<h4 id="2-3什么是-D、E-类地址？"><a href="#2-3什么是-D、E-类地址？" class="headerlink" title="2.3什么是 D、E 类地址？"></a>2.3什么是 D、E 类地址？</h4><p>D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于<strong>多播</strong>，E 类是预留的分类，暂时未使用。</p>
<h4 id="2-4多播地址用于什么？"><a href="#2-4多播地址用于什么？" class="headerlink" title="2.4多播地址用于什么？"></a>2.4多播地址用于什么？</h4><p>多播用于<strong>将包发送给特定组内的所有主机。</strong></p>
<h4 id="2-5IP-分类的优点和缺点"><a href="#2-5IP-分类的优点和缺点" class="headerlink" title="2.5IP 分类的优点和缺点"></a>2.5IP 分类的优点和缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>通过IP分类，可以很快找到网络地址和主机地址。</li>
</ul>
<p><strong>缺点：</strong></p>
<ol>
<li><p><strong>同一网络下没有地址层次</strong>，比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就<strong>缺少地址的灵活性</strong>。</p>
</li>
<li><p>A、B、C类有个尴尬处境，就是<strong>不能很好的与现实网络匹配</strong>。</p>
<ul>
<li><p>C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用。</p>
</li>
<li><p>而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</p>
</li>
</ul>
</li>
</ol>
<p>这两个缺点，都可以在 <code>CIDR</code> 无分类地址解决。</p>
<h4 id="2-6什么是无分类地址-CIDR？"><a href="#2-6什么是无分类地址-CIDR？" class="headerlink" title="2.6什么是无分类地址 CIDR？"></a>2.6什么是无分类地址 CIDR？</h4><p>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x 位属于<strong>网络号</strong>， x 的范围是 <code>0 ~ 32</code>，这就使得 IP 地址更加具有灵活性。</p>
<h4 id="2-7为什么要分离网络号和主机号？"><a href="#2-7为什么要分离网络号和主机号？" class="headerlink" title="2.7为什么要分离网络号和主机号？"></a>2.7为什么要分离网络号和主机号？</h4><p>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p>
<h4 id="2-9环回地址是不会流向网络"><a href="#2-9环回地址是不会流向网络" class="headerlink" title="2.9环回地址是不会流向网络"></a>2.9环回地址是不会流向网络</h4><ul>
<li>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。</li>
<li>计算机使用一个特殊的 IP 地址 <strong>127.0.0.1 作为环回地址</strong>。与该地址具有相同意义的是一个叫做 <code>localhost</code> 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。</li>
</ul>
<h3 id="3-IPv6"><a href="#3-IPv6" class="headerlink" title="3. IPv6"></a>3. IPv6</h3><h4 id="3-1IPv6-的亮点"><a href="#3-1IPv6-的亮点" class="headerlink" title="3.1IPv6 的亮点"></a>3.1IPv6 的亮点</h4><ul>
<li>IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址，真是<strong>便捷到即插即用</strong>啊。</li>
<li>IPv6 包头包首部长度采用固定的值 <code>40</code> 字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大<strong>提高了传输的性能</strong>。</li>
<li>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大<strong>提升了安全性</strong>。</li>
</ul>
<h3 id="4-一些协议"><a href="#4-一些协议" class="headerlink" title="4.一些协议"></a>4.一些协议</h3><h4 id="4-1DNS"><a href="#4-1DNS" class="headerlink" title="4.1DNS"></a>4.1DNS</h4><h4 id="4-2APR"><a href="#4-2APR" class="headerlink" title="4.2APR"></a>4.2APR</h4><p>上述两个协议看之前的笔记</p>
<p><strong>补充RAPR：</strong>APR是根据IP地址找MAC地址；RAPR是根据MAC地址找IP地址。</p>
<h4 id="4-3DHCP"><a href="#4-3DHCP" class="headerlink" title="4.3DHCP"></a>4.3DHCP</h4><p>通过 DHCP 动态获取 IP 地址。</p>
<h4 id="4-4NAT"><a href="#4-4NAT" class="headerlink" title="4.4NAT"></a>4.4NAT</h4><p><strong>网络地址转换</strong>方法，将私有IP转换为公有IP。</p>
<p>缺点：</p>
<ul>
<li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li>
<li>转换表的生成与转换操作都会产生性能开销。</li>
<li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li>
</ul>
<p>解决：</p>
<ul>
<li>第一种就是改用 IPv6</li>
<li>NAT穿透技术：就是客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT 设备来进行转换了。</li>
</ul>
<h4 id="4-5ICMP"><a href="#4-5ICMP" class="headerlink" title="4.5ICMP"></a>4.5ICMP</h4><p><strong>互联网控制报文协议</strong>。在网络包遇到各种问题时，传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。</p>
<h5 id="4-5-1ICMP-功能都有啥？"><a href="#4-5-1ICMP-功能都有啥？" class="headerlink" title="4.5.1ICMP 功能都有啥？"></a>4.5.1ICMP 功能都有啥？</h5><p><strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p>
<h5 id="4-5-2ICMP类型"><a href="#4-5-2ICMP类型" class="headerlink" title="4.5.2ICMP类型"></a>4.5.2ICMP类型</h5><p>ICMP 大致可以分为两大类：</p>
<ul>
<li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li>
<li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li>
</ul>
<img src="/2023/07/12/%E8%AE%A1%E7%BD%91/41.jpg" alt="常见的 ICMP 类型" style="zoom:50%;">

<h4 id="4-6IGMP"><a href="#4-6IGMP" class="headerlink" title="4.6IGMP"></a>4.6IGMP</h4><p>在前面我们知道了组播地址，也就是 D 类地址，既然是组播，那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要 <code>IGMP</code> 协议了。</p>
<h3 id="5-ping的工作原理"><a href="#5-ping的工作原理" class="headerlink" title="5.ping的工作原理"></a>5.ping的工作原理</h3><ol>
<li><p>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包。ICMP 数据包内包含多个字段，最重要的是两个：</p>
<ul>
<li><p>第一个是<strong>类型</strong>，对于回送请求消息而言该字段为 <code>8</code>；</p>
</li>
<li><p>另外一个是<strong>序号</strong>，主要用于区分连续 ping 的时候发出的多个数据包。</p>
</li>
</ul>
</li>
<li><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为<strong>目的地址</strong>，本机 IP 地址作为<strong>源地址</strong>，<strong>协议</strong>字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，再加上一些其他控制信息，构建一个 <code>IP</code> 数据包。</p>
</li>
<li><p>接下来，需要加入 <code>MAC</code> 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 <code>ARP</code> 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p>
</li>
<li><p>主机 <code>B</code> 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。</p>
</li>
<li><p>接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p>
</li>
<li><p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去给主机 A。</p>
</li>
<li><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</p>
</li>
<li><p>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p>
</li>
</ol>
<p><img src="/2023/07/12/%E8%AE%A1%E7%BD%91/17.png" alt="主机 A ping 主机 B 期间发送的事情"></p>
<h4 id="追问：断网了，还能-ping-通-127-0-0-1-吗？"><a href="#追问：断网了，还能-ping-通-127-0-0-1-吗？" class="headerlink" title="追问：断网了，还能 ping 通 127.0.0.1 吗？"></a>追问：断网了，还能 ping 通 127.0.0.1 吗？</h4><p>答案是可以的。<code>ping</code> 本机地址的时候，走的是<strong>本地回环接口，即”假网卡”<strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前</strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</p>
<h4 id="追问：TCP发数据和Ping差别大吗？"><a href="#追问：TCP发数据和Ping差别大吗？" class="headerlink" title="追问：TCP发数据和Ping差别大吗？"></a>追问：TCP发数据和Ping差别大吗？</h4><p>差别不大。程序基本一样。可以把Ping看做是自己组建了一个数据包进行发送。</p>
<h4 id="追问：ping回环地址和ping本机地址有什么区别？"><a href="#追问：ping回环地址和ping本机地址有什么区别？" class="headerlink" title="追问：ping回环地址和ping本机地址有什么区别？"></a>追问：ping回环地址和ping本机地址有什么区别？</h4><p> ping 本机IP 跟 ping 回环地址一样，相关的网络数据，都是走的本地回环接口，只要走了本地回环接口，那数据都不会发送到网络中，在本机网络协议栈中兜一圈，就发回来了。因此 <strong>ping回环地址和ping本机地址没有区别</strong>。</p>
<h4 id="追问：127-0-0-1-和-localhost-有区别吗"><a href="#追问：127-0-0-1-和-localhost-有区别吗" class="headerlink" title="追问：127.0.0.1 和 localhost 有区别吗"></a>追问：127.0.0.1 和 localhost 有区别吗</h4><ul>
<li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</li>
</ul>
<h3 id="6-traceroute-——-差错报文类型的使用"><a href="#6-traceroute-——-差错报文类型的使用" class="headerlink" title="6.traceroute —— 差错报文类型的使用"></a>6.traceroute —— 差错报文类型的使用</h3><p>有一款充分利用 ICMP <strong>差错报文类型</strong>的应用叫做 <code>traceroute</code>（在UNIX、MacOS中是这个命令，而在Windows中对等的命令叫做 tracert ）。</p>
<p><strong>作用：</strong></p>
<ul>
<li><p>第一个作用就是<strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</strong></p>
<ul>
<li><p>作用如何实现？</p>
<p>它的原理就是利用 IP 包的<strong>生存期限</strong> 从 <code>1</code> 开始按照顺序递增的同时发送 <strong>UDP 包</strong>，强制接收 <strong>ICMP 超时消息</strong>的一种方法。</p>
<p>比如，将 TTL 设置 为 <code>1</code>，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是<strong>时间超时</strong>。</p>
<p>接下来将 TTL 设置为 <code>2</code>，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。</p>
<p>这样的过程，traceroute 就可以拿到了所有的路由器 IP。</p>
</li>
<li><p>发送方如何知道发出的 UDP 包是否到达了目的主机呢？</p>
<p>traceroute 在发送 <code>UDP</code> 包时，会填入一个<strong>不可能的端口号</strong>值作为 UDP 目标端口号：33434。然后对于每个下一个探针，它都会增加一个，这些端口都是通常认为不会被使用，不过，没有人知道当某些应用程序监听此类端口时会发生什么。</p>
<p>当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型是「<strong>端口不可达</strong>」。</p>
<p>所以，<strong>当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。</strong></p>
</li>
</ul>
</li>
<li><p>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。</p>
<ul>
<li><p>这样做的目的：</p>
<p>这样做的目的是为了<strong>路径MTU发现</strong>。</p>
<p>因为有的时候我们并不知道路由器的 <code>MTU</code> 大小，以太网的数据链路上的 <code>MTU</code> 通常是 <code>1500</code> 字节，但是非以太网的 <code>MTU</code> 值就不一样了，所以我们要知道 <code>MTU</code> 的大小，从而控制发送的包大小。</p>
</li>
<li><p>原理：</p>
<p>首先在发送端主机发送 <code>IP</code> 数据报时，将 <code>IP</code> 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</p>
<p>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</p>
<p>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 <code>MTU</code> 值，以便能到达目标主机。</p>
</li>
</ul>
</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>计算机基础——计算机网络</p><p><a href="https://spy955.github.io/2023/07/12/计网/">https://spy955.github.io/2023/07/12/计网/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Sun Peiyuan</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-07-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-07-23</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Computer-Basics/">Computer Basics</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/08/16/Data-Structure/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">数据结构</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/07/07/Lottery-API/"><span class="level-item">Lottery-API</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://spy955.github.io/2023/07/12/%E8%AE%A1%E7%BD%91/';
            this.page.identifier = '2023/07/12/计网/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'SPY' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/hutao.jpg" alt="SPY"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SPY</p><p class="is-size-6 is-block">一个热爱并追求技术的小白</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Spy955" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Spy955"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-29T01:31:58.000Z">2023-08-29</time></p><p class="title"><a href="/2023/08/29/Java%E5%85%AB%E8%82%A1%E4%B9%8BSSM/">深入理解 Java 原理之SSM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-28T01:20:05.000Z">2023-08-28</time></p><p class="title"><a href="/2023/08/28/Java%E5%85%AB%E8%82%A1%E4%B9%8BJVM/">深入理解 Java 原理之 JVM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-26T08:28:56.000Z">2023-08-26</time></p><p class="title"><a href="/2023/08/26/Java%E5%85%AB%E8%82%A1%E4%B9%8B%E9%9B%86%E5%90%88/">深入 Java 原理之集合篇</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-24T09:40:47.000Z">2023-08-24</time></p><p class="title"><a href="/2023/08/24/JavaSE/">深入学习 Java 原理之基础篇</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-16T06:11:29.000Z">2023-08-16</time></p><p class="title"><a href="/2023/08/16/Data-Structure/">数据结构</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Computer-Basics/"><span class="tag">Computer Basics</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Data-Structure/"><span class="tag">Data Structure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Interview-preparation/"><span class="tag">Interview preparation</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java-Project/"><span class="tag">Java_Project</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web/"><span class="tag">Web</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.png" alt="SPY 的博客" height="28"></a><p class="is-size-7"><span>&copy; 2023 Sun Peiyuan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Spy955"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>