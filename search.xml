<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>瑞吉外卖项目优化</title>
    <url>/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="瑞吉外卖项目优化"><a href="#瑞吉外卖项目优化" class="headerlink" title="瑞吉外卖项目优化"></a>瑞吉外卖项目优化</h1><h2 id="一、缓存优化"><a href="#一、缓存优化" class="headerlink" title="一、缓存优化"></a>一、缓存优化</h2><h3 id="1-1存在的问题"><a href="#1-1存在的问题" class="headerlink" title="1.1存在的问题"></a>1.1存在的问题</h3><p>在客户端点击某一个菜品分类，都会去数据库进行查找，导致系统性能下降，用户端速度变慢</p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230217125119369.png" alt="image-20230217125119369"></p>
<h3 id="1-2环境搭建"><a href="#1-2环境搭建" class="headerlink" title="1.2环境搭建"></a>1.2环境搭建</h3><h4 id="1-2-1maven坐标"><a href="#1-2-1maven坐标" class="headerlink" title="1.2.1maven坐标"></a>1.2.1maven坐标</h4><p>在项目的pom.xml文件中导入<code>spring data redis</code> 的maven坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2配置文件"><a href="#1-2-2配置文件" class="headerlink" title="1.2.2配置文件"></a>1.2.2配置文件</h4><p>在<code>application.yml</code>文件中，加入下述配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>	</span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">        <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意有密码的话需要将密码也进行配置</li>
</ul>
<h4 id="1-2-3配置类"><a href="#1-2-3配置类" class="headerlink" title="1.2.3配置类"></a>1.2.3配置类</h4><p>即在学习<code>Redis</code>的时候的配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()); <span class="comment">// key序列化</span></span><br><span class="line">        <span class="comment">//redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); // value序列化</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3缓存短信验证码"><a href="#1-3缓存短信验证码" class="headerlink" title="1.3缓存短信验证码"></a>1.3缓存短信验证码</h3><h4 id="1-3-1实现思路"><a href="#1-3-1实现思路" class="headerlink" title="1.3.1实现思路"></a>1.3.1实现思路</h4><p>前面我们已经实现了移动端手机验证码登录，随机生成的验证码我们是保存在<code>HttpSession</code>中的。</p>
<p>现在需要改造为将验证码缓存在<code>Redis</code>中，具体的实现思路如下:</p>
<ol>
<li>在服务端<code>UserController</code>中注入<code>RedisTemplate</code>对象，用于操作<code>Redis</code></li>
<li>在服务端<code>UserController</code>的<code>sendMsg</code>方法中，将随机生成的验证码缓存到<code>Redis</code>中，并设置有效期为5分钟</li>
<li>在服务端<code>UserController</code>的<code>login</code>方法中，从<code>Redis</code>中获取缓存的验证码，如果登录成功则删除<code>Redis</code>中的验证码</li>
</ol>
<h4 id="1-3-2代码改造"><a href="#1-3-2代码改造" class="headerlink" title="1.3.2代码改造"></a>1.3.2代码改造</h4><p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230217144608252.png" alt="image-20230217144608252"></p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230217144624934.png" alt="image-20230217144624934"></p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230217144641167.png" alt="image-20230217144641167"></p>
<ul>
<li>修改上述三个位置即可</li>
</ul>
<h4 id="1-3-3功能测试"><a href="#1-3-3功能测试" class="headerlink" title="1.3.3功能测试"></a>1.3.3功能测试</h4><h3 id="1-4缓存菜品数据"><a href="#1-4缓存菜品数据" class="headerlink" title="1.4缓存菜品数据"></a>1.4缓存菜品数据</h3><h4 id="1-4-1实现思路"><a href="#1-4-1实现思路" class="headerlink" title="1.4.1实现思路"></a>1.4.1实现思路</h4><p>前面我们已经实现了移动端菜品查看功能，对应的服务端方法为<code>DishController</code>的<code>list</code>方法，此方法会根据前端提交的查询条件进行数据库查询操作。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长。现在需要对此方法进行缓存优化，提高系统的性能。具体的实现思路如下</p>
<ol>
<li>改造<code>DishController</code>的<code>list</code>方法，先从<code>Redis</code>中获取菜品数据，如果有则直接返回，无需查询数据库；如果没有则查询数据库，并将查询到的菜品数据放入<code>Redis</code></li>
<li>改造<code>DishController</code>的<code>save</code>和<code>update</code>方法，加入清理缓存的逻辑</li>
</ol>
<p><strong>注意事项：</strong></p>
<p>在使用缓存过程中，要注意保证数据库中的数据和缓存中的数据一致，如果数据库中的数据发生变化，需要及时清理缓存数据</p>
<h4 id="1-4-2代码改造"><a href="#1-4-2代码改造" class="headerlink" title="1.4.2代码改造"></a>1.4.2代码改造</h4><ul>
<li>上述第一步的代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;List&lt;DishDto&gt;&gt; <span class="title function_">list</span><span class="params">(Dish dish)</span> &#123;</span><br><span class="line">       List&lt;DishDto&gt; dishDtoList = <span class="literal">null</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + dish.getCategoryId() + <span class="string">&quot;_&quot;</span> + dish.getStatus();<span class="comment">//dish_id_1</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//先从redis中获取缓存数据</span></span><br><span class="line">       dishDtoList = (List&lt;DishDto&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果存在，直接返回，无需查询数据库</span></span><br><span class="line">       <span class="keyword">if</span> (dishDtoList != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> R.success(dishDtoList);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//构造查询条件对象</span></span><br><span class="line">       LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.eq(dish.getCategoryId() != <span class="literal">null</span>, Dish::getCategoryId, dish.getCategoryId());</span><br><span class="line">       <span class="comment">//添加条件，查询状态为1（启售）</span></span><br><span class="line">       queryWrapper.eq(Dish::getStatus, <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//添加排序条件</span></span><br><span class="line">       queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">       List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">       dishDtoList = list.stream().map((item) -&gt; &#123;</span><br><span class="line">           <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishDto</span>();</span><br><span class="line"></span><br><span class="line">           BeanUtils.copyProperties(item, dishDto);</span><br><span class="line"></span><br><span class="line">           <span class="type">Long</span> <span class="variable">categoryId</span> <span class="operator">=</span> item.getCategoryId();<span class="comment">//分类id</span></span><br><span class="line">           <span class="comment">//根据id查询分类对象</span></span><br><span class="line">           <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (category != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">categoryName</span> <span class="operator">=</span> category.getName();</span><br><span class="line">               dishDto.setCategoryName(categoryName);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//当前菜品的id</span></span><br><span class="line">           <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> item.getId();</span><br><span class="line">           LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">           lambdaQueryWrapper.eq(DishFlavor::getDishId, dishId);</span><br><span class="line">           <span class="comment">//select * from dish_flavor where dish_id = ?</span></span><br><span class="line">           List&lt;DishFlavor&gt; dishFlavorList = dishFlavorService.list(lambdaQueryWrapper);</span><br><span class="line">           dishDto.setFlavors(dishFlavorList);</span><br><span class="line">           <span class="keyword">return</span> dishDto;</span><br><span class="line">       &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果不存在，需要查询数据库，将查询到的菜品数据缓存到redis</span></span><br><span class="line">       redisTemplate.opsForValue().set(key,dishDtoList,<span class="number">60</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> R.success(dishDtoList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改菜品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dishDto</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> DishDto dishDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">    dishService.updateWithFlavor(dishDto);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理所有菜品的缓存数据</span></span><br><span class="line">    <span class="comment">//Set keys = redisTemplate.keys(&quot;dish_*&quot;);</span></span><br><span class="line">    <span class="comment">//redisTemplate.delete(keys);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清理某个分类的菜品缓存数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + dishDto.getCategoryId() + <span class="string">&quot;_1&quot;</span>;</span><br><span class="line">    redisTemplate.delete(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;修改菜品成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 增加菜品</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dishDto</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> DishDto dishDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">       dishService.saveWithFlavor(dishDto);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//清理所有菜品的缓存数据</span></span><br><span class="line">       <span class="comment">//Set keys = redisTemplate.keys(&quot;dish_*&quot;);</span></span><br><span class="line">       <span class="comment">//redisTemplate.delete(keys);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//清理某个分类的菜品缓存数据</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + dishDto.getCategoryId() + <span class="string">&quot;_1&quot;</span>;</span><br><span class="line">       redisTemplate.delete(key);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> R.success(<span class="string">&quot;新增菜品成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-3功能测试"><a href="#1-4-3功能测试" class="headerlink" title="1.4.3功能测试"></a>1.4.3功能测试</h4><h3 id="1-5Spring-Cache"><a href="#1-5Spring-Cache" class="headerlink" title="1.5Spring Cache"></a>1.5Spring Cache</h3><h4 id="1-5-1Spring-Cache介绍"><a href="#1-5-1Spring-Cache介绍" class="headerlink" title="1.5.1Spring Cache介绍"></a>1.5.1Spring Cache介绍</h4><p>Spring Cache是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。</p>
<p>Spring Cache提供了一层抽象，底层可以切换不同的cache实现。具体就是通过<code>CacheManager</code>接口来统一不同的缓存技术。</p>
<p><code>CacheManager</code>是Spring提供的各种缓存技术抽象接口。</p>
<p>针对不同的缓存技术需要实现不同的<code>CacheManager</code></p>
<table>
<thead>
<tr>
<th><code>CacheManager</code></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>EhCacheCacheManager</code></td>
<td>使用EhCache作为缓存技术</td>
</tr>
<tr>
<td><code>GuavaCacheManager</code></td>
<td>使用Google的GuavaCache作为缓存技术</td>
</tr>
<tr>
<td><code>RedisCacheManager</code></td>
<td>使用Redis作为缓存技术</td>
</tr>
</tbody></table>
<h4 id="1-5-2Spring-Cache常用注解"><a href="#1-5-2Spring-Cache常用注解" class="headerlink" title="1.5.2Spring Cache常用注解"></a>1.5.2Spring Cache常用注解</h4><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableCaching</code></td>
<td>开启缓存注解功能</td>
</tr>
<tr>
<td><code>@Cacheable</code></td>
<td>在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据若没有数据，调用方法并将方法返回值放到缓存中</td>
</tr>
<tr>
<td><code>@CachePut</code></td>
<td>将方法的返回值放到缓存中</td>
</tr>
<tr>
<td><code>@CacheEvict</code></td>
<td>将一条或多条数据从缓存中删除</td>
</tr>
</tbody></table>
<p>在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用<code>@EnableCaching</code>开启缓存支持即可。</p>
<p>例如，使用<code>Redis</code>作为缓存技术，只需要导入<code>Spring data Redis</code>的maven坐标即可。</p>
<h4 id="1-5-3Spring-Cache使用方式"><a href="#1-5-3Spring-Cache使用方式" class="headerlink" title="1.5.3Spring Cache使用方式"></a>1.5.3Spring Cache使用方式</h4><p>在Spring Boot项目中使用Spring Cache的操作步骤(使用redis缓存技术)</p>
<ol>
<li><p>导入maven坐标</p>
<p>​		spring-boot-starter-data-redis、spring-boot-starter-cache</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">1800000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动类上加入<code>@EnableCaching</code>注解，开启缓存注解功能</p>
</li>
<li><p>在Controller的方法上加入<code>@Cacheable</code>、<code>@CacheEvict</code>等注解，进行缓存操作</p>
</li>
</ol>
<h3 id="1-6缓存套餐数据"><a href="#1-6缓存套餐数据" class="headerlink" title="1.6缓存套餐数据"></a>1.6缓存套餐数据</h3><h4 id="1-6-1实现思路"><a href="#1-6-1实现思路" class="headerlink" title="1.6.1实现思路"></a>1.6.1实现思路</h4><p>前面我们已经实现了移动端套餐查看功能，对应的服务端方法为<code>SetmealController</code>的<code>list</code>方法，此方法会根据前端提交的查询条件进行数据库查询操作。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长现在需要对此方法进行缓存优化，提高系统的性能。具体的实现思路如下:</p>
<ol>
<li>导入<code>Spring Cache</code>和<code>Redis</code>相关maven坐标</li>
<li>在<code>application.yml</code>中配置缓存数据的过期时间</li>
<li>在启动类上加入<code>@EnableCaching</code>注解，开启缓存注解功能</li>
<li>在<code>SetmealController</code>的<code>list</code>方法上加入<code>@Cacheable</code>注解</li>
<li>在<code>SetmealController</code>的<code>save</code>和<code>delete</code>方法上加入<code>CacheEvict</code>注解</li>
</ol>
<h4 id="1-6-2代码改造"><a href="#1-6-2代码改造" class="headerlink" title="1.6.2代码改造"></a>1.6.2代码改造</h4><ul>
<li>在<code>SetmealController</code>的<code>list</code>方法上加入<code>@Cacheable</code>注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;setmealCache&quot;, key = &quot;#setmeal.categoryId + &#x27;_&#x27; + #setmeal.status&quot;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在delete、save、setStatus方法上加入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;setmealCache&quot;,allEntries = true)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此时运行点击套餐会进行报错，原因是R这个通用类没有实现序列化，因此需要将R类后面加上继承序列化函数即可</li>
</ul>
<h4 id="1-6-3功能测试"><a href="#1-6-3功能测试" class="headerlink" title="1.6.3功能测试"></a>1.6.3功能测试</h4><h2 id="二、读写分离"><a href="#二、读写分离" class="headerlink" title="二、读写分离"></a>二、读写分离</h2><h3 id="2-1存在的问题"><a href="#2-1存在的问题" class="headerlink" title="2.1存在的问题"></a>2.1存在的问题</h3><p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230222163525183.png" alt="image-20230222163525183"></p>
<ul>
<li>单台数据库压力太大</li>
<li>单台数据库容易发生丢失现象</li>
</ul>
<p><strong>解决办法：</strong></p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230222163630003.png" alt="image-20230222163630003"></p>
<ul>
<li><code>Mysql</code>主从复制结构</li>
</ul>
<h3 id="2-2Mysql主从复制"><a href="#2-2Mysql主从复制" class="headerlink" title="2.2Mysql主从复制"></a>2.2Mysql主从复制</h3><h4 id="2-2-1介绍"><a href="#2-2-1介绍" class="headerlink" title="2.2.1介绍"></a>2.2.1介绍</h4><p>MySQL主从复制是一个异步的复制过程，底层是基于MySQL数据库自带的<strong>二进制日志功能</strong>。就是一台或多台MySQL数据库(slave，即<strong>从库</strong>)从另一台MySQL数据库(master，即<strong>主库</strong>)进行日志的复制然后再解析日志并应用到自身，最终实现从库的数据和主库的数据保持一致。MySQL主从复制是MySQL数据库自带功能，无需借助第三方工具.</p>
<p>MySQL复制过程分成三步:</p>
<ul>
<li>master将改变记录到二进制日志 (binary log)</li>
<li>slave将master的binary log拷贝到它的中继日志 (relay log)</li>
<li>slave重做中继日志中的事件，将改变应用到自己的数据库中</li>
</ul>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230222164758440.png" alt="image-20230222164758440"></p>
<ul>
<li>主库有一个，从库可以有多个</li>
</ul>
<h4 id="2-2-2配置"><a href="#2-2-2配置" class="headerlink" title="2.2.2配置"></a>2.2.2配置</h4><p><strong>前置条件</strong></p>
<p>提前准备好两台服务器，分别安装MySQL并且启动服务</p>
<ul>
<li>主库地址：192.168.133.100</li>
<li>从库地址：192.168.133.130</li>
</ul>
<h5 id="配置-主库"><a href="#配置-主库" class="headerlink" title="配置-主库"></a>配置-主库</h5><p>第一步：修改MySQL数据库的配置文件 &#x2F;etc&#x2F;my.cnf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin   #[必须]启用二进制日志</span><br><span class="line">server-id=100       #[必须]服务器唯一ID</span><br></pre></td></tr></table></figure>

<p>第二步：重启MySQL服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<p>第三步: 登录MySQL数据库，执行下面SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;xiaoming&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#也可以拆解为下面两步</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> xiaoming identified <span class="keyword">with</span> <span class="string">&#x27;mysql_native_password&#x27;</span> <span class="keyword">by</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> xiaoming;</span><br></pre></td></tr></table></figure>

<p>注:上面SQL的作用是创建一个用户xiaoming，密码为Root@123456，并目给xiaoming用户授REPLICATION SLAVE权限。常用于建立复制时所需要用到的用户权限，也就是slave必须被master授权具有该权限的用户，才能通过该用户复制。</p>
<p>第四步: 登录MySQL数据库，执行下面SQL，记录下结果中File和Position的值show master status:</p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230222202123267.png" alt="image-20230222202123267"></p>
<p>注:上面SQL的作用是查看Master的状态，执行完此SQL后不要再执行任何操作</p>
<h5 id="配置-从库"><a href="#配置-从库" class="headerlink" title="配置-从库"></a>配置-从库</h5><p>第一步：修改MySQL数据库配置文件 &#x2F;etc&#x2F;my.cnf，添加如下代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=130 #[必须]服务器唯一ID，和ip末尾一致即可</span><br></pre></td></tr></table></figure>

<p>第二步：重启MySQL服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<p>第三步:登录MySQL数据库，执行下面SQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;192.168.133.100&#x27;,master_user=&#x27;xiaoming&#x27;,master_password=&#x27;Root@123456&#x27;,master_log_file=&#x27;mysql-bin.000003&#x27;,master_log_pos=154;</span><br><span class="line"></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230222221956314.png" alt="image-20230222221956314"></p>
<p>第四步：登录MySQL数据库，执行下面的SQL，查看从数据库的状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230222222326535.png" alt="image-20230222222326535"></p>
<h4 id="2-2-3测试"><a href="#2-2-3测试" class="headerlink" title="2.2.3测试"></a>2.2.3测试</h4><p>在navicate中创建两个连接，如果无法连接，那么在两个服务器的mysql中分别运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;Root@123456&#x27; WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES</span><br></pre></td></tr></table></figure>

<p>然后再进行连接即可</p>
<ul>
<li>注意此时密码设置要含有大小写数字字符，或者改变默认密码规则</li>
</ul>
<p><strong>问题发现</strong></p>
<p>重启之后，两个数据库之间的关联可能已经消失，此时采取以下两个步骤将他们重新设置为主从关系</p>
<ul>
<li>Slave_IO_Running: No 的解决办法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#重启master库：service mysqld restart</span><br><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class="line">+------------------------+--------------+--------------+------------------+</span><br><span class="line">| mysql-bin.000534 |    63    |                  |                       | </span><br><span class="line">+------------------------+--------------+--------------+------------------+</span><br><span class="line">mysql&gt; stop slave;</span><br><span class="line">mysql&gt; change master to Master_Log_File=&#x27;mysql-bin.000534&#x27;,Master_Log_Pos=63;</span><br><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure>

<ul>
<li>Slave_SQL_Running: No</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave ;</span><br><span class="line">mysql&gt; set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;</span><br><span class="line">mysql&gt; start slave ;</span><br></pre></td></tr></table></figure>



<h3 id="2-3读写分离案例"><a href="#2-3读写分离案例" class="headerlink" title="2.3读写分离案例"></a>2.3读写分离案例</h3><h4 id="2-3-1背景"><a href="#2-3-1背景" class="headerlink" title="2.3.1背景"></a>2.3.1背景</h4><p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。对于同一时刻有<strong>大量并发读操作和较少写操作类型</strong>的应用系统来说，将数据库拆分为<strong>主库和从库</strong>，<strong>主库负责处理事务性的增删改操作，从库负责处理查询操作</strong>，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。</p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230223093930974.png" alt="image-20230223093930974"></p>
<h4 id="2-3-2Sharding-JDBC介绍"><a href="#2-3-2Sharding-JDBC介绍" class="headerlink" title="2.3.2Sharding-JDBC介绍"></a>2.3.2Sharding-JDBC介绍</h4><p>Sharding-JDBC定位为轻量级Java框架，在Java的]DBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p>
<p>使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离。</p>
<ul>
<li>适用于任何基于]DBC的ORM框架，如: JPA,Hibernate,Mybatis, Spring JDBC Template或直接使用JDBC。</li>
<li>支持任何第三方的数据库连接池，如: DBCP,C3P0,BoneCP,Druid,HikariCP等。</li>
<li>支持任意实现]DBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-3入门案例"><a href="#2-3-3入门案例" class="headerlink" title="2.3.3入门案例"></a>2.3.3入门案例</h4><p>使用Sharding-JDBC实现读写分离步骤：</p>
<ol>
<li>导入maven坐标</li>
<li>在配置文件中配置读写分离规则</li>
<li>在配置文件中配置<strong>允许bean定义覆盖</strong>配置项</li>
</ol>
<p>导入maven坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在配置文件中配置读写分离规则</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span></span><br><span class="line">        <span class="string">master,slave</span></span><br><span class="line">      <span class="comment"># 主数据源</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.138.100:3306/rw?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="comment"># 从数据源</span></span><br><span class="line">      <span class="attr">slave:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.138.101:3306/rw?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">masterslave:</span></span><br><span class="line">      <span class="comment"># 读写分离配置</span></span><br><span class="line">      <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span></span><br><span class="line">      <span class="comment"># 最终的数据源名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">      <span class="comment"># 主库数据源名称</span></span><br><span class="line">      <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 从库数据源名称列表，多个逗号分隔</span></span><br><span class="line">      <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-4功能测试"><a href="#2-3-4功能测试" class="headerlink" title="2.3.4功能测试"></a>2.3.4功能测试</h4><h3 id="2-4项目实现读写分离"><a href="#2-4项目实现读写分离" class="headerlink" title="2.4项目实现读写分离"></a>2.4项目实现读写分离</h3><h4 id="2-4-1数据库环境准备-主从复制"><a href="#2-4-1数据库环境准备-主从复制" class="headerlink" title="2.4.1数据库环境准备(主从复制)"></a>2.4.1数据库环境准备(主从复制)</h4><p>直接使用前面我们在虚拟中搭建的主从复制的数据库环境即可。</p>
<p>在主库中创建瑞吉外卖项目的业务数据库reggie并导入相关表结构和数据。</p>
<h4 id="2-4-2代码改造"><a href="#2-4-2代码改造" class="headerlink" title="2.4.2代码改造"></a>2.4.2代码改造</h4><p>使用Sharding-JDBC实现读写分离步骤：</p>
<ol>
<li>导入maven坐标</li>
<li>在配置文件中配置读写分离规则</li>
<li>在配置文件中配置<strong>允许bean定义覆盖</strong>配置项</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">#应用的名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">reggie_take_out</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span></span><br><span class="line">        <span class="string">master,slave</span></span><br><span class="line">      <span class="comment"># 主数据源</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.133.100:3306/reggie?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">Root@123456</span></span><br><span class="line">      <span class="comment"># 从数据源</span></span><br><span class="line">      <span class="attr">slave:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.133.130:3306/reggie?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">Root@123456</span></span><br><span class="line">    <span class="attr">masterslave:</span></span><br><span class="line">      <span class="comment"># 读写分离配置</span></span><br><span class="line">      <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span></span><br><span class="line">      <span class="comment"># 最终的数据源名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">      <span class="comment"># 主库数据源名称</span></span><br><span class="line">      <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 从库数据源名称列表，多个逗号分隔</span></span><br><span class="line">      <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-3功能测试"><a href="#2-4-3功能测试" class="headerlink" title="2.4.3功能测试"></a>2.4.3功能测试</h4><h2 id="三、前后端分离优化"><a href="#三、前后端分离优化" class="headerlink" title="三、前后端分离优化"></a>三、前后端分离优化</h2><h3 id="3-1存在的问题"><a href="#3-1存在的问题" class="headerlink" title="3.1存在的问题"></a>3.1存在的问题</h3><p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230223184036686.png" alt="image-20230223184036686"></p>
<ul>
<li>开发人员同时负责前端和后端代码开发，分工不明确</li>
<li>开发效率低</li>
<li>前后端混合在一个工程中，不便于管理</li>
<li>对开发人员要求高</li>
</ul>
<h3 id="3-2前后端分离开发"><a href="#3-2前后端分离开发" class="headerlink" title="3.2前后端分离开发"></a>3.2前后端分离开发</h3><h4 id="3-2-1介绍"><a href="#3-2-1介绍" class="headerlink" title="3.2.1介绍"></a>3.2.1介绍</h4><p><strong>前后端分离开发</strong>，就是在项目开发过程中，对于前端代码的开发由专门的前端开发人员负责，后端代码则由后端开发人员负责，这样可以做到分工明确、各司其职，提高开发效率，前后端代码并行开发，可以加快项目开发进度。目前，前后端分离开发方式已经被越来越多的公司所采用，成为当前项目开发的主流开发方式。</p>
<p>前后端分离开发后，从工程结构上也会发生变化，即前后端代码不再混合在同一个maven工程中，而是分为<strong>前端工程和后端工程</strong>。</p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230225121123734.png" alt="image-20230225121123734"></p>
<h4 id="3-2-2开发流程"><a href="#3-2-2开发流程" class="headerlink" title="3.2.2开发流程"></a>3.2.2开发流程</h4><p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230225121316114.png" alt="image-20230225121316114"></p>
<p>**接口(API接口)**就是一个http的请求地址，主要就是去定义:请求路径、请求方式、请求参数、响应数据等内容，</p>
<p><strong>举例：</strong></p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230225122309550.png" alt="image-20230225122309550"></p>
<h4 id="3-2-3前端技术栈"><a href="#3-2-3前端技术栈" class="headerlink" title="3.2.3前端技术栈"></a>3.2.3前端技术栈</h4><p><strong>开发工具</strong></p>
<ul>
<li>Visual Studio Code</li>
<li>hbuilder</li>
</ul>
<p><strong>技术框架</strong></p>
<ul>
<li>nodejs</li>
<li>VUE</li>
<li>ElementUI</li>
<li>mock</li>
<li>webpack</li>
</ul>
<h3 id="3-3Yapi"><a href="#3-3Yapi" class="headerlink" title="3.3Yapi"></a>3.3Yapi</h3><h4 id="3-3-1介绍"><a href="#3-3-1介绍" class="headerlink" title="3.3.1介绍"></a>3.3.1介绍</h4><p>YApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。</p>
<p>YApi让接口开发更简单高效，让接口的管理更具可读性、可维护性，让团队协作更合理。</p>
<p>源码地址: <a href="https://github.com/YMFE/yapi">https://github.com/YMFE/yapi</a></p>
<p>要使用YApi，需要自己进行部署</p>
<h4 id="3-3-2使用"><a href="#3-3-2使用" class="headerlink" title="3.3.2使用"></a>3.3.2使用</h4><p>使用YAPi，可以执行以下操作</p>
<ul>
<li>添加项目</li>
<li>添加分类</li>
<li>添加接口</li>
<li>编辑接口</li>
<li>查看接口</li>
</ul>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230225124742602.png" alt="image-20230225124742602"></p>
<h3 id="3-4Swagger"><a href="#3-4Swagger" class="headerlink" title="3.4Swagger"></a>3.4Swagger</h3><h4 id="3-4-1介绍"><a href="#3-4-1介绍" class="headerlink" title="3.4.1介绍"></a>3.4.1介绍</h4><p>使用Swagger你只需要按照它的规范去定义接口及接口相关的信息，再通过Swagger衍生出来的一系列项目和工具就可以做到生成各种格式的接口文档，以及在线接口调试页面等等。</p>
<p>官网: <a href="https://swagger.io/">https://swagger.io/</a></p>
<p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-2使用方式"><a href="#3-4-2使用方式" class="headerlink" title="3.4.2使用方式"></a>3.4.2使用方式</h4><p><strong>操作步骤</strong></p>
<ol>
<li>导入knife4j的maven坐标</li>
<li>导入knife4j相关配置类</li>
<li>设置静态资源，否则接口文档页面无法访问</li>
<li>在LoginCheckFilter中设置不需要处理的请求路径</li>
</ol>
<p><strong>导入knife4j的maven坐标</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>导入knife4j相关配置类（WebMvcConfig）</strong></p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230225130208979.png" alt="image-20230225130208979"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 文档类型</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">               .apiInfo(apiInfo())</span><br><span class="line">               .select()</span><br><span class="line">               .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.spy.reggie.controller&quot;</span>))</span><br><span class="line">               .paths(PathSelectors.any())</span><br><span class="line">               .build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">               .title(<span class="string">&quot;瑞吉外卖&quot;</span>)</span><br><span class="line">               .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">               .description(<span class="string">&quot;瑞吉外卖接口文档&quot;</span>)</span><br><span class="line">               .build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置静态资源</strong></p>
<p>在addResourceHandlers方法中加入以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.addResourceHandler(<span class="string">&quot;doc.html&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>在LoginCheckFilter中设置不需要处理的请求路径</strong></p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230225134139423.png" alt="image-20230225134139423"></p>
<h4 id="3-4-3常用注解"><a href="#3-4-3常用注解" class="headerlink" title="3.4.3常用注解"></a>3.4.3常用注解</h4><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Api</td>
<td>用在请求的类上，例如Controller，表示对类的说明</td>
</tr>
<tr>
<td>@ApiModel</td>
<td>用在类上，通常是实体类，表示一个返回响应数据的信息</td>
</tr>
<tr>
<td>@ApiModelProperty</td>
<td>用在属性上，描述响应类的属性</td>
</tr>
<tr>
<td>@ApiOperation</td>
<td>用在请求的方法上，说明方法的用途、作用</td>
</tr>
<tr>
<td>@ApiImplicitParams</td>
<td>用在请求的方法上，表示一组参数说明</td>
</tr>
<tr>
<td>@ApiImplicitParam</td>
<td>用在@ApilmplicitParams注解中，指定一个请求参数的各个方面</td>
</tr>
</tbody></table>
<h3 id="3-5项目部署"><a href="#3-5项目部署" class="headerlink" title="3.5项目部署"></a>3.5项目部署</h3><h4 id="3-5-1部署架构"><a href="#3-5-1部署架构" class="headerlink" title="3.5.1部署架构"></a>3.5.1部署架构</h4><p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230225140128438.png" alt="image-20230225140128438"></p>
<h4 id="3-5-2部署环境说明"><a href="#3-5-2部署环境说明" class="headerlink" title="3.5.2部署环境说明"></a>3.5.2部署环境说明</h4><p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230225142625263.png" alt="image-20230225142625263"></p>
<h4 id="3-5-3部署前端项目"><a href="#3-5-3部署前端项目" class="headerlink" title="3.5.3部署前端项目"></a>3.5.3部署前端项目</h4><p>第一步：在服务器A中安装Nginx，将课程资料中的dist目录（前端打包文件）上传到Nginx的html目录下</p>
<p>第二步：修改Nginx中的nginx.conf</p>
<p><img src="/2023/03/09/03-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20230225143210020.png" alt="image-20230225143210020"></p>
<h4 id="3-5-4部署后端项目"><a href="#3-5-4部署后端项目" class="headerlink" title="3.5.4部署后端项目"></a>3.5.4部署后端项目</h4><p>第一步：安装相应的工具，使用git clone命令将远程仓库中的代码克隆下来</p>
<p>第二步：将资料中的reggieStart.sh文件上传到服务器，通过chmod命令设置执行权限（拉取最新代码，将代码打包，在使用java -jar命令进行运行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 reggieStart.sh</span><br></pre></td></tr></table></figure>

<p>第三步：执行reggieStart.sh脚本文件，自动部署项目</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>瑞吉外卖业务开发</title>
    <url>/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="业务开发——员工管理"><a href="#业务开发——员工管理" class="headerlink" title="业务开发——员工管理"></a>业务开发——员工管理</h1><h2 id="一、开发环境搭建"><a href="#一、开发环境搭建" class="headerlink" title="一、开发环境搭建"></a>一、开发环境搭建</h2><h3 id="1-1-数据库环境搭建"><a href="#1-1-数据库环境搭建" class="headerlink" title="1.1 数据库环境搭建"></a>1.1 数据库环境搭建</h3><p>运行<code>sql</code>文件导入需要的数据表</p>
<p>数据表：</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/Users\14196\AppData\Roaming\Typora\typora-user-images\image-20230123140811366.png" alt="image-20230123140811366"></p>
<h3 id="1-2Maven环境搭建"><a href="#1-2Maven环境搭建" class="headerlink" title="1.2Maven环境搭建"></a>1.2Maven环境搭建</h3><ul>
<li>创建<code>Maven</code>项目，检查本地仓库、<code>jdk</code>版本配置是否正确</li>
<li>导入<code>pom</code>文件</li>
<li>编写启动类检查是否可以正常启动</li>
<li>导入前端页面，添加静态资源映射——导入后即可访问静态页面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置静态资源映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/backend/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/backend/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/front/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/front/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、后台系统登录和退出功能"><a href="#二、后台系统登录和退出功能" class="headerlink" title="二、后台系统登录和退出功能"></a>二、后台系统登录和退出功能</h2><h3 id="2-1后台登录功能开发"><a href="#2-1后台登录功能开发" class="headerlink" title="2.1后台登录功能开发"></a>2.1后台登录功能开发</h3><h4 id="2-1-1需求分析"><a href="#2-1-1需求分析" class="headerlink" title="2.1.1需求分析"></a>2.1.1需求分析</h4><p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230123173548664.png" alt="image-20230123173548664"></p>
<ul>
<li>判断账号和密码是否与数据库中的数据相对应</li>
<li>相对应则登录成功，否则登录失败</li>
<li>前端页面分析</li>
</ul>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230123180748033.png" alt="image-20230123180748033"></p>
<h4 id="2-1-2代码开发"><a href="#2-1-2代码开发" class="headerlink" title="2.1.2代码开发"></a>2.1.2代码开发</h4><p>1）创建实体类Employee，和employee表进行映射</p>
<p>2）创建Controller、Service、Mapper</p>
<p>3）导入返回结果类R——此类是一个通用结果类，服务器响应的所有结果最终都会包装成此种类型返回给前端页面</p>
<ul>
<li>当响应成功时，返回data即为调用success函数的时候的参数，并且设置响应code为1</li>
<li>当响应失败时，返回msg即为调用error函数的时候的参数，并且设置响应code为0</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spy.reggie.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用返回结果，服务端响应的数据最终都会封装成此对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code; <span class="comment">//编码：1成功，0和其它数字为失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//动态数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">success</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        R&lt;T&gt; r = <span class="keyword">new</span> <span class="title class_">R</span>&lt;T&gt;();</span><br><span class="line">        r.data = object;</span><br><span class="line">        r.code = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.msg = msg;</span><br><span class="line">        r.code = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> R&lt;T&gt; <span class="title function_">add</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）编写后台登录处理代码，处理逻辑如下：</p>
<ul>
<li>将页面提交的密码进行<code>md5</code>加密处理</li>
<li>根据页面提交的用户名<code>username</code>查询数据库</li>
<li>未查询到则返回登录失败结果</li>
<li>密码对比不一致返回登录失败结果</li>
<li>查看员工状态，如果员工为已禁用状态，则返回员工已禁用的结果</li>
<li>登录成功，将员工id存入到session并返回登录成功结果</li>
</ul>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230123194008116.png" alt="image-20230123194008116"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 员工登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;Employee&gt; <span class="title function_">login</span><span class="params">(HttpServletRequest request, <span class="meta">@RequestBody</span> Employee employee)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.将页面提交的密码进行`md5`加密处理</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> employee.getPassword();</span><br><span class="line">        password = DigestUtils.md5DigestAsHex(password.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.根据页面提交的用户名`username`查询数据库</span></span><br><span class="line">        LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(Employee::getUsername,employee.getUsername());</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> employeeService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.未查询到则返回登录失败结果</span></span><br><span class="line">        <span class="keyword">if</span> (emp == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.error(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.密码对比不一致返回登录失败结果</span></span><br><span class="line">        <span class="keyword">if</span> (!emp.getPassword().equals(password))&#123;</span><br><span class="line">            <span class="keyword">return</span> R.error(<span class="string">&quot;账号或者密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.查看员工状态，如果员工为已禁用状态，则返回员工已禁用的结果</span></span><br><span class="line">        <span class="keyword">if</span> (emp.getStatus() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.error(<span class="string">&quot;账号已禁用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.登录成功，将员工id存入到session并返回登录成功结果</span></span><br><span class="line">        request.getSession().setAttribute(<span class="string">&quot;employee&quot;</span>,emp.getId());</span><br><span class="line">        <span class="keyword">return</span> R.success(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<code>@RequestBody</code>就是将前端页面中收到的数据封装为<code>json</code>格式进行返回，使用<code>Employee</code>实体类来进行接收。</li>
<li>最终做返回的是数据库中查找出来的数据封装为<code>Employee</code>实体类</li>
</ul>
<h4 id="2-1-3功能测试"><a href="#2-1-3功能测试" class="headerlink" title="2.1.3功能测试"></a>2.1.3功能测试</h4><p>在页面上进行功能测试，测试三种情况是否都能有正常的响应</p>
<h3 id="2-2后台系统退出功能"><a href="#2-2后台系统退出功能" class="headerlink" title="2.2后台系统退出功能"></a>2.2后台系统退出功能</h3><h4 id="2-2-1需求分析"><a href="#2-2-1需求分析" class="headerlink" title="2.2.1需求分析"></a>2.2.1需求分析</h4><p>员工登录成功之后，页面跳转到后台系统首页面，此时会显示当前用户的姓名，如果员工需要退出系统，直接点击员工右侧的退出按钮即可退出系统，退出系统之后返回到登录页面。</p>
<h4 id="2-2-2代码开发"><a href="#2-2-2代码开发" class="headerlink" title="2.2.2代码开发"></a>2.2.2代码开发</h4><p><strong>代码思路：</strong></p>
<p>用户点击页面中的退出按钮，发送请求，请求地址为<code>/employee/logout</code>，请求方式为<code>POST</code>。我们只需要在<code>Controller</code>中创建对应的处理方法即可，具体的处理逻辑为：</p>
<ul>
<li>清理<code>Session</code>中的用户<code>id</code></li>
<li>返回结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/logout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">logout</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="comment">//清理Session中保存的当前登录员工的id</span></span><br><span class="line">    request.getSession().removeAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3功能测试"><a href="#2-2-3功能测试" class="headerlink" title="2.2.3功能测试"></a>2.2.3功能测试</h4><p>测试退出功能</p>
<h3 id="2-3登录功能的完善"><a href="#2-3登录功能的完善" class="headerlink" title="2.3登录功能的完善"></a>2.3登录功能的完善</h3><h4 id="2-3-1问题分析"><a href="#2-3-1问题分析" class="headerlink" title="2.3.1问题分析"></a>2.3.1问题分析</h4><ul>
<li>前面已经初步实现了后台系统的员工登录功能的开发，但是还存在一个问题：用户如果不登录，直接访问系统页面的首页，照样可以进行跳转访问。</li>
<li>我们的目标是只有登录成功之后才会访问系统中的页面，如果没有访问，则自动跳转到登录页面。</li>
<li>具体实现：使用过滤器或者拦截器，在过滤器或者拦截器之中判断员工是否已经登录，若未登录则跳转到登录页面。</li>
</ul>
<h4 id="2-3-2代码实现"><a href="#2-3-2代码实现" class="headerlink" title="2.3.2代码实现"></a>2.3.2代码实现</h4><p>实现步骤：</p>
<ol>
<li>创建自定义过滤器<code>LoginCheckFilter</code></li>
<li>在启动类上加入注解<code>@ServletComponentScan</code></li>
<li>完善过滤器的处理逻辑</li>
</ol>
<p>过滤器处理逻辑如下：</p>
<ul>
<li>获取本次请求的URI</li>
<li>判断此次请求是否需要处理</li>
<li>如果不需要处理，则直接放行</li>
<li>判断登录状态，如果已经登录，则直接放行</li>
<li>如果未登录则返回未登录结果</li>
</ul>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230125132329672.png" alt="image-20230125132329672"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;loginCheckFilter&quot;, urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">//路径匹配器，支持通配符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">PATH_MATCHER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line">        <span class="comment">//1、获取本次请求的URI</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;拦截到请求：&#123;&#125;&quot;</span>,requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义不需要处理的请求路径</span></span><br><span class="line">        String[] urls = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                <span class="string">&quot;/employee/login&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/employee/logout&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/backend/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/front/**&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、判断本次请求是否需要处理</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">check</span> <span class="operator">=</span> check(urls, requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、如果不需要处理，则直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(check)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;本次请求&#123;&#125;不需要处理&quot;</span>,requestURI);</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、判断登录状态，如果已登录，则直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户已登录，用户id为：&#123;&#125;&quot;</span>,request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>));</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        <span class="comment">//5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据</span></span><br><span class="line">        response.getWriter().write(JSON.toJSONString(R.error(<span class="string">&quot;NOTLOGIN&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查路径匹配来判断是否放行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestURI</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String[] urls, String requestURI)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> PATH_MATCHER.match(url, requestURI);</span><br><span class="line">            <span class="keyword">if</span> (match)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>filterName</code>的首字母一定要小写！！！小写！！！小写！！！</li>
</ul>
<h4 id="2-3-3功能测试"><a href="#2-3-3功能测试" class="headerlink" title="2.3.3功能测试"></a>2.3.3功能测试</h4><p>测试拦截是否已经生效</p>
<h2 id="三、新增员工功能"><a href="#三、新增员工功能" class="headerlink" title="三、新增员工功能"></a>三、新增员工功能</h2><h3 id="3-1需求分析"><a href="#3-1需求分析" class="headerlink" title="3.1需求分析"></a>3.1需求分析</h3><p>后台系统中可以管理员工的信息，通过新增员工来添加后台系统用户。点击<code>[添加员工]</code>按钮跳转到新增页面，如下：</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230125164551217.png" alt="image-20230125164551217"></p>
<h3 id="3-2数据模型"><a href="#3-2数据模型" class="headerlink" title="3.2数据模型"></a>3.2数据模型</h3><p>新增员工，其实就是将新增页面录入的员工数据插入到employee表，需要注意的是，<code>employee</code>表中对<code>username</code>字段加入了唯一约束，因为<code>username</code>是员工的登录账号，必须是唯一的。</p>
<p><code>employee</code>表中的<code>Status</code>字段已经设置了默认值1，表示状态正常。</p>
<h3 id="3-3代码开发"><a href="#3-3代码开发" class="headerlink" title="3.3代码开发"></a>3.3代码开发</h3><p>在开发代码之前，需要梳理一下整个程序的执行过程：</p>
<ol>
<li>页面发送<code>ajax</code>请求，将新增员工页面中输入的数据以<code>json</code>的形式提交给服务端</li>
<li>服务端<code>Controller</code>接收页面提交的数据并且调用<code>Service</code>将数据进行保存</li>
<li><code>Service</code>调用<code>Mapper</code>操作数据库，保存数据</li>
</ol>
<p>初步实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增员工</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(HttpServletRequest request, <span class="meta">@RequestBody</span> Employee employee)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;新增员工，员工信息：&#123;&#125;&quot;</span>,employee.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置初始密码123456,但是需要进行md5加密处理</span></span><br><span class="line">        employee.setPassword(DigestUtils.md5DigestAsHex(<span class="string">&quot;123456&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        employee.setCreateTime(LocalDateTime.now());</span><br><span class="line">        employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前登录用户的id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> (Long) request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line">        employee.setUpdateUser(empId);</span><br><span class="line">        employee.setCreateUser(empId);</span><br><span class="line"></span><br><span class="line">        employeeService.save(employee);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.success(<span class="string">&quot;新增员工成功&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此时存在一定的异常，当申请的账号在数据库中已经存在的时候，由于账号在设置该字段的时候加入了唯一性约束，因此程序会出现异常</p>
<blockquote>
<p>Duplicate entry ‘zhangsan’ for key ‘employee.idx_username’</p>
</blockquote>
</li>
<li><p>此时我们的程序需要进行异常捕获，通常有两种处理方式：</p>
<ol>
<li><p>在<code>Controller</code>方法中加入<code>try-catch</code>进行异常捕获</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    employeeService.save(employee);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.getMessage().contains(<span class="string">&quot;Duplicate entry&quot;</span>))&#123;</span><br><span class="line">        String[] split = e.getMessage().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> split[<span class="number">2</span>] + <span class="string">&quot;已存在&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> R.error(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用异常处理器进行全局异常捕获——项目采用此方式来进行异常捕获</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> spy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-25 17:22</span></span><br><span class="line"><span class="comment"> * 全局异常处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ControllerAdvice</span>中的参数表示拦截注解类型的且注解类型为以下两种的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">exceptionHandler</span><span class="params">(SQLIntegrityConstraintViolationException ex)</span>&#123;</span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ex.getMessage().contains(<span class="string">&quot;Duplicate entry&quot;</span>))&#123;</span><br><span class="line">            String[] split = ex.getMessage().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> split[<span class="number">2</span>] + <span class="string">&quot;已存在&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> R.error(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R.error(<span class="string">&quot;未知错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于异常信息：Duplicate entry ‘zhangsan’ for key ‘employee.idx_username’，采用上述split方法进行处理</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="3-4功能测试"><a href="#3-4功能测试" class="headerlink" title="3.4功能测试"></a>3.4功能测试</h3><p>测试新增员工功能和异常处理功能</p>
<h3 id="3-5小结"><a href="#3-5小结" class="headerlink" title="3.5小结"></a>3.5小结</h3><ul>
<li>根据产品原型明确业务需求</li>
<li>重点分析数据的流转过程和数据格式</li>
<li>通过debug断点调试跟踪程序执行过程</li>
</ul>
<h2 id="四、员工信息分页查询功能"><a href="#四、员工信息分页查询功能" class="headerlink" title="四、员工信息分页查询功能"></a>四、员工信息分页查询功能</h2><h3 id="4-1需求分析"><a href="#4-1需求分析" class="headerlink" title="4.1需求分析"></a>4.1需求分析</h3><p>系统中的员工很多的时候，如果在一个页面上全部显示出来会显得比较乱，不便于查看，所以一般系统中都会以分页的方式来展示数据</p>
<h3 id="4-2代码开发"><a href="#4-2代码开发" class="headerlink" title="4.2代码开发"></a>4.2代码开发</h3><p>在开发代码之前，梳理整个程序执行的过程：</p>
<ol>
<li>页面发送<code>ajax</code>请求，将分页查询参数(<code>page</code>、<code>pageSize</code>、<code>name</code>)提交到服务端（前端已做）</li>
<li>服务端<code>Controller</code>接收页面提交的数据并调用<code>Service</code>查询数据</li>
<li><code>Service</code>调用<code>Mapper</code>操作数据库，查询分页数据</li>
<li><code>Controller</code>将查询到的分页数据响应给页面</li>
<li>页面接收到分页数据并通过<code>ElementUI</code>的<code>Table</code>组件展示到页面上</li>
</ol>
<p><strong>配置类加入分页插件：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> spy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-25 18:58</span></span><br><span class="line"><span class="comment"> * 配置MP的分页插件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>员工信息分页数据查询</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 员工信息分页数据查询</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> page 当前页码</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pageSize 一页所包含的数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name 查询框里的查询条件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> pageSize,String name)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;page=&#123;&#125;,pageSize=&#123;&#125;,name=&#123;&#125;&quot;</span>,page,pageSize,name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造分页构造器</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pageInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(page,pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造条件构造器</span></span><br><span class="line">    LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加一个过滤条件</span></span><br><span class="line">    queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);</span><br><span class="line">    <span class="comment">//添加一个排序条件</span></span><br><span class="line">    queryWrapper.orderByDesc(Employee::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    employeeService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3功能测试"><a href="#4-3功能测试" class="headerlink" title="4.3功能测试"></a>4.3功能测试</h3><p>对员工分页功能进行测试</p>
<h2 id="五、启用、禁用员工账号"><a href="#五、启用、禁用员工账号" class="headerlink" title="五、启用、禁用员工账号"></a>五、启用、禁用员工账号</h2><h3 id="5-1需求分析"><a href="#5-1需求分析" class="headerlink" title="5.1需求分析"></a>5.1需求分析</h3><p>在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启用后的员工可以进行正常登录</p>
<p>可以注意，只有管理员（admin用户）可以对其他用户进行启用、禁用操作，所以普通用户登录系统之后启用、禁用按钮不显示</p>
<p>如果员工状态为启用，则按钮显示为 禁用；如果员工状态为禁用，则按钮显示为 启用</p>
<h3 id="5-2代码开发"><a href="#5-2代码开发" class="headerlink" title="5.2代码开发"></a>5.2代码开发</h3><ul>
<li><p>前端页面已经完成只有管理员可以显示启用、禁用操作按钮</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230125195900606.png" alt="image-20230125195900606"></p>
</li>
<li><p>在开发代码之前，需要梳理一下整个程序的执行过程</p>
<ol>
<li>页面发送<code>ajax</code>请求，将参数(<code>id</code>、<code>status</code>)提交到服务端</li>
<li>服务端<code>Controller</code>接收页面提交的数据并调用<code>Service</code>更新数据</li>
<li><code>Service</code>调用<code>Mapper</code>操作数据库</li>
</ol>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230125203559231.png" alt="image-20230125203559231"></p>
</li>
<li><p>页面发送<code>ajax</code>请求的方式</p>
</li>
</ul>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230125205356535.png" alt="image-20230125205356535"></p>
<ul>
<li>编写代码完成员工账号禁用及启用功能（和下面编辑员工信息代码一致）</li>
</ul>
<h3 id="5-3功能测试"><a href="#5-3功能测试" class="headerlink" title="5.3功能测试"></a>5.3功能测试</h3><p>进行功能测试，发现功能没有报错但是功能并没有实现，查看数据库可以发现数据库中的数据也没有变化</p>
<p>观察控制台给出的SQL：</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230125212245948.png" alt="image-20230125212245948"></p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230125212314603.png" alt="image-20230125212314603"></p>
<p>可以发现<code>id</code>值并不相同，SQL更新的结果为0</p>
<p><strong>原因：</strong></p>
<p><code>js</code>对<code>long</code>型数据进行处理时丢失精度，导致提交的<code>id</code>和数据库中的<code>id</code>不一致</p>
<p><strong>解决办法：</strong></p>
<p>我们可以在服务端给页面响应<code>json</code>数据时进行处理，将<code>long</code>型数据统一成<code>String</code>字符串</p>
<h3 id="5-4代码修复"><a href="#5-4代码修复" class="headerlink" title="5.4代码修复"></a>5.4代码修复</h3><p><strong>具体实现步骤：</strong></p>
<ul>
<li><p>提供对象转换器<code>JacksonObjectMapper</code>，基于<code>]ackson</code>进行<code>Java</code>对象到<code>json</code>数据的转换(资料中已经提供，直接复制到项目中使用)</p>
</li>
<li><p>这个类不止此处需要用到，在后续编辑员工信息也要用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象</span></span><br><span class="line"><span class="comment"> * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]</span></span><br><span class="line"><span class="comment"> * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonObjectMapper</span> <span class="keyword">extends</span> <span class="title class_">ObjectMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;HH:mm:ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JacksonObjectMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//收到未知属性时不报异常</span></span><br><span class="line">        <span class="built_in">this</span>.configure(FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化时，属性不存在的兼容处理</span></span><br><span class="line">        <span class="built_in">this</span>.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleModule</span> <span class="variable">simpleModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleModule</span>()</span><br><span class="line">                .addDeserializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))</span><br><span class="line"></span><br><span class="line">                .addSerializer(BigInteger.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(Long.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addSerializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addSerializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span></span><br><span class="line">        <span class="built_in">this</span>.registerModule(simpleModule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>WebMvcConfig</code>配置类中扩展<code>Spring mvc</code>的消息转换器，在此消息转换器中使用提供的对象转换器进行<code>Java</code>对象到<code>json</code>数据的转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 扩展mvc框架的消息转换器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;扩展消息转换器...&quot;</span>);</span><br><span class="line">    <span class="comment">//创建消息转换器对象</span></span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">messageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="comment">//设置对象转换器，底层使用Jackson将Java对象转为json</span></span><br><span class="line">    messageConverter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">    <span class="comment">//将上面的消息转换器对象追加到mvc框架的转换器集合中</span></span><br><span class="line">    converters.add(<span class="number">0</span>,messageConverter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="六、编辑员工信息"><a href="#六、编辑员工信息" class="headerlink" title="六、编辑员工信息"></a>六、编辑员工信息</h2><h3 id="6-1需求分析"><a href="#6-1需求分析" class="headerlink" title="6.1需求分析"></a>6.1需求分析</h3><p>在员工管理列表页面点击编辑按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最后点击保存按钮完成编辑操作</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230125215406966.png" alt="image-20230125215406966"></p>
<h3 id="6-2代码开发"><a href="#6-2代码开发" class="headerlink" title="6.2代码开发"></a>6.2代码开发</h3><p>在开发代码之前需要梳理一下操作过程和对应的程序的执行流程:</p>
<ol>
<li>点击编辑按钮时，页面跳转到<code>add.html</code>，并在<code>url</code>中携带参数[员工<code>id</code>]</li>
<li>在<code>add.htm</code>[页面获取<code>url</code>中的参数[员工<code>id</code>]</li>
<li>发送<code>ajax</code>请求，请求服务端，同时提交员工<code>id</code>参数</li>
<li>服务端接收请求，根据员工<code>id</code>查询员工信息，将员工信息以<code>json</code>形式响应给页面</li>
<li>页面接收服务端响应的<code>json</code>数据，通过<code>VUE</code>的数据绑定进行员工信息回显</li>
<li>点击保存按钮，发送<code>ajax</code>请求，将页面中的员工信息以<code>json</code>方式提交给服务端</li>
<li>服务端接收员工信息，并进行处理，完成后给页面响应</li>
<li>页面接收到服务端响应信息后进行相应处理</li>
</ol>
<p><strong>注意:</strong> <code>add.html</code>页面为公共页面，新增员工和编辑员工都是在此页面操作</p>
<p><code>html</code>页面中相关的代码都已经提供好了，我们只需要分析页面发送的请求和需要的响应数据格式，就可以对应来创<br>建服务端的<code>Controller</code>方法<code>getByld</code>方法</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230125220055996.png" alt="image-20230125220055996"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 编辑员工信息功能，由于和添加员工信息为同一个页面操作，因此主要实现数据回显</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Employee&gt; <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;根据id查询员工信息&quot;</span>);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeService.getById(id);</span><br><span class="line">    <span class="keyword">if</span> (employee != <span class="literal">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> R.success(employee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R.error(<span class="string">&quot;没有查询到对应员工信息&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">update</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">    employeeService.updateById(employee);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;员工信息修改成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3功能测试"><a href="#6-3功能测试" class="headerlink" title="6.3功能测试"></a>6.3功能测试</h3><p>测试数据回显功能是否实现</p>
<h1 id="业务开发——分类管理"><a href="#业务开发——分类管理" class="headerlink" title="业务开发——分类管理"></a>业务开发——分类管理</h1><h2 id="一、公共字段自动填充"><a href="#一、公共字段自动填充" class="headerlink" title="一、公共字段自动填充"></a>一、公共字段自动填充</h2><h3 id="1-1问题分析"><a href="#1-1问题分析" class="headerlink" title="1.1问题分析"></a>1.1问题分析</h3><p>前面已经完成后台系统员工管理功能的实现，在新增员工的时候需要设置创建时间、创建人、修改时间、修改人等字段，在编辑员工的时候需要设置修改时间和修改人等字段。这些字段属于公共字段，也就是很多表中都有这些字段</p>
<p>是否可以通过对这些公共字段在某个地方进行统一处理，从而来简化开发？</p>
<p>答案就是可以使用<code>MyBatis Plus</code>提供的公共字段处理功能</p>
<h3 id="1-2代码实现"><a href="#1-2代码实现" class="headerlink" title="1.2代码实现"></a>1.2代码实现</h3><p><code>Mybatis Plus</code>公共字段自动填充，也就是在插入或者更新的时候为指定字段赋予指定的值，使用它的好处就是可以统一对这些字段进行处理，避免了重复代码。</p>
<p>实现步骤:</p>
<ol>
<li><p>在实体类的属性上加入<code>@TableField</code>注解，指定自动填充的策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在Employee实体类中加入注解<span class="doctag">@TableField</span></span></span><br><span class="line"><span class="comment">FieldFill.INSERT：插入时进行更新</span></span><br><span class="line"><span class="comment">FieldFill.INSERT_UPDATE：插入和更新时都进行更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Long updateUser;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现<code>MetaObjectHandler</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjecthandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作，自动填充</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;公共字段自动填充[insert]...&quot;</span>);</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>,LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createUser&quot;</span>,<span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">1</span>));</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>,<span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作，自动填充</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;公共字段自动填充[update]...&quot;</span>);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line"></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>,LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>,<span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述的代码实现了使用数据填充器进行自动填充，但是还有一个问题：需要动态获取当前用户的<code>id</code>来进行赋值</li>
</ul>
</li>
</ol>
<h3 id="1-3功能测试"><a href="#1-3功能测试" class="headerlink" title="1.3功能测试"></a>1.3功能测试</h3><p>通过测试可以发现，能够进行自动填充</p>
<h3 id="1-4功能完善"><a href="#1-4功能完善" class="headerlink" title="1.4功能完善"></a>1.4功能完善</h3><p>前面我们已经完成了公共字段自动填充功能的代码开发，但是还有一个问题没有解决，就是我们在自动填充<code>createUser</code>和<code>updateUser</code>时设置的用户<code>id</code>是固定值，现在我们需要改造成动态获取当前登录用户的<code>id</code>。</p>
<p>有的同学可能想到，用户登录成功后我们将用户<code>id</code>存入了<code>HttpSession</code>中，现在我从<code>HttpSession</code>中获取不就行了?</p>
<p>注意：我们在<code>MyMetaObjectHandler</code>类中是不能获得<code>HttpSession</code>对象的，所以我们需要通过其他方式来获取登录用户<code>id</code>。</p>
<p>可以使用<code>ThreadLocal</code>来解决此问题，它是<code>JDK</code>中提供的一个类。</p>
<blockquote>
<p>在学习<code>ThreadLocal</code>之前，我们需要先确认一个事情，就是客户端发送的每次<code>http</code>请求，对应的在服务端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程:<br>1、<code>LoginCheckFilter</code>的<code>doFilter</code>方法<br>2、<code>EmployeeController</code>的<code>update</code>方法<br>3、<code>MyMetaObjectHandler</code>的<code>updateFill</code>方法<br>可以在上面的三个方法中分别加入下面代码 (获取当前线程id) :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">log.info(<span class="string">&quot;线程id:&#123;&#125;&quot;</span>,id);</span><br></pre></td></tr></table></figure>

<p>执行编辑员工功能进行验证，通过观察控制台输出可以发现，一次请求对应的线程<code>id</code>是相同的:</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230126110213751.png" alt="image-20230126110213751"></p>
</blockquote>
<p>什么是<code>ThreadLocal</code>?<br><code>ThreadLocal</code>并不是一个<code>Thread</code>，而是<code>Thread</code>的局部变量。当使用<code>ThreadLocal</code>维护变量时，<code>ThreadLocal</code>为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<code>ThreadLocal</code>为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p>
<p><strong><code>ThreadLocal</code>常用方法</strong></p>
<ul>
<li><code>public void set(T value)</code>:设置当前线程的线程局部变量的值</li>
<li><code>public T get()</code>:返回当前线程所对应的线程局部变量的值</li>
</ul>
<p>我们可以在<code>LoginCheckFilter</code>的<code>doFilter</code>方法中获取当前登录用户<code>id</code>，并调用<code>ThreadLocal</code>的<code>set</code>方法来设置当前线程的线程局部变量的值(用户<code>id</code>)，然后在<code>MyMeta0bjectHandler</code>的<code>updateFill</code>方法中调用<code>ThreadLocal</code>的<code>get</code>方法来获得当前线程所对应的线程局部变量的值(用户<code>id</code>)。</p>
<p><strong>实现步骤：</strong></p>
<ul>
<li>编写<code>BaseContext</code>工具类，基于<code>ThreadLocal</code>封装的工具类</li>
<li>在<code>LoginCheckFilter</code>的<code>doFilter</code>方法中调用<code>BaseContext</code>来设置当前登录用户的<code>id</code></li>
<li>在<code>MyMetaObjectHandler</code>的方法中调用<code>BaseContext</code>获取登录用户的<code>id</code></li>
</ul>
<p><code>BaseContext</code>工具类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于ThreadLocal封装工具类，用户保存和获取当前登录用户id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>LoginCheckFilter</code>的<code>doFilter</code>方法中调用<code>BaseContext</code>来设置当前登录用户的<code>id</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> (Long) request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line">BaseContext.setCurrentId(empId);</span><br></pre></td></tr></table></figure>

<p>在<code>MyMetaObjectHandler</code>的方法中调用<code>BaseContext</code>获取登录用户的<code>id</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">metaObject.setValue(<span class="string">&quot;createUser&quot;</span>,BaseContext.getCurrentId());</span><br><span class="line">metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>,BaseContext.getCurrentId());</span><br></pre></td></tr></table></figure>

<h2 id="二、新增分类"><a href="#二、新增分类" class="headerlink" title="二、新增分类"></a>二、新增分类</h2><h3 id="2-1需求分析"><a href="#2-1需求分析" class="headerlink" title="2.1需求分析"></a>2.1需求分析</h3><p>后台系统中可以管理分类信息，分类包括两种类型，分别是菜品分类和套餐分类。当我们在后台系统中添加菜品时需要选择一个菜品分类，当我们在后台系统中添加一个套餐时需要选择一个套餐分类，在移动端也会按照菜品分类和套餐分类来展示对应的菜品和套餐。</p>
<p>菜品分类和套餐分类如下：</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230126123438845.png" alt="image-20230126123438845"></p>
<h3 id="2-2数据模型"><a href="#2-2数据模型" class="headerlink" title="2.2数据模型"></a>2.2数据模型</h3><p>新增分类，其实就是将我们新增窗口录入的分类数据插入到<code>category</code>表中，其中表结构如下：</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230126124701898.png" alt="image-20230126124701898"></p>
<p>需要注意，<code>category</code>表中对<code>name</code>字段加入了唯一约束，保证分类的名称是唯一的：</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230126125548360.png" alt="image-20230126125548360"></p>
<h3 id="2-3代码开发"><a href="#2-3代码开发" class="headerlink" title="2.3代码开发"></a>2.3代码开发</h3><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好</p>
<ul>
<li>实体类<code>Category</code> (直接从课程资料中导入即可)</li>
<li><code>Mapper</code>接口<code>CategoryMapper</code></li>
<li>业务层接口<code>CategoryService</code></li>
<li>业务层实现类<code>CategoryServicelmpl</code></li>
<li>控制层<code>CategoryController</code></li>
</ul>
<p>在开发代码之前，需要梳理一下整个程序的执行过程</p>
<ul>
<li>页面(<code>backend/page/category/list.html</code>)发送<code>ajax</code>请求，将新增分类窗口输入的数据以<code>json</code>形式提交到服务端</li>
<li>服务端<code>Controller</code>接收页面提交的数据并调用<code>Service</code>将数据进行保存</li>
<li><code>Service</code>调用<code>Mapper</code>操作数据库，保存数据</li>
</ul>
<p>可以看到新增菜品分类和新增套餐分类请求的服务端地址和提交的<code>json</code>数据结构相同，所以服务端只需要提供一个方法统处理即可:</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230126130523328.png" alt="image-20230126130523328"></p>
<ul>
<li>只有<code>type</code>的值不同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Category category)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;category:&#123;&#125;&quot;</span>,category);</span><br><span class="line">    categoryService.save(category);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;新增分类成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4功能测试"><a href="#2-4功能测试" class="headerlink" title="2.4功能测试"></a>2.4功能测试</h3><p>进行功能测试，测试是否可以正常导入以及重复数据是否可以进行全局异常处理</p>
<h2 id="三、分类信息分页查询"><a href="#三、分类信息分页查询" class="headerlink" title="三、分类信息分页查询"></a>三、分类信息分页查询</h2><h3 id="3-1需求分析-1"><a href="#3-1需求分析-1" class="headerlink" title="3.1需求分析"></a>3.1需求分析</h3><p>数据太多，全部放在同一个页面中会导致可读性差，因此引入分页插件进行分页展示</p>
<h3 id="3-2代码开发"><a href="#3-2代码开发" class="headerlink" title="3.2代码开发"></a>3.2代码开发</h3><p>在开发代码之前，需要梳理一下整个程序的执行过程</p>
<ol>
<li><p>页面发送<code>ajax</code>请求，将分页查询参数(<code>page</code>、<code>pageSize</code>)提交到服务端</p>
</li>
<li><p>服务端<code>Controller</code>接收页面提交的数据并调用<code>Service</code>查询数据</p>
</li>
<li><p><code>Service</code>调用<code>Mapper</code>操作数据库，查询分页数据</p>
</li>
<li><p><code>Controller</code>将查询到的分页数据响应给页面</p>
</li>
<li><p>页面接收到分页数据并通过<code>ElementUl</code>的<code>Table</code>组件展示到页面上</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230126152756607.png" alt="image-20230126152756607"></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分页展示信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> pageSize)</span>&#123;</span><br><span class="line">    <span class="comment">//引入分页构造器</span></span><br><span class="line">    Page&lt;Category&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page, pageSize);</span><br><span class="line">    <span class="comment">//构造条件查询器</span></span><br><span class="line">    LambdaQueryWrapper&lt;Category&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加排序条件，根据sort进行排序</span></span><br><span class="line">    queryWrapper.orderByAsc(Category::getSort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行分页查询</span></span><br><span class="line">    categoryService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3功能测试"><a href="#3-3功能测试" class="headerlink" title="3.3功能测试"></a>3.3功能测试</h3><p>测试分页功能是否已经完成</p>
<h2 id="四、删除分类"><a href="#四、删除分类" class="headerlink" title="四、删除分类"></a>四、删除分类</h2><h3 id="4-1需求分析-1"><a href="#4-1需求分析-1" class="headerlink" title="4.1需求分析"></a>4.1需求分析</h3><p>在分类管理页面，可以对某个分类进行删除。需要注意的是当分类关联了菜品或者套餐的时候，此分类不允许删除。</p>
<ul>
<li>这里的关联指的是：例如精品热菜中有菜品的话，不可以删除这个套餐；同理，在套餐中的菜品也不可以被删除</li>
</ul>
<h3 id="4-2代码开发-1"><a href="#4-2代码开发-1" class="headerlink" title="4.2代码开发"></a>4.2代码开发</h3><p>在开发代码之前，需要梳理一下整个程序的执行过程</p>
<ol>
<li><p>页面发送ajax请求，将参数(id)提交到服务端</p>
</li>
<li><p>服务端Controller接收页面提交的数据并调用Service删除数据</p>
</li>
<li><p>Service调用Mapper操作数据库</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230126163935398.png" alt="image-20230126163935398"></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">delete</span><span class="params">(Long ids)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;删除分类，id为：&#123;&#125;&quot;</span>,ids);</span><br><span class="line"></span><br><span class="line">    categoryService.removeById(ids);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;分类信息删除成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3功能测试-1"><a href="#4-3功能测试-1" class="headerlink" title="4.3功能测试"></a>4.3功能测试</h3><p>测试删除功能是否可以成功实现</p>
<h3 id="4-4功能完善"><a href="#4-4功能完善" class="headerlink" title="4.4功能完善"></a>4.4功能完善</h3><p>前面我们已经实现了根据<code>id</code>删除分类的功能，但是并没有检查删除的分类是否关联了菜品或者套餐，所以我们需要进行功能完善。</p>
<p>要完善分类删除功能，需要先准备基础的类和接口:</p>
<ol>
<li>实体类<code>Dish</code>和<code>Setmeal</code> (从课程资料中复制即可)</li>
<li><code>Mapper</code>接口<code>DishMapper</code>和<code>SetmealMapper</code></li>
<li><code>Service</code>接口<code>DishService</code>和<code>SetmealService</code></li>
<li><code>Service</code>实现类<code>DishServicelmpl</code>和<code>SetmealServicelmpl</code></li>
</ol>
<p>在<code>CategoryServiceImpl</code>加入如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;CategoryMapper, Category&gt; <span class="keyword">implements</span> <span class="title class_">CategoryService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishService dishService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SetmealService setmealService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除分类，删除之前需要进行判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加查询条件，根据分类id进行查询</span></span><br><span class="line">        dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> dishService.count(dishLambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询当前分类是否关联了菜品，如果已经关联，抛出一个业务异常</span></span><br><span class="line">        <span class="keyword">if</span>(count1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//已经关联菜品，抛出一个业务异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;当前分类下关联了菜品，不能删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常</span></span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加查询条件，根据分类id进行查询</span></span><br><span class="line">        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> setmealService.count(setmealLambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">if</span>(count2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//已经关联套餐，抛出一个业务异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;当前分类下关联了套餐，不能删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常删除分类</span></span><br><span class="line">        <span class="built_in">super</span>.removeById(id);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建自定义异常<code>CustomException</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在全局异常模块加入如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(CustomException.class)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">exceptionHandler</span><span class="params">(CustomException ex)</span>&#123;</span><br><span class="line">    log.error(ex.getMessage());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.error(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、修改分类"><a href="#五、修改分类" class="headerlink" title="五、修改分类"></a>五、修改分类</h2><h3 id="5-1需求分析-1"><a href="#5-1需求分析-1" class="headerlink" title="5.1需求分析"></a>5.1需求分析</h3><p>在分类管理页面点击修改按钮，弹出修改窗口，在修改窗口进行数据回显并进行修改，最后点击确定按钮完成修改操作</p>
<ul>
<li>其中回显已经前端完成，只需要我们点击确定处理发送请求</li>
</ul>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230126182034964.png" alt="image-20230126182034964"></p>
<h3 id="5-2代码开发-1"><a href="#5-2代码开发-1" class="headerlink" title="5.2代码开发"></a>5.2代码开发</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 进行分类更新</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> category</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Category category)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;更新分类为：&#123;&#125;&quot;</span>, category);</span><br><span class="line"></span><br><span class="line">    categoryService.updateById(category);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;修改分类信息成功&quot;</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3功能测试-1"><a href="#5-3功能测试-1" class="headerlink" title="5.3功能测试"></a>5.3功能测试</h3><h1 id="业务开发——菜品管理"><a href="#业务开发——菜品管理" class="headerlink" title="业务开发——菜品管理"></a>业务开发——菜品管理</h1><h2 id="一、文件上传下载"><a href="#一、文件上传下载" class="headerlink" title="一、文件上传下载"></a>一、文件上传下载</h2><h3 id="1-1文件上传介绍"><a href="#1-1文件上传介绍" class="headerlink" title="1.1文件上传介绍"></a>1.1文件上传介绍</h3><p>文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。</p>
<p>文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。</p>
<p>文件上传时，对页面的form表单有如下要求:</p>
<ul>
<li><code>method=&quot;post&quot;</code>                                   采用<code>post</code>方式提交数据</li>
<li><code>enctype=&quot;multipart/form-data&quot; </code> 采用<code>multipart</code>格式上传文件</li>
<li><code>type=&quot;file&quot;</code>                                       使用<code>input</code>的<code>file</code>控件上传</li>
</ul>
<p><strong>举例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/common/upload&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;myFile&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file”/&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">	&lt;input type=&quot;</span><span class="attr">submit</span>&quot; <span class="attr">value</span>=<span class="string">&quot;提交”/&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">&lt;/form&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>服务端要接收客户端页面上传的文件，通常都会使用<code>Apache</code>的两个组件：</p>
<ul>
<li><code>commons-fileupload</code></li>
<li><code>commons-io</code></li>
</ul>
<p>Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个<code>MultipartFile</code>类型的参数即可接收上传的文件，例如：</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230126203013968.png" alt="image-20230126203013968"></p>
<h3 id="1-2文件下载介绍"><a href="#1-2文件下载介绍" class="headerlink" title="1.2文件下载介绍"></a>1.2文件下载介绍</h3><p>文件下载，也称为<code>download</code>，是指将文件从服务器传输到本地计算机的过程。</p>
<p>通过浏览器进行文件下载，通常有两种表现形式：</p>
<ul>
<li>以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录</li>
<li>直接在浏览器中打开</li>
</ul>
<p>通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程</p>
<h3 id="1-3文件上传代码实现"><a href="#1-3文件上传代码实现" class="headerlink" title="1.3文件上传代码实现"></a>1.3文件上传代码实现</h3><p>文件上传，页面端可以使用<code>ElementUl</code>提供的上传组件。</p>
<p>可以直接使用资料中提供的上传页面，位置：资料&#x2F;文件上传下载页面&#x2F;upload.html</p>
<ul>
<li>在配置文件中配置上传地址</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">reggie:</span><br><span class="line">  path: D:\</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>CommonController</code>中代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;reggie.path&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String basePath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文件上传</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file 名字一定要和前端中的name保持一致，否则无法获取文件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span>&#123;</span><br><span class="line">    <span class="comment">//file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除</span></span><br><span class="line">    log.info(file.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原始文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">    <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用UUID重新生成文件名，防止文件名重复导致文件覆盖</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + suffix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个目录对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(basePath);</span><br><span class="line">    <span class="comment">//判断当前目录是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!dir.exists())&#123;</span><br><span class="line">        <span class="comment">//目录不存在</span></span><br><span class="line">        dir.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将临时文件转存到指定位置</span></span><br><span class="line">        file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + fileName));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4文件下载代码实现"><a href="#1-4文件下载代码实现" class="headerlink" title="1.4文件下载代码实现"></a>1.4文件下载代码实现</h3><p>上面实现了文件上传，传到一个指定位置，现在要实现文件的下载，将刚刚上传的图片在页面中展示出来</p>
<p>文件下载，页面端可以使用<img>标签展示下载的图片</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230127081707368.png" alt="image-20230127081707368"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文件下载</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String name, HttpServletResponse response)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//输入流，通过输入流读取文件内容</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + name));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出流，通过输出流将文件写回浏览器</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStream.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、新增菜品"><a href="#二、新增菜品" class="headerlink" title="二、新增菜品"></a>二、新增菜品</h2><h3 id="2-1需求分析-1"><a href="#2-1需求分析-1" class="headerlink" title="2.1需求分析"></a>2.1需求分析</h3><p>后台系统中可以管理菜品信息，通过新增功能来添加一个新的菜品，在添加菜品时需要选择当前菜品所属的菜品分类，并且需要上传菜品图片，在移动端会按照菜品分类来展示对应的菜品信息。</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230127085329971.png" alt="image-20230127085329971"></p>
<h3 id="2-2数据模型-1"><a href="#2-2数据模型-1" class="headerlink" title="2.2数据模型"></a>2.2数据模型</h3><p>新增菜品，其实就是将新增页面录入的菜品信息插入到<code>dish</code>表，如果添加了口味做法，还需要向<code>dish_flavor</code>表插入数据所以在新增菜</p>
<p>品时，涉及到两个表:</p>
<ul>
<li>dish                菜品表</li>
<li>dish flavor    菜品口味表</li>
</ul>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230127085750838.png" alt="image-20230127085750838"></p>
<h3 id="2-3代码开发-1"><a href="#2-3代码开发-1" class="headerlink" title="2.3代码开发"></a>2.3代码开发</h3><p><strong>准备工作</strong></p>
<p>在开发业务功能前，先将需要用到的类和接口基本结构创建好</p>
<ul>
<li>实体类 <code>DishFlavor</code>(直接从课程资料中导入即可，<code>Dish</code>实体前面课程中已经导入过了)</li>
<li><code>Mapper</code>接口<code>DishFlavorMapper</code></li>
<li>业务层接口 <code>DishFlavorService</code></li>
<li>业务层实现类 <code>DishFlavorServicelmpl</code></li>
<li>控制层 <code>DishController</code></li>
</ul>
<p><strong>首先将上述准备工作完成，然后梳理交互过程</strong></p>
<p>在开发代码之前，需要梳理一下新增菜品时前端页面和服务端的交互过程</p>
<ol>
<li>页面(backend&#x2F;page&#x2F;food&#x2F;add.html)发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中</li>
<li>页面发送请求进行图片上传，请求服务端将图片保存到服务器</li>
<li>页面发送请求进行图片下载，将上传的图片进行回显</li>
<li>点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端</li>
</ol>
<p>开发新增菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求即可</p>
<ul>
<li>页面(backend&#x2F;page&#x2F;food&#x2F;add.html)发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据条件查询分类数据</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> category</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;List&lt;Category&gt;&gt; <span class="title function_">list</span><span class="params">(Category category)</span> &#123;</span><br><span class="line">    <span class="comment">//条件构造器</span></span><br><span class="line">    LambdaQueryWrapper&lt;Category&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加条件</span></span><br><span class="line">    queryWrapper.eq(category.getType() != <span class="literal">null</span>,Category::getType,category.getType());</span><br><span class="line">    <span class="comment">//添加排序条件</span></span><br><span class="line">    queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Category&gt; list = categoryService.list(queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> R.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中2、3步已经在文件上传和下载模块进行处理</p>
</li>
<li><p>点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端</p>
<p><strong>注意：</strong>在点击保存按钮之后，页面封装的数据，在<code>dish</code>实体类中并没有<code>flavor</code>属性，因此需要导入一个新的实体类（<code>DishDto</code>）来用于封装页面提交的数据</p>
<p>DTO：全程Data Transfer Object，即数据传输对象，一般用于展示层与服务层之间的数据传输。</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230127102946081.png" alt="image-20230127102946081"></p>
</li>
</ul>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230127103723887.png" alt="image-20230127103723887"></p>
<p>代码实现：</p>
<p><code>DishService</code>接口中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增菜品，同时插入菜品对应的口味数据，需要同时操作两张表dish、dish_flavor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveWithFlavor</span><span class="params">(DishDto dishDto)</span>;</span><br></pre></td></tr></table></figure>

<p><code>DishServiceImpl</code>实现类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 新增菜品同时保存对应口味信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dishDto</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Transactional</span><span class="comment">//加入事务注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveWithFlavor</span><span class="params">(DishDto dishDto)</span> &#123;</span><br><span class="line">    <span class="comment">//保存菜品的基本信息到菜品表dish</span></span><br><span class="line">    <span class="built_in">this</span>.save(dishDto);</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> dishDto.getId();<span class="comment">//菜品id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜品口味</span></span><br><span class="line">    List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line">    flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">        item.setDishId(dishId);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存菜品口味数据到菜品口味表dish_flavor</span></span><br><span class="line">    dishFlavorService.saveBatch(flavors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动类加入启动事务注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4功能测试-1"><a href="#2-4功能测试-1" class="headerlink" title="2.4功能测试"></a>2.4功能测试</h3><p>测试数据表是否进行正常插入功能</p>
<h2 id="三、菜品信息分页"><a href="#三、菜品信息分页" class="headerlink" title="三、菜品信息分页"></a>三、菜品信息分页</h2><h3 id="3-1需求分析-2"><a href="#3-1需求分析-2" class="headerlink" title="3.1需求分析"></a>3.1需求分析</h3><p>系统中菜品信息较多，如果在一个页面中进行展示会比较乱，因此采用分页的方式来进行列表数据。</p>
<h3 id="3-2代码开发-1"><a href="#3-2代码开发-1" class="headerlink" title="3.2代码开发"></a>3.2代码开发</h3><p>在开发代码之前，需要梳理一下菜品分页查询时前端页面和服务端的交互过程</p>
<ol>
<li>页面(backend&#x2F;page&#x2F;food&#x2F;list.html)发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端，获取分页数据</li>
<li>页面发送请求，请求服务端进行图片下载，用于页面图片展示</li>
</ol>
<p>开发菜品信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜品信息分页</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> pageSize,String name)</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//构造分页构造器对象</span></span><br><span class="line">       Page&lt;Dish&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page,pageSize);</span><br><span class="line">       Page&lt;DishDto&gt; dishDtoPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//条件构造器</span></span><br><span class="line">       LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//添加过滤条件</span></span><br><span class="line">       queryWrapper.like(name != <span class="literal">null</span>,Dish::getName,name);</span><br><span class="line">       <span class="comment">//添加排序条件</span></span><br><span class="line">       queryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//执行分页查询</span></span><br><span class="line">       dishService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//对象拷贝</span></span><br><span class="line">       BeanUtils.copyProperties(pageInfo,dishDtoPage,<span class="string">&quot;records&quot;</span>);</span><br><span class="line"></span><br><span class="line">       List&lt;Dish&gt; records = pageInfo.getRecords();</span><br><span class="line"></span><br><span class="line">       List&lt;DishDto&gt; list = records.stream().map((item) -&gt; &#123;</span><br><span class="line">           <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishDto</span>();</span><br><span class="line"></span><br><span class="line">           BeanUtils.copyProperties(item,dishDto);</span><br><span class="line"></span><br><span class="line">           <span class="type">Long</span> <span class="variable">categoryId</span> <span class="operator">=</span> item.getCategoryId();<span class="comment">//分类id</span></span><br><span class="line">           <span class="comment">//根据id查询分类对象</span></span><br><span class="line">           <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(category != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">categoryName</span> <span class="operator">=</span> category.getName();</span><br><span class="line">               dishDto.setCategoryName(categoryName);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> dishDto;</span><br><span class="line">       &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">       dishDtoPage.setRecords(list);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> R.success(dishDtoPage);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在菜品分页代码开发中，如果只是将返回数据封装为一个Dish对象，那么会导致菜品分类项无法显示。因此进行上述操作将其拷贝到<code>DishDto</code>中再设置其分类即可</li>
</ul>
<h3 id="3-3功能测试-1"><a href="#3-3功能测试-1" class="headerlink" title="3.3功能测试"></a>3.3功能测试</h3><p>测试分页功能是否可以正常展示</p>
<h2 id="四、修改菜品"><a href="#四、修改菜品" class="headerlink" title="四、修改菜品"></a>四、修改菜品</h2><h3 id="4-1需求分析-2"><a href="#4-1需求分析-2" class="headerlink" title="4.1需求分析"></a>4.1需求分析</h3><p>在菜品管理列表页面点击修改操作，跳转到修改菜品页面，在修改页面回显菜品相关信息并进行修改，最后点击确定按钮完成修改操作</p>
<h3 id="4-2代码开发-2"><a href="#4-2代码开发-2" class="headerlink" title="4.2代码开发"></a>4.2代码开发</h3><p>在开发代码之前，需要梳理一下修改菜品时前端页面 (add.html) 和服务端的交互过程</p>
<ol>
<li>页面发送ajax请求，请求服务端获取分类数据，用于菜品分类下拉框中数据展示（前面已经实现）</li>
<li>页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</li>
<li>页面发送请求，请求服务端进行图片下载，用于页图片回显</li>
<li>点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</li>
</ol>
<p>开发修改菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求即可</p>
<p><strong>注意</strong>：其中第一步和第三步已经实现，只要实现第二步和第四步即可</p>
<p>② 页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</p>
<ul>
<li><p>首先在Service层编写接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id查询菜品信息和口味信息</span></span><br><span class="line"><span class="keyword">public</span> DishDto <span class="title function_">getByIdWithFlavor</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在ServiceImpl编写接口函数的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DishDto <span class="title function_">getByIdWithFlavor</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询菜品基本信息，从dish表进行查询</span></span><br><span class="line">    <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(id);</span><br><span class="line"></span><br><span class="line">    <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishDto</span>();</span><br><span class="line">    BeanUtils.copyProperties(dish,dishDto);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前菜品的口味信息，从dish_flavor表查询</span></span><br><span class="line">    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(DishFlavor::getDishId,dish.getId());</span><br><span class="line">    List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);</span><br><span class="line">    dishDto.setFlavors(flavors);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dishDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Controller层编写控制层函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据id查询菜品的信息和口味信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;DishDto&gt; <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> dishService.getByIdWithFlavor(id);</span><br><span class="line">    <span class="keyword">return</span> R.success(dishDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>④ 点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</p>
<p>在Controller层插入代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修改菜品</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dishDto</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> DishDto dishDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">    dishService.updateWithFlavor(dishDto);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;修改菜品成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Service层编写函数<code>updateWithFlavor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新菜品信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dishDto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithFlavor</span><span class="params">(DishDto dishDto)</span> &#123;</span><br><span class="line">    <span class="comment">//更新dish表基本信息</span></span><br><span class="line">    <span class="built_in">this</span>.updateById(dishDto);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先清理当前菜品对应的口味数据——dish_flavor表的delete操作</span></span><br><span class="line">    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());</span><br><span class="line"></span><br><span class="line">    dishFlavorService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加当前提交过来的口味数据——dish_flavor表的insert操作</span></span><br><span class="line">    List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line"></span><br><span class="line">    flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">        item.setDishId(dishDto.getId());</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    dishFlavorService.saveBatch(flavors);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3功能测试-2"><a href="#4-3功能测试-2" class="headerlink" title="4.3功能测试"></a>4.3功能测试</h3><p>进行功能测试</p>
<h2 id="五、菜品的删除"><a href="#五、菜品的删除" class="headerlink" title="五、菜品的删除"></a>五、菜品的删除</h2><h3 id="5-1需求分析-2"><a href="#5-1需求分析-2" class="headerlink" title="5.1需求分析"></a>5.1需求分析</h3><p>菜品的删除包括删除和批量删除</p>
<h3 id="5-2代码开发-2"><a href="#5-2代码开发-2" class="headerlink" title="5.2代码开发"></a>5.2代码开发</h3><p>批量删除代码</p>
<p><code>Controller</code>层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除菜品和对应的口味</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">    dishService.deleteWithFlavor(ids);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;菜品数据删除成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Service</code>层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除对应的菜品信息， 同时还要删除关联表dish_flavor中的数据。</span></span><br><span class="line"><span class="comment">     * 注意：如果菜品为起售则不能删除菜品，只有先停售后才能删除。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteWithFlavor</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">        <span class="comment">//先来查询菜品状态，确定是否可以删除</span></span><br><span class="line">        <span class="comment">//select count(*) from dish where id in(1,2,3) and status = 1</span></span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.in(Dish::getId,ids);</span><br><span class="line">        queryWrapper.eq(Dish::getStatus,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果不能删除，抛出一个业务异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;菜品正在售卖中，不能删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果可以删除，先删除套餐表中的数据——dish</span></span><br><span class="line">        <span class="built_in">this</span>.removeByIds(ids);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除关系表中的数据——dish_flavor</span></span><br><span class="line">        <span class="comment">//delete from dish_flavor where dish_id in(1,2,3)</span></span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.in(DishFlavor::getDishId,ids);</span><br><span class="line"></span><br><span class="line">        dishFlavorService.remove(lambdaQueryWrapper);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3功能测试-2"><a href="#5-3功能测试-2" class="headerlink" title="5.3功能测试"></a>5.3功能测试</h3><h2 id="六、菜品的启售停售"><a href="#六、菜品的启售停售" class="headerlink" title="六、菜品的启售停售"></a>六、菜品的启售停售</h2><h3 id="6-1需求分析-1"><a href="#6-1需求分析-1" class="headerlink" title="6.1需求分析"></a>6.1需求分析</h3><p>当菜品处于启售状态的时候，页面上按钮显示为停售；当菜品处于停售状态的时候，页面上按钮显示为启售，点击之后状态进行更改。</p>
<h3 id="6-2代码开发-1"><a href="#6-2代码开发-1" class="headerlink" title="6.2代码开发"></a>6.2代码开发</h3><p><strong>批量启售停售</strong></p>
<ol>
<li><p>我们同样还是使用批量更新的方法<code>updateBatchById()</code>,接受的是一个<code>Dish</code>集合，而不是单单的<code>id</code>。以为需要根据实体类匹配数据库字段，更新每个<code>Dish</code>对象的值。</p>
</li>
<li><p>我们得到的<code>id</code>需要设置给每个<code>Dish</code>对象，并修改状态信息。</p>
</li>
<li><p>路径参数传过来的<code>st</code>，就是要修改的状态值，即我要让这些<code>ids</code>停售，<code>st = 0</code>，所以直接设置状态即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/status/&#123;st&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">updateStatus</span><span class="params">(<span class="meta">@PathVariable</span> Integer st, <span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.in(Dish::getId,ids);</span><br><span class="line">    List&lt;Dish&gt; dishList = dishService.list(queryWrapper);</span><br><span class="line">    dishList = dishList.stream().map((item) -&gt; &#123;</span><br><span class="line">        item.setStatus(st);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    dishService.updateBatchById(dishList);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;菜品起售停售修改成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3功能测试-1"><a href="#6-3功能测试-1" class="headerlink" title="6.3功能测试"></a>6.3功能测试</h3><h1 id="业务开发——套餐管理"><a href="#业务开发——套餐管理" class="headerlink" title="业务开发——套餐管理"></a>业务开发——套餐管理</h1><h2 id="一、新增套餐"><a href="#一、新增套餐" class="headerlink" title="一、新增套餐"></a>一、新增套餐</h2><h3 id="1-1需求分析"><a href="#1-1需求分析" class="headerlink" title="1.1需求分析"></a>1.1需求分析</h3><p>套餐就是菜品的集合。</p>
<p>后台系统中可以管理套餐信息，通过新增套餐功能来添加一个新的套餐，在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片，在移动端会按照套餐分类来展示对应的套餐。</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230127204123515.png" alt="image-20230127204123515"></p>
<h3 id="1-2数据模型"><a href="#1-2数据模型" class="headerlink" title="1.2数据模型"></a>1.2数据模型</h3><p>新增套餐，其实就是将新增页面录入的套餐信息插入到<code>setmeal</code>表，还需要向<code>setmeal_dish</code>表插入套餐和菜品关联数据所以在新增套餐时，涉及到两个表:</p>
<ul>
<li><code>setmeal     </code>                     套餐表</li>
<li><code>setmeal_dish </code>          套餐菜品关系表</li>
</ul>
<h3 id="1-3代码开发"><a href="#1-3代码开发" class="headerlink" title="1.3代码开发"></a>1.3代码开发</h3><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好</p>
<ul>
<li>实体类<code>SetmealDish</code>(直接从课程资料中导入即可，<code>Setmeal</code>实体前面课程中已经导入过了)</li>
<li><code>DTO SetmealDto</code>(直接从课程资料中导入即可)</li>
<li><code>Mapper</code>接口 <code>SetmealDishMapper</code></li>
<li>业务层接口 <code>SetmealDishService</code></li>
<li>业务层实现类 <code>SetmealDishServicelmpl</code></li>
<li>控制层 <code>SetmealController</code></li>
</ul>
<p><strong>梳理交互过程</strong></p>
<p>在开发代码之前，需要梳理一下新增套餐时前端页面和服务端的交互过程</p>
<ol>
<li>页面(backend&#x2F;page&#x2F;combo&#x2F;add.html)发送ajax请求，请求服务端获取套餐分类数据并展示到下拉框中（菜品已经实现）</li>
<li>页面发送ajax请求，请求服务端获取菜品分类数据并展示到添加菜品窗口中（菜品已经实现）</li>
<li>页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中</li>
<li>页面发送请求进行图片上传，请求服务端将图片保存到服务器（已完成）</li>
<li>页面发送请求进行图片下载，将上传的图片进行回显（已完成）</li>
<li>点击保存按钮，发送ajax请求，将套餐相关数据以<code>json</code> 形式提交到服务端</li>
</ol>
<p>开发新增套餐功能，其实就是在服务端编写代码去处理前端页面发送的这6次请求即可</p>
<p>③ 页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 套餐管理中添加菜品时进行显示</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;List&lt;Dish&gt;&gt; <span class="title function_">list</span><span class="params">(Dish dish)</span> &#123;</span><br><span class="line">       <span class="comment">//构造查询条件对象</span></span><br><span class="line">       LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.eq(dish.getCategoryId() != <span class="literal">null</span>, Dish::getCategoryId, dish.getCategoryId());</span><br><span class="line">       <span class="comment">//添加条件，查询状态为1（启售）</span></span><br><span class="line">       queryWrapper.eq(Dish::getStatus,<span class="number">1</span>);</span><br><span class="line">       <span class="comment">//添加排序条件</span></span><br><span class="line">       queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">       List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> R.success(list);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>⑥ 点击保存按钮，发送ajax请求，将套餐相关数据以<code>json</code> 形式提交到服务端</p>
<p>在service层添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增套餐，同时保存套餐和菜品的关联关系</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> setmealDto</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveWithDish</span><span class="params">(SetmealDto setmealDto)</span> &#123;</span><br><span class="line">        <span class="comment">//保存套餐的基本信息，操作setmeal，执行insert操作</span></span><br><span class="line">        <span class="built_in">this</span>.save(setmealDto);</span><br><span class="line"></span><br><span class="line">        List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();</span><br><span class="line">        setmealDishes.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setSetmealId(setmealDto.getId());</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存套餐和菜品的关联信息，操作setmeal_dish，执行insert操作</span></span><br><span class="line">        setmealDishService.saveBatch(setmealDishes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在controller层调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 新增套餐</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> setmealDto</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> SetmealDto setmealDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">       setmealService.saveWithDish(setmealDto);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> R.success(<span class="string">&quot;新增套餐成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4功能测试"><a href="#1-4功能测试" class="headerlink" title="1.4功能测试"></a>1.4功能测试</h3><h2 id="二、套餐信息分页查询"><a href="#二、套餐信息分页查询" class="headerlink" title="二、套餐信息分页查询"></a>二、套餐信息分页查询</h2><h3 id="2-1需求分析-2"><a href="#2-1需求分析-2" class="headerlink" title="2.1需求分析"></a>2.1需求分析</h3><p>系统中套餐信息较多，如果在一个页面中进行展示会比较乱，因此采用分页的方式来进行列表数据。</p>
<h3 id="2-2代码开发"><a href="#2-2代码开发" class="headerlink" title="2.2代码开发"></a>2.2代码开发</h3><p><strong>梳理交互过程</strong></p>
<ol>
<li>页面(backend&#x2F;page&#x2F;combo&#x2F;list.html)发送ajax请求，将分页查询参数(page、pageSize.name)提交到服务端，获取分页数据</li>
<li>页面发送请求，请求服务端进行图片下载，用于页面图片展示</li>
</ol>
<p>开发套餐信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 套餐分页查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> pageSize, String name)</span> &#123;</span><br><span class="line">        <span class="comment">//分页构造器对象</span></span><br><span class="line">        Page&lt;Setmeal&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page,pageSize);</span><br><span class="line">        Page&lt;SetmealDto&gt; dtoPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加查询条件，根据name进行模糊查询</span></span><br><span class="line">        queryWrapper.like(name != <span class="literal">null</span>,Setmeal::getName,name);</span><br><span class="line">        <span class="comment">//添加排序条件，根据更新时间降序排序</span></span><br><span class="line">        queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        setmealService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象拷贝，由于泛型不一致，因此不需要拷贝records</span></span><br><span class="line">        BeanUtils.copyProperties(pageInfo,dtoPage,<span class="string">&quot;records&quot;</span>);</span><br><span class="line">        List&lt;Setmeal&gt; records = pageInfo.getRecords();</span><br><span class="line"></span><br><span class="line">        List&lt;SetmealDto&gt; list = records.stream().map((item) -&gt; &#123;</span><br><span class="line">            <span class="type">SetmealDto</span> <span class="variable">setmealDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetmealDto</span>();</span><br><span class="line">            BeanUtils.copyProperties(item,setmealDto);</span><br><span class="line">            <span class="comment">//分类id</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">categoryId</span> <span class="operator">=</span> item.getCategoryId();</span><br><span class="line">            <span class="comment">//根据分类id查询分类对象</span></span><br><span class="line">            <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> categoryService.getById(categoryId);</span><br><span class="line">            <span class="keyword">if</span> (category != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//分类名称</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">categoryName</span> <span class="operator">=</span> category.getName();</span><br><span class="line">                setmealDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> setmealDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        dtoPage.setRecords(list);</span><br><span class="line">        <span class="keyword">return</span> R.success(dtoPage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3功能测试"><a href="#2-3功能测试" class="headerlink" title="2.3功能测试"></a>2.3功能测试</h3><p>测试分页查询功能是否正常</p>
<h2 id="三、删除套餐"><a href="#三、删除套餐" class="headerlink" title="三、删除套餐"></a>三、删除套餐</h2><h3 id="3-1需求分析-3"><a href="#3-1需求分析-3" class="headerlink" title="3.1需求分析"></a>3.1需求分析</h3><p>在套餐管理列表页面点击删除按钮，可以删除对应的套餐信息。也可以通过复选框选择多个套餐，点击批量删除按钮一次删除多个套餐。注意，对于状态为售卖中的套餐不能删除，需要先停售，然后才能删除。</p>
<h3 id="3-2代码开发-2"><a href="#3-2代码开发-2" class="headerlink" title="3.2代码开发"></a>3.2代码开发</h3><p><strong>梳理删除套餐时前端页面和服务端的交互过程</strong></p>
<ul>
<li><p>删除单个套餐时，页面发送ajax请求，根据套餐id删除对应套餐</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230128101150436.png" alt="image-20230128101150436"></p>
</li>
<li><p>删除多个套餐时，页面发送ajax请求，根据提交的多个套餐id删除对应套餐</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230128101234984.png" alt="image-20230128101234984"></p>
</li>
</ul>
<p>开发删除套餐功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可</p>
<p>观察删除单个套餐和批量删除套餐的请求信息可以发现，两种请求的<strong>地址</strong>和<strong>请求方式</strong>都是相同的，不同的则是传递的id个数，所以在服务端可以提供一个方法来统一处理。</p>
<p><code>Controller</code>层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除套餐</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@DeleteMapping</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">       setmealService.removeWithDish(ids);</span><br><span class="line">       <span class="keyword">return</span> R.success(<span class="string">&quot;套餐数据删除成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>Service</code>层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除套餐，同时删除套餐和菜品的关联关系</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeWithDish</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">       <span class="comment">//先来查询套餐状态，确定是否可以删除</span></span><br><span class="line">       <span class="comment">//select count(*) from setmeal where id in(1,2,3) and status = 1</span></span><br><span class="line">       LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.in(Setmeal::getId,ids);</span><br><span class="line">       queryWrapper.eq(Setmeal::getStatus,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count(queryWrapper);</span><br><span class="line">       <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//如果不能删除，抛出一个业务异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;套餐正在售卖中，不能删除&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果可以删除，先删除套餐表中的数据——setmeal</span></span><br><span class="line">       <span class="built_in">this</span>.removeByIds(ids);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//删除关系表中的数据——setmeal_dish</span></span><br><span class="line">       <span class="comment">//delete from setmeal_dish where setmeal_id in(1,2,3)</span></span><br><span class="line">       LambdaQueryWrapper&lt;SetmealDish&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       lambdaQueryWrapper.in(SetmealDish::getId,ids);</span><br><span class="line"></span><br><span class="line">       setmealDishService.remove(lambdaQueryWrapper);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3功能测试-2"><a href="#3-3功能测试-2" class="headerlink" title="3.3功能测试"></a>3.3功能测试</h3><h2 id="四、套餐的启售停售"><a href="#四、套餐的启售停售" class="headerlink" title="四、套餐的启售停售"></a>四、套餐的启售停售</h2><h3 id="4-1需求分析-3"><a href="#4-1需求分析-3" class="headerlink" title="4.1需求分析"></a>4.1需求分析</h3><p>当菜品处于启售状态的时候，页面上按钮显示为停售；当菜品处于停售状态的时候，页面上按钮显示为启售，点击之后状态进行更改。</p>
<h3 id="4-2代码开发-3"><a href="#4-2代码开发-3" class="headerlink" title="4.2代码开发"></a>4.2代码开发</h3><p>代码和菜品的启售停售类似</p>
<p><code>Controller</code>层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 批量更新启售停售</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> st</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/status/&#123;st&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">setStatus</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> st, String ids)</span>&#123;</span><br><span class="line">       <span class="comment">//处理string 转成Long</span></span><br><span class="line">       String[] split = ids.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">       List&lt;Long&gt; idList = Arrays.stream(split).map(s -&gt; Long.parseLong(s.trim())).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//将每个id new出来一个Setmeal对象，并设置状态</span></span><br><span class="line">       List&lt;Setmeal&gt; setmeals = idList.stream().map((item) -&gt; &#123;</span><br><span class="line">           <span class="type">Setmeal</span> <span class="variable">setmeal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Setmeal</span>();</span><br><span class="line">           setmeal.setId(item);</span><br><span class="line">           setmeal.setStatus(st);</span><br><span class="line">           <span class="keyword">return</span> setmeal;</span><br><span class="line">       &#125;).collect(Collectors.toList()); <span class="comment">//Dish集合</span></span><br><span class="line"></span><br><span class="line">       log.info(<span class="string">&quot;status ids : &#123;&#125;&quot;</span>,ids);</span><br><span class="line">       setmealService.updateBatchById(setmeals);<span class="comment">//批量操作</span></span><br><span class="line">       <span class="keyword">return</span> R.success(<span class="string">&quot;操作成功&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3功能测试-3"><a href="#4-3功能测试-3" class="headerlink" title="4.3功能测试"></a>4.3功能测试</h3><h1 id="业务开发——手机验证码"><a href="#业务开发——手机验证码" class="headerlink" title="业务开发——手机验证码"></a>业务开发——手机验证码</h1><h2 id="一、短信发送"><a href="#一、短信发送" class="headerlink" title="一、短信发送"></a>一、短信发送</h2><h3 id="1-1短信服务介绍"><a href="#1-1短信服务介绍" class="headerlink" title="1.1短信服务介绍"></a>1.1短信服务介绍</h3><p>目前市面上有很多第三方提供的短信服务，这些第三方短信服务会和各个运营商(移动、联通、电信)对接，我们只需要注册成为会员并且按照提供的开发文档进行调用就可以发送短信。需要说明的是，这些短信服务一般都是收费服务。</p>
<p>常用短信服务:</p>
<ul>
<li>阿里云</li>
<li>华为云</li>
<li>腾讯云</li>
<li>京东</li>
<li>梦网</li>
<li>乐信</li>
</ul>
<h3 id="1-2阿里云短信服务"><a href="#1-2阿里云短信服务" class="headerlink" title="1.2阿里云短信服务"></a>1.2阿里云短信服务</h3><p>阿里云短信服务(Short Message Service)是广大企业客户快速触达手机用户所优选使用的通信能力。调用API或用群发助手，即可发送验证码、通知类和营销类短信;国内验证短信秒级触达，到达率最高可达99%，国际&#x2F;港澳台短信覆盖200多个国家和地区，安全稳定，广受出海企业选用。</p>
<p>应用场景:</p>
<ul>
<li>验证码</li>
<li>短信通知</li>
<li>推广短信</li>
</ul>
<p><strong>注册账号</strong></p>
<p>阿里云官网：<a href="https://www.aliyun.com/">https://www.aliyun.com/</a></p>
<p>注册账号之后<strong>设置短信签名</strong>，短信签名指的是短信发送者的署名，表示发送者身份</p>
<p><strong>模板管理</strong></p>
<h3 id="1-3代码开发-1"><a href="#1-3代码开发-1" class="headerlink" title="1.3代码开发"></a>1.3代码开发</h3><p>使用阿里云短信服务发送短信，可以参照官方文档即可</p>
<p>具体开发步骤：</p>
<ol>
<li><p>导入maven坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--阿里云短信服务--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-dysmsapi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用API</p>
<ul>
<li>项目资料中已经创建好了 <code>SMSUtils</code></li>
</ul>
</li>
</ol>
<h2 id="二、手机验证码登录"><a href="#二、手机验证码登录" class="headerlink" title="二、手机验证码登录"></a>二、手机验证码登录</h2><h3 id="2-1需求分析-3"><a href="#2-1需求分析-3" class="headerlink" title="2.1需求分析"></a>2.1需求分析</h3><p>为了方便用户登录，移动端通常都会提供通过手机验证码登录的功能</p>
<p><strong>手机验证码登录的优点</strong></p>
<ul>
<li>方便快捷，无需注册，直接登录</li>
<li>使用短信验证码作为登录凭证，无需记忆密码</li>
<li>安全</li>
</ul>
<p><strong>登录流程</strong></p>
<p>输入手机号&gt;获取验证码&gt;输入验证码&gt;点击登录&gt;登录成功</p>
<p><strong>注意</strong>:通过手机验证码登录，手机号是区分不同用户的标识。</p>
<h3 id="2-2数据模型-2"><a href="#2-2数据模型-2" class="headerlink" title="2.2数据模型"></a>2.2数据模型</h3><p>通过手机验证码登录时，涉及的表为<code>user</code>，即用户表。表结构如下：</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230128181306151.png" alt="image-20230128181306151"></p>
<h3 id="2-3代码开发-2"><a href="#2-3代码开发-2" class="headerlink" title="2.3代码开发"></a>2.3代码开发</h3><p>在开发代码之前，需要梳理一下登录时前端页面和服务端的<strong>交互过程</strong></p>
<ol>
<li>在登录页面(front&#x2F;page&#x2F;login.html)输入手机号，点击 <strong>[获取验证码]</strong> 按钮，页面发送ajax请求，在服务端调用短信服务API给指定手机号发送验证码短信</li>
<li>在登录页面输入验证码，点击**[登录]** 按钮，发送ajax请求，在服务端处理登录请求</li>
</ol>
<p>开发手机验证码登录功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可</p>
<p><strong>开发代码前的准备工作：</strong></p>
<p>在开发业务功能前，先将需要用到的类和接口基本结构创建好</p>
<ul>
<li>实体类 <code>User</code> (直接从课程资料中导入即可)</li>
<li><code>Mapper</code>接口 <code>UserMapper</code></li>
<li>业务层接口 <code>UserService</code></li>
<li>业务层实现类  <code>UserServicelmpl</code></li>
<li>控制层 <code>UserController</code></li>
<li>工具类<code>SMSUtils</code>、<code>ValidateCodeUtils</code> (直接从课程资料中导入即可)</li>
</ul>
<p><strong>修改<code>LoginCheckFilter</code>过滤器：</strong></p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230128202347907.png" alt="image-20230128202347907"></p>
<p><strong>在<code>LoginCheckFilter</code>中扩展逻辑，修改移动端的用户登录状态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4-2、判断登录状态，如果已登录，则直接放行</span></span><br><span class="line"><span class="keyword">if</span>(request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">    log.info(<span class="string">&quot;用户已登录，用户id为：&#123;&#125;&quot;</span>,request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> (Long) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    BaseContext.setCurrentId(userId);</span><br><span class="line"></span><br><span class="line">    filterChain.doFilter(request,response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>资料中给的前端代码有问题，在使用移动端发送**<code>发送验证码</code>**请求的时候，页面直接填充验证码，不发请求，解决办法参照<a href="https://blog.csdn.net/qq_39123467/article/details/127066612">这里</a></li>
</ul>
<p><strong>发送验证码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送手机短信验证码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sendMsg&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestBody</span> User user, HttpSession session)</span>&#123;</span><br><span class="line">        <span class="comment">//获取手机号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> user.getPhone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(phone))&#123;</span><br><span class="line">            <span class="comment">//生成随机的4位验证码</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> ValidateCodeUtils.generateValidateCode(<span class="number">4</span>).toString();</span><br><span class="line">            log.info(<span class="string">&quot;code=&#123;&#125;&quot;</span>,code);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用阿里云提供的短信服务API完成发送短信</span></span><br><span class="line">            <span class="comment">//SMSUtils.sendMessage(&quot;瑞吉外卖&quot;,&quot;&quot;,phone,code);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要将生成的验证码保存到Session</span></span><br><span class="line">            session.setAttribute(phone,code);</span><br><span class="line"><span class="comment">//            session.setAttribute(&quot;code&quot;,code);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> R.success(<span class="string">&quot;手机验证码短信发送成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.error(<span class="string">&quot;短信发送失败&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>登录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 移动端用户登录</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;User&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> Map map, HttpSession session)</span>&#123;</span><br><span class="line">       log.info(map.toString());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取手机号</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> map.get(<span class="string">&quot;phone&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取验证码</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> map.get(<span class="string">&quot;code&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//从Session中获取保存的验证码</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">codeInSession</span> <span class="operator">=</span> session.getAttribute(phone);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//进行验证码的比对（页面提交的验证码和Session中保存的验证码比对）</span></span><br><span class="line">       <span class="keyword">if</span>(codeInSession != <span class="literal">null</span> &amp;&amp; codeInSession.equals(code))&#123;</span><br><span class="line">           <span class="comment">//如果能够比对成功，说明登录成功</span></span><br><span class="line"></span><br><span class="line">           LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">           queryWrapper.eq(User::getPhone,phone);</span><br><span class="line"></span><br><span class="line">           <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getOne(queryWrapper);</span><br><span class="line">           <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//判断当前手机号对应的用户是否为新用户，如果是新用户就自动完成注册</span></span><br><span class="line">               user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">               user.setPhone(phone);</span><br><span class="line">               user.setStatus(<span class="number">1</span>);</span><br><span class="line">               userService.save(user);</span><br><span class="line">           &#125;</span><br><span class="line">           session.setAttribute(<span class="string">&quot;user&quot;</span>,user.getId());</span><br><span class="line">           <span class="keyword">return</span> R.success(user);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> R.error(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4功能测试-2"><a href="#2-4功能测试-2" class="headerlink" title="2.4功能测试"></a>2.4功能测试</h3><h1 id="业务开发——移动端开发"><a href="#业务开发——移动端开发" class="headerlink" title="业务开发——移动端开发"></a>业务开发——移动端开发</h1><h2 id="一、导入用户地址簿"><a href="#一、导入用户地址簿" class="headerlink" title="一、导入用户地址簿"></a>一、导入用户地址簿</h2><h3 id="1-1需求分析-1"><a href="#1-1需求分析-1" class="headerlink" title="1.1需求分析"></a>1.1需求分析</h3><p>地址簿，指的是移动端消费者用户的地址信息，用户登录成功之后可以维护自己的地址信息。同一个用户可以有多个地址信息，但是只有一个<strong>默认地址</strong>。</p>
<p>可以完成功能有</p>
<ul>
<li>保存地址</li>
<li>设置为默认地址</li>
<li>新增地址或者删除地址</li>
</ul>
<h3 id="1-2数据模型-1"><a href="#1-2数据模型-1" class="headerlink" title="1.2数据模型"></a>1.2数据模型</h3><p>用户的地址信息会存储在<code>address_book</code>表，即地址簿表中，具体表结构如下：</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230129082947113.png" alt="image-20230129082947113"></p>
<h3 id="1-3导入功能代码"><a href="#1-3导入功能代码" class="headerlink" title="1.3导入功能代码"></a>1.3导入功能代码</h3><p>功能代码清单:</p>
<ul>
<li>实体类 <code>AddressBook</code>(直接从课程资料中导入即可)</li>
<li><code>Mapper</code>接口 <code>AddressBookMapper</code></li>
<li>业务层接口 <code>AddressBookService</code></li>
<li>业务层实现类 <code>AddressBookServicelmpl</code></li>
<li>控制层 <code>AddressBookController </code>(直接从课程资料中导入即可）</li>
</ul>
<p>控制层代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址簿管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/addressBook&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressBookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AddressBookService addressBookService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;AddressBook&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> AddressBook addressBook)</span> &#123;</span><br><span class="line">        addressBook.setUserId(BaseContext.getCurrentId());</span><br><span class="line">        log.info(<span class="string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);</span><br><span class="line">        addressBookService.save(addressBook);</span><br><span class="line">        <span class="keyword">return</span> R.success(addressBook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置默认地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/default&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;AddressBook&gt; <span class="title function_">setDefault</span><span class="params">(<span class="meta">@RequestBody</span> AddressBook addressBook)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);</span><br><span class="line">        LambdaUpdateWrapper&lt;AddressBook&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());</span><br><span class="line">        wrapper.set(AddressBook::getIsDefault, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//SQL:update address_book set is_default = 0 where user_id = ?</span></span><br><span class="line">        addressBookService.update(wrapper);</span><br><span class="line"></span><br><span class="line">        addressBook.setIsDefault(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//SQL:update address_book set is_default = 1 where id = ?</span></span><br><span class="line">        addressBookService.updateById(addressBook);</span><br><span class="line">        <span class="keyword">return</span> R.success(addressBook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getById(id);</span><br><span class="line">        <span class="keyword">if</span> (addressBook != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.success(addressBook);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> R.error(<span class="string">&quot;没有找到该对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询默认地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/default&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;AddressBook&gt; <span class="title function_">getDefault</span><span class="params">()</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());</span><br><span class="line">        queryWrapper.eq(AddressBook::getIsDefault, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SQL:select * from address_book where user_id = ? and is_default = 1</span></span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == addressBook) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.error(<span class="string">&quot;没有找到该对象&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> R.success(addressBook);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询指定用户的全部地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;List&lt;AddressBook&gt;&gt; <span class="title function_">list</span><span class="params">(AddressBook addressBook)</span> &#123;</span><br><span class="line">        addressBook.setUserId(BaseContext.getCurrentId());</span><br><span class="line">        log.info(<span class="string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件构造器</span></span><br><span class="line">        LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(<span class="literal">null</span> != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId());</span><br><span class="line">        queryWrapper.orderByDesc(AddressBook::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SQL:select * from address_book where user_id = ? order by update_time desc</span></span><br><span class="line">        <span class="keyword">return</span> R.success(addressBookService.list(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-4功能测试-1"><a href="#1-4功能测试-1" class="headerlink" title="1.4功能测试"></a>1.4功能测试</h3><h2 id="二、菜品展示"><a href="#二、菜品展示" class="headerlink" title="二、菜品展示"></a>二、菜品展示</h2><h3 id="2-1需求分析-4"><a href="#2-1需求分析-4" class="headerlink" title="2.1需求分析"></a>2.1需求分析</h3><p>用户登陆成功后跳转系统首页，在首页需要根据分类来展示菜品和套餐。如果菜品设置了口味信息，需要展示【选择规格】按钮，否则展示【+】按钮</p>
<h3 id="2-2代码开发-1"><a href="#2-2代码开发-1" class="headerlink" title="2.2代码开发"></a>2.2代码开发</h3><p><strong>梳理交互过程</strong></p>
<p>在开发代码之前，需要梳理一下前端页面和服务端的交互过程</p>
<ol>
<li>页面(front&#x2F;index.html)发送ajax请求，获取分类数据 (菜品分类和套餐分类)</li>
<li>页面发送ajax请求，获取第一个分类下的菜品或者套餐</li>
</ol>
<p>开发菜品展示功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<p>注意：首页加载完成后，还发送了一次ajax请求用于加载购物车数据，此处可以将这次请求的地址暂时修改一下，从静态<code>json</code>文件获取数据，等后续开发购物车功能时再修改回来，如下:</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230129094615009.png" alt="image-20230129094615009"></p>
<p><strong>首先在菜品有口味信息的时候，显示按钮为选择规格，因此需要修改<code>DishController</code>中的list方法追加口味信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;List&lt;DishDto&gt;&gt; <span class="title function_">list</span><span class="params">(Dish dish)</span> &#123;</span><br><span class="line">       <span class="comment">//构造查询条件对象</span></span><br><span class="line">       LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.eq(dish.getCategoryId() != <span class="literal">null</span>, Dish::getCategoryId, dish.getCategoryId());</span><br><span class="line">       <span class="comment">//添加条件，查询状态为1（启售）</span></span><br><span class="line">       queryWrapper.eq(Dish::getStatus,<span class="number">1</span>);</span><br><span class="line">       <span class="comment">//添加排序条件</span></span><br><span class="line">       queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">       List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">       List&lt;DishDto&gt; dishDtoList = list.stream().map((item) -&gt; &#123;</span><br><span class="line">           <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishDto</span>();</span><br><span class="line"></span><br><span class="line">           BeanUtils.copyProperties(item,dishDto);</span><br><span class="line"></span><br><span class="line">           <span class="type">Long</span> <span class="variable">categoryId</span> <span class="operator">=</span> item.getCategoryId();<span class="comment">//分类id</span></span><br><span class="line">           <span class="comment">//根据id查询分类对象</span></span><br><span class="line">           <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(category != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">categoryName</span> <span class="operator">=</span> category.getName();</span><br><span class="line">               dishDto.setCategoryName(categoryName);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//当前菜品的id</span></span><br><span class="line">           <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> item.getId();</span><br><span class="line">           LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">           lambdaQueryWrapper.eq(DishFlavor::getDishId,dishId);</span><br><span class="line">           <span class="comment">//select * from dish_flavor where dish_id = ?</span></span><br><span class="line">           List&lt;DishFlavor&gt; dishFlavorList = dishFlavorService.list(lambdaQueryWrapper);</span><br><span class="line">           dishDto.setFlavors(dishFlavorList);</span><br><span class="line">           <span class="keyword">return</span> dishDto;</span><br><span class="line">       &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> R.success(dishDtoList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>此时可以显示菜品相关信息，现在来写显示套餐的相关信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据条件查询套餐数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> setmeal</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;List&lt;Setmeal&gt;&gt; <span class="title function_">list</span><span class="params">(Setmeal setmeal)</span>&#123;</span><br><span class="line">       LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.eq(setmeal.getCategoryId() != <span class="literal">null</span>,Setmeal::getCategoryId,setmeal.getCategoryId());</span><br><span class="line">       queryWrapper.eq(setmeal.getStatus() != <span class="literal">null</span>,Setmeal::getStatus,setmeal.getStatus());</span><br><span class="line">       queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">       List&lt;Setmeal&gt; list = setmealService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> R.success(list);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3功能测试-1"><a href="#2-3功能测试-1" class="headerlink" title="2.3功能测试"></a>2.3功能测试</h3><h2 id="三、购物车"><a href="#三、购物车" class="headerlink" title="三、购物车"></a>三、购物车</h2><h3 id="3-1需求分析-4"><a href="#3-1需求分析-4" class="headerlink" title="3.1需求分析"></a>3.1需求分析</h3><p>移动端用户可以将菜品或者套餐添加到购物车。对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车;对于套餐来说，可以直接点击【+】将当前套餐加入购物车。在购物车中可以修改菜品和套餐的数量也可以清空购物车。</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230129105125929.png" alt="image-20230129105125929"></p>
<h3 id="3-2数据模型-1"><a href="#3-2数据模型-1" class="headerlink" title="3.2数据模型"></a>3.2数据模型</h3><p>购物车对应的数据表为<code>shopping_cart</code>表，具体的表结构为</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230129105944178.png" alt="image-20230129105944178"></p>
<h3 id="3-3代码开发-1"><a href="#3-3代码开发-1" class="headerlink" title="3.3代码开发"></a>3.3代码开发</h3><p>在开发代码之前，需要梳理一下购物车操作时前端页面和服务端的交互过程</p>
<ol>
<li>点击【加入购物车】或者【+】按钮，页面发送ajax请求，请求服务端，将菜品或者套餐添加到购物车</li>
<li>点击购物车图标，页面发送ajax请求，请求服务端查询购物车中的菜品和套餐</li>
<li>点击清空购物车按钮，页面发送ajax请求，请求服务端来执行清空购物车操作</li>
</ol>
<p>开发购物车功能，其实就是在服务端编写代码去处理前端页面发送的这3次请求即可</p>
<p><strong>准备工作</strong></p>
<p>在开发业务功能前，先将需要用到的类和接口基本结构创建好</p>
<ul>
<li>实体类 <code>ShoppingCart</code> (直接从课程资料中导入即可)</li>
<li><code>Mapper</code>接口 <code>ShoppingCartMapper</code></li>
<li>业务层接口 <code>ShoppingCartService</code></li>
<li>业务层实现类 <code>ShoppingCartServicelmpl</code></li>
<li>控制层 <code>ShoppingCartController</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/shoppingCart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCartController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加购物车</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shoppingCart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;ShoppingCart&gt; <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> ShoppingCart shoppingCart)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;购物车数据:&#123;&#125;&quot;</span>,shoppingCart);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置用户id，指定当前是哪个用户的购物车数据</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line">        shoppingCart.setUserId(currentId);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> shoppingCart.getDishId();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,currentId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dishId != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//添加到购物车的是菜品</span></span><br><span class="line">            queryWrapper.eq(ShoppingCart::getDishId,dishId);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//添加到购物车的是套餐</span></span><br><span class="line">            queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询当前菜品或者套餐是否在购物车中</span></span><br><span class="line">        <span class="comment">//SQL:select * from shopping_cart where user_id = ? and dish_id/setmeal_id = ?</span></span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">cartServiceOne</span> <span class="operator">=</span> shoppingCartService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cartServiceOne != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果已经存在，就在原来数量基础上加一</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> cartServiceOne.getNumber();</span><br><span class="line">            cartServiceOne.setNumber(number + <span class="number">1</span>);</span><br><span class="line">            shoppingCartService.updateById(cartServiceOne);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果不存在，则添加到购物车，数量默认就是一</span></span><br><span class="line">            shoppingCart.setNumber(<span class="number">1</span>);</span><br><span class="line">            shoppingCart.setCreateTime(LocalDateTime.now());</span><br><span class="line">            shoppingCartService.save(shoppingCart);</span><br><span class="line">            cartServiceOne = shoppingCart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.success(cartServiceOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看购物车</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;List&lt;ShoppingCart&gt;&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;查看购物车...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());</span><br><span class="line">        queryWrapper.orderByAsc(ShoppingCart::getCreateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;ShoppingCart&gt; list = shoppingCartService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空购物车</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/clean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">clean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//SQL:delete from shopping_cart where user_id = ?</span></span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId, BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">        shoppingCartService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.success(<span class="string">&quot;清空购物车成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4功能测试-1"><a href="#3-4功能测试-1" class="headerlink" title="3.4功能测试"></a>3.4功能测试</h3><h2 id="四、用户下单"><a href="#四、用户下单" class="headerlink" title="四、用户下单"></a>四、用户下单</h2><h3 id="4-1需求分析-4"><a href="#4-1需求分析-4" class="headerlink" title="4.1需求分析"></a>4.1需求分析</h3><p>移动端用户将菜品或者套餐加入到购物车之后，可以点击购物车中的【去结算】按钮，页面跳转到订单确认页面，点击【去支付】按钮完成下单操作。</p>
<ul>
<li>在这里只完成结算显示订单功能，支付需要相关资质才可以，目前不考虑</li>
</ul>
<h3 id="4-2数据模型"><a href="#4-2数据模型" class="headerlink" title="4.2数据模型"></a>4.2数据模型</h3><p>用户下单业务对应的数据表为<code>orders</code>表和<code>order_detail</code>表：</p>
<ul>
<li><p><code>orders</code>表：订单表</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230202164857980.png" alt="image-20230202164857980"></p>
</li>
<li><p><code>order_detail</code>表：订单明细表</p>
<p><img src="/2023/03/09/02-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/image-20230202164654592.png" alt="image-20230202164654592"></p>
<ul>
<li>name指菜品的名字</li>
</ul>
</li>
</ul>
<h3 id="4-3代码开发"><a href="#4-3代码开发" class="headerlink" title="4.3代码开发"></a>4.3代码开发</h3><p><strong>梳理交互过程</strong></p>
<ol>
<li>在购物车中点击【去结算】按钮，页面跳转到订单确认页面</li>
<li>在订单确认页面，发送<code>ajax</code>请求，请求服务端获取当前登录用户的默认地址</li>
<li>在订单确认页面，发送<code>ajax</code>请求，请求服务端获取当前登录用户的购物车数据</li>
<li>在订单确认页面点击【去支付】按钮，发送<code>ajax</code>请求，请求服务端完成下单操作</li>
</ol>
<p>开发用户下单功能，其实就是在服务端编写代码去处理前端页面发送的请求即可</p>
<p><strong>准备工作</strong></p>
<p>在开发业务功能前，先将需要用到的类和接口基本结构创建好：</p>
<ul>
<li>实体类<code>Orders</code>、<code>OrderDetails</code>(直接从课程资料中进行导入)</li>
<li><code>Mapper</code>接口<code>OrderMapper</code>、<code>OrderDetailMappper</code></li>
<li>业务层接口<code>OrderService</code>、<code>OrderDetailService</code></li>
<li>业务层实现类<code>OrderServiceImpl</code>、<code>OrderDetailServiceImpl</code></li>
<li>控制层<code>OrderController</code>、<code>OrderDetailController</code></li>
</ul>
<p><strong>代码实现</strong></p>
<ul>
<li>在<code>OrderController</code>控制层中，将下单操作封装在<code>orderService</code>方法中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户下单功能</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> orders</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">submit</span><span class="params">(<span class="meta">@RequestBody</span> Orders orders)</span> &#123;</span><br><span class="line">       log.info(<span class="string">&quot;订单数据：&#123;&#125;&quot;</span>,orders);</span><br><span class="line">       orderService.submit(orders);</span><br><span class="line">       <span class="keyword">return</span> R.success(<span class="string">&quot;下单成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>OrderService</code>方法中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> AddressBookService addressBookService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OrderDetailService orderDetailService;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户下单</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> orders</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Orders orders)</span> &#123;</span><br><span class="line">       <span class="comment">//首先获取当前用户的id</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//查询当前用户的购物车数据</span></span><br><span class="line">       LambdaQueryWrapper&lt;ShoppingCart&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       wrapper.eq(ShoppingCart::getUserId,userId);</span><br><span class="line">       List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(wrapper);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (shoppingCarts == <span class="literal">null</span> || shoppingCarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;购物车为空，不能下单&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//查询用户数据</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//地址数据</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">addressBookId</span> <span class="operator">=</span> orders.getAddressBookId();</span><br><span class="line">       <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getById(addressBookId);</span><br><span class="line">       <span class="keyword">if</span> (addressBook == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;用户地址信息有误，不能下单&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> IdWorker.getId();<span class="comment">//订单号</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//原子操作，保证多线程也可以计算成功</span></span><br><span class="line">       <span class="type">AtomicInteger</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1.计算总金额 2.订单明细</span></span><br><span class="line">       List&lt;OrderDetail&gt; orderDetails = shoppingCarts.stream().map((item) -&gt; &#123;</span><br><span class="line">           <span class="type">OrderDetail</span> <span class="variable">orderDetail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderDetail</span>();</span><br><span class="line">           orderDetail.setOrderId(orderId);</span><br><span class="line">           orderDetail.setNumber(item.getNumber());</span><br><span class="line">           orderDetail.setDishFlavor(item.getDishFlavor());</span><br><span class="line">           orderDetail.setDishId(item.getDishId());</span><br><span class="line">           orderDetail.setSetmealId(item.getSetmealId());</span><br><span class="line">           orderDetail.setName(item.getName());</span><br><span class="line">           orderDetail.setImage(item.getImage());</span><br><span class="line">           orderDetail.setAmount(item.getAmount());</span><br><span class="line">           amount.addAndGet(item.getAmount().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(item.getNumber())).intValue());</span><br><span class="line">           <span class="keyword">return</span> orderDetail;</span><br><span class="line">       &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       orders.setId(orderId);</span><br><span class="line">       orders.setOrderTime(LocalDateTime.now());</span><br><span class="line">       orders.setCheckoutTime(LocalDateTime.now());</span><br><span class="line">       orders.setStatus(<span class="number">2</span>);</span><br><span class="line">       orders.setAmount(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(amount.get()));<span class="comment">//总金额</span></span><br><span class="line">       orders.setUserId(userId);</span><br><span class="line">       orders.setNumber(String.valueOf(orderId));</span><br><span class="line">       orders.setUserName(user.getName());</span><br><span class="line">       orders.setConsignee(addressBook.getConsignee());</span><br><span class="line">       orders.setPhone(addressBook.getPhone());</span><br><span class="line">       orders.setAddress((addressBook.getProvinceName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getProvinceName())</span><br><span class="line">               + (addressBook.getCityName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getCityName())</span><br><span class="line">               + (addressBook.getDistrictName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getDistrictName())</span><br><span class="line">               + (addressBook.getDetail() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getDetail()));</span><br><span class="line">       <span class="comment">//向订单表插入数据，一条数据</span></span><br><span class="line">       <span class="built_in">this</span>.save(orders);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//向订单明细表插入数据，多条数据</span></span><br><span class="line">       orderDetailService.saveBatch(orderDetails);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//清空购物车数据</span></span><br><span class="line">       shoppingCartService.remove(wrapper);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-4功能测试"><a href="#4-4功能测试" class="headerlink" title="4.4功能测试"></a>4.4功能测试</h3><p>测试功能是否完善</p>
<h1 id="BUG汇总"><a href="#BUG汇总" class="headerlink" title="BUG汇总"></a>BUG汇总</h1><ol>
<li>在2.3.2中对登录功能进行完善的模块，由于后台管理系统和客户端不同时开发的。在开发客户端时，直接将登录过滤器加在了后台系统的后面。这就导致如果用户进行了登录，那么它也可以不登录即访问后台管理系统。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>瑞吉外卖项目介绍</title>
    <url>/2023/03/09/01-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="瑞吉外卖项目介绍"><a href="#瑞吉外卖项目介绍" class="headerlink" title="瑞吉外卖项目介绍"></a>瑞吉外卖项目介绍</h1><h2 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h2><p>本项目(瑞吉外卖)是专门为餐饮企业(餐厅、饭店)定制的一款软件产品，包括系统管理后台和移动端应用两部分。</p>
<p>其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的菜品、套餐、订单等进行管理维护。</p>
<p>移动端应用主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单等。</p>
<p>本项目共分为3期进行开发：</p>
<ul>
<li>第一期主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问。</li>
<li>第二期主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便。</li>
<li>第三期主要针对系统进行优化升级，提高系统的访问性能。</li>
</ul>
<h2 id="二、产品原型"><a href="#二、产品原型" class="headerlink" title="二、产品原型"></a>二、产品原型</h2><p>项目成型前的一个简单的布局框架结构图，将页面的排版布局展现出来，使产品的初步构思有一个可视化的展示。通过原型展示可以更直观了解项目中的需求，当然<strong>产品原型只是一个初步的结构，并不代表最终效果</strong>。</p>
<p>课程资料已经提供了相应的产品原型：</p>
<p><img src="/2023/03/09/01-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/Users\14196\AppData\Roaming\Typora\typora-user-images\image-20230123122028799.png" alt="image-20230123122028799"></p>
<h2 id="三、技术选型"><a href="#三、技术选型" class="headerlink" title="三、技术选型"></a>三、技术选型</h2><p><img src="/2023/03/09/01-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/Users\14196\AppData\Roaming\Typora\typora-user-images\image-20230123122612010.png" alt="image-20230123122612010"></p>
<ul>
<li><p>项目属于前后端分离，前端使用<code>H5</code>页面以及<code>vue</code>框架构建页面，或者使用微信小程序开发。</p>
</li>
<li><p>网关使用的是<code>Nginx</code>代理服务器作为地址的转发，以及集群的<code>Tomcat</code>配置分发。</p>
</li>
<li><p>应用层主要就是使用<code>Spring</code>一系列技术，<code>SpringSession</code>是用来解决集群session共享的问题，数据层使用的<code>MyBatis</code>与数据库交互。</p>
</li>
<li><p>代码管理工具使用的是<code>Git</code>以及<code>Maven</code>仓库</p>
</li>
</ul>
<h2 id="四、功能架构"><a href="#四、功能架构" class="headerlink" title="四、功能架构"></a>四、功能架构</h2><p><img src="/2023/03/09/01-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/Users\14196\AppData\Roaming\Typora\typora-user-images\image-20230123123125891.png" alt="image-20230123123125891"></p>
<p>移动端前台主要是使用H5页面以及微信小程序搭建前端页面，主要功能有：</p>
<ul>
<li>手机号登录</li>
<li>微信登录</li>
<li>历史订单</li>
<li>菜品规格</li>
<li>购物车</li>
<li>下单</li>
<li>菜品浏览</li>
</ul>
<p>系统后台主要实现功能：</p>
<ul>
<li>分类管理</li>
<li>菜品管理</li>
<li>套餐管理</li>
<li>菜品口味管理</li>
<li>员工管理</li>
<li>订单管理</li>
</ul>
<h2 id="五、项目角色"><a href="#五、项目角色" class="headerlink" title="五、项目角色"></a>五、项目角色</h2><p><strong>角色</strong></p>
<ul>
<li>后台系统管理员：登陆后台管理系统，拥有后台系统中所有的权限。</li>
<li>后台普通员：登陆后台管理系统，对菜品、套餐、订单进行管理。</li>
<li>C端用户：登录移动端应用，浏览菜品、添加购物车、设置地址、在线下单。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet的学习</title>
    <url>/2022/12/25/Servlet/</url>
    <content><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h3 id="1-设置编码"><a href="#1-设置编码" class="headerlink" title="1. 设置编码"></a><strong>1. 设置编码</strong></h3><p>​	<strong>tomcat8之前，设置编码：</strong><br>      1)get请求方式：<br>​    		&#x2F;&#x2F;get方式目前不需要设置编码（基于tomcat8）<br>            &#x2F;&#x2F;如果是get请求发送的中文数据，转码稍微有点麻烦（tomcat8之前）<br>​    		String fname &#x3D; request.getParameter(“fname”);<br>​    		&#x2F;&#x2F;1.将字符串打散成字节数组<br>        	byte[] bytes &#x3D; fname.getBytes(“ISO-8859-1”);<br>​    		&#x2F;&#x2F;2.将字节数组按照设定的编码重新组装成字符串<br>​    		fname &#x3D; new String(bytes,”UTF-8”);<br>      2)post请求方式：<br>        	request.setCharacterEncoding(“UTF-8”);<br>​	<strong>tomcat8开始，设置编码，只需要针对post方式</strong><br>​    		request.setCharacterEncoding(“UTF-8”);<br>​	注意：<br>        需要注意的是，<strong>设置编码(post)这一句代码必须在所有的获取参数动作之前</strong></p>
<h3 id="2-Servlet的继承关系"><a href="#2-Servlet的继承关系" class="headerlink" title="2.Servlet的继承关系"></a><strong>2.Servlet的继承关系</strong></h3><p> <strong>- 重点查看的是服务方法（service()）</strong></p>
<ol>
<li><p>继承关系<br>javax.servlet.Servlet接口<br> javax.servlet.GenericServlet抽象类<br>      javax.servlet.http.HttpServlet抽象子类</p>
</li>
<li><p>相关方法<br>javax.servlet.Servlet接口:<br> void init(config) - 初始化方法<br> void service(request,response) - 服务方法<br> void destory() - 销毁方法<br>  javax.servlet.GenericServlet抽象类：<br>void service(request,response) - 仍然是抽象的<br>  javax.servlet.http.HttpServlet 抽象子类：<br>void service(request,response) - 不是抽象的</p>
</li>
<li><p>String method &#x3D; req.getMethod(); 获取请求的方式</p>
</li>
<li><p>各种if判断，根据请求方式不同，决定去调用不同的do方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line"> <span class="built_in">this</span>.doGet(req,resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line"> <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line"> <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在HttpServlet这个抽象类中，do方法都差不多:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> req.getProtocol();</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">    	resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a><strong>3.小结</strong></h3><ol>
<li><p>继承关系： HttpServlet -&gt; GenericServlet -&gt; Servlet</p>
</li>
<li><p>Servlet中的核心方法： init() , service() , destroy()</p>
</li>
<li><p>服务方法：</p>
<p>​    当有请求过来时，service方法会自动响应（其实是tomcat容器调用的）<br>​    在HttpServlet中我们会去分析请求的方式：到底是get、post、head还是delete等等<br>​    然后再决定调用的是哪个do开头的方法<br>​    那么在HttpServlet中这些do方法默认都是405的实现风格-要我们子类去实现对应的方法，否则默认会报405错误</p>
</li>
<li><p>因此，我们在新建Servlet时，我们才会去考虑请求方法，从而决定重写哪个do方法</p>
</li>
</ol>
<h3 id="4-Servlet的生命周期"><a href="#4-Servlet的生命周期" class="headerlink" title="4.Servlet的生命周期"></a><strong>4.Servlet的生命周期</strong></h3><p>1） 生命周期：从出生到死亡的过程就是生命周期。对应Servlet中的三个方法：init(),service(),destroy()<br>2） 默认情况下：<br>           第一次接收请求时，这个Servlet会进行实例化(调用构造方法)、初始化(调用init())、然后服务(调用service())<br>          从第二次请求开始，每一次都是服务<br>          当容器关闭时，其中的所有的servlet实例会被销毁，调用销毁方法<br>3） 通过案例我们发现：</p>
<p>​			Servlet实例tomcat只会创建一个，所有的请求都是这个实例去响应。</p>
<p>​	        第一次请求时，tomcat才会去实例化，初始化，然后再服务。这样的好处是什么？ 提高系统的启动速度 。 这样的缺点是什么？ 第一次请求时，耗时较长。</p>
<p>​		    因此得出结论： 如果需要提高系统的启动速度，当前默认情况就是这样。如果需要提高响应速度，我们应该设置Servlet的初始化时机。<br>4）Servlet的初始化时机：</p>
<p>​    	   默认是第一次接收请求时，实例化，初始化<br>​		   可以通过<load-on-startup>来设置servlet启动的先后顺序,数字越小，启动越靠前，最小值0<br>5） Servlet在容器中是：单例的、线程不安全的</load-on-startup></p>
<pre><code>   单例：所有的请求都是同一个实例去响应
      不安全：一个线程需要根据这个实例中的某个成员变量值去做逻辑判断。但是在中间某个时机，另一个线程改变了这个成员变量的值，从而导致第一个线程的执行路径发生了变化
</code></pre>
<p>​          （线程不安全就是说在一个线程操作的过程中，另一个线程将共享域中的数据做了修改，导致访问结果发生错误的过程；举例来说，一个人去上厕所发现里面有纸，然后他就往里走，这时候有一个人把纸拿走了）</p>
<p><img src="/2022/12/25/Servlet/image-20221225113107433.png" alt="image-20221225113107433">			</p>
<p>我们已经知道了servlet是线程不安全的，给我们的启发是： 尽量的不要在servlet中定义成员变量。如果不得不定义成员变量，那么不要去：①不要去修改成员变量的值 ②不要去根据成员变量的值做一些逻辑判断</p>
<h3 id="5-HTTP协议"><a href="#5-HTTP协议" class="headerlink" title="5.HTTP协议"></a><strong>5.HTTP协议</strong></h3><p>1） Http 称之为 超文本传输协议</p>
<p>2） Http是无状态的</p>
<p>3） Http请求响应包含两个部分：请求和响应</p>
<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a><strong>请求</strong></h4><p>请求包含三个部分： 1.请求行 ； 2.请求消息头 ； 3.请求主体</p>
<p><img src="/2022/12/25/Servlet/image-20221225115248962.png" alt="image-20221225115248962"></p>
<ol>
<li><p><strong>请求行</strong></p>
<p>作用：展示当前请求的最基本信息</p>
<blockquote>
<p>POST &#x2F;dynamic&#x2F;target.jsp HTTP&#x2F;1.1</p>
</blockquote>
<p>包含三个信息： 1. 请求的方式 ； 2.请求的URL ； 3.请求的协议（一般都是HTTP1.1）</p>
</li>
<li><p><strong>请求消息头</strong></p>
<p>包含了很多客户端需要告诉服务器的信息，比如：我的浏览器型号、版本、我能接收的内容的类型、我给你发的内容的类型、内容的长度等等</p>
<p>作用：通过具体的参数对本次请求进行详细的说明</p>
<p>格式：键值对，键和值之间使用冒号隔开</p>
<p>相对比较重要的请求消息头：</p>
<p><img src="/2022/12/25/Servlet/image-20221225115518174.png" alt="image-20221225115518174"></p>
</li>
<li><p><strong>请求体</strong></p>
<p>作用：作为请求的主体，发送数据给服务器。具体来说其实就是POST请求方式下的请求参数。</p>
<p>三种情况：</p>
<ul>
<li>get方式，没有请求体，但是有一个queryString</li>
<li>post方式，有请求体，form data</li>
<li>json格式，有请求体，request payload</li>
</ul>
<p><strong>格式：</strong></p>
<ul>
<li><p><strong>from data</strong></p>
<p>含义：当前请求体是一个表单提交的请求参数。</p>
<p><img src="/2022/12/25/Servlet/image-20221225115805376.png" alt="image-20221225115805376"></p>
<p>查看源码后，发现格式如下：</p>
<blockquote>
<p>username&#x3D;tom&amp;password&#x3D;123456</p>
</blockquote>
<ul>
<li>每一组请求参数是一个键值对</li>
<li>键和值中间是等号</li>
<li>键值对之间是&amp;号</li>
</ul>
</li>
<li><p><strong>Request Payload</strong></p>
<p>含义：整个请求体以某种特定格式来组织数据，例如JSON格式。</p>
<p><img src="/2022/12/25/Servlet/image-20221225115938714.png" alt="image-20221225115938714"></p>
</li>
</ul>
</li>
</ol>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a><strong>响应</strong></h4><p>响应也包含三本： 1. 响应行 ； 2.响应头 ； 3.响应体</p>
<p><img src="/2022/12/25/Servlet/image-20221225120035506.png" alt="image-20221225120035506"></p>
<ol>
<li>响应行包含三个信息：1.协议 2.响应状态码(200) 3.响应状态(ok)</li>
<li>响应头：包含了服务器的信息；服务器发送给浏览器的信息（内容的媒体类型、编码、内容长度等）</li>
<li>响应体：响应的实际内容（比如请求add.html页面时，响应的内容就是<html><head></head><body>&lt;form….）</body></html></li>
</ol>
<p><strong>①响应状态行</strong></p>
<blockquote>
<p>HTTP&#x2F;1.1 200 OK</p>
</blockquote>
<ul>
<li>HTTP协议版本</li>
<li><strong>响应状态码</strong></li>
<li>响应状态的说明文字</li>
</ul>
<p><strong>②响应消息头</strong></p>
<ul>
<li>响应体的说明书。</li>
<li>服务器端对浏览器端设置数据，例如：服务器端返回Cookie信息。</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Type</td>
<td>响应体的内容类型</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的内容长度</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>服务器返回新的Cookie信息给浏览器</td>
</tr>
<tr>
<td>location</td>
<td>在<strong>重定向</strong>的情况下，告诉浏览器访问下一个资源的地址</td>
</tr>
</tbody></table>
<p><strong>③响应体</strong></p>
<p>服务器返回的数据主体，有可能是各种数据类型。</p>
<ul>
<li>HTML页面</li>
<li>图片</li>
<li>视频</li>
<li>以下载形式返回的文件</li>
<li>CSS文件</li>
<li>JavaScript文件</li>
</ul>
<p><strong>④响应状态码</strong></p>
<p>作用：以编码的形式告诉浏览器当前请求处理的结果</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>服务器成功处理了当前请求，成功返回响应</td>
</tr>
<tr>
<td>302</td>
<td>重定向</td>
</tr>
<tr>
<td>400</td>
<td>[SpringMVC特定环境]请求参数问题</td>
</tr>
<tr>
<td>403</td>
<td>没有权限</td>
</tr>
<tr>
<td>404</td>
<td>找不到目标资源</td>
</tr>
<tr>
<td>405</td>
<td>请求方式和服务器端对应的处理方式不一致</td>
</tr>
<tr>
<td>406</td>
<td>[SpringMVC特定环境]请求扩展名和实际返回的响应体类型不一致</td>
</tr>
<tr>
<td>50X</td>
<td>服务器端内部错误，通常都是服务器端抛异常了</td>
</tr>
</tbody></table>
<p>404产生的具体原因：</p>
<ul>
<li>访问地址写错了，确实是没有这个资源</li>
<li>访问了WEB-INF目录下的资源</li>
<li>Web应用启动的时候，控制台已经抛出异常，导致整个Web应用不可用，访问任何资源都是404</li>
<li>服务器端缓存</li>
</ul>
<h3 id="6-Session会话"><a href="#6-Session会话" class="headerlink" title="6.Session会话"></a>6.Session会话</h3><p>1） Http是无状态的</p>
<ul>
<li>HTTP 无状态 ：服务器无法判断这两次请求是同一个客户端发过来的，还是不同的客户端发过来的</li>
<li>无状态带来的现实问题：第一次请求是添加商品到购物车，第二次请求是结账；如果这两次请求服务器无法区分是同一个用户的，那么就会导致混乱</li>
<li>通过会话跟踪技术来解决无状态的问题。</li>
</ul>
<p>2） 会话跟踪技术</p>
<ul>
<li>客户端第一次发请求给服务器，服务器获取session，获取不到，则创建新的，然后响应给客户端</li>
<li>下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到了，那么服务器就判断这一次请求和上次某次请求是同一个客户端，从而能够区分开客户端</li>
</ul>
<p><img src="/2022/12/25/Servlet/image-20221225161046739.png" alt="image-20221225161046739"></p>
<ul>
<li>常用的API：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.getSession() -&gt; 获取当前的会话，没有则创建一个新的会话</span><br><span class="line">request.getSession(true) -&gt; 效果和不带参数相同</span><br><span class="line">request.getSession(false) -&gt; 获取当前会话，没有则返回null，不会创建新的</span><br><span class="line">session.getId() -&gt; 获取sessionID</span><br><span class="line">session.isNew() -&gt; 判断当前session是否是新的</span><br><span class="line">session.getMaxInactiveInterval() -&gt; session的非激活间隔时长，默认1800秒</span><br><span class="line">session.setMaxInactiveInterval()</span><br><span class="line">session.invalidate() -&gt; 强制性让会话立即失效</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>3） session保存作用域</p>
<ul>
<li><p>session保存作用域是和具体的某一个session对应的</p>
<p><img src="/2022/12/25/Servlet/image-20221225164425868.png" alt="image-20221225164425868"></p>
</li>
<li><p>常用的API：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void session.setAttribute(k,v)</span><br><span class="line">Object session.getAttribute(k)</span><br><span class="line">void removeAttribute(k)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-服务器内部转发以及客户端重定向"><a href="#7-服务器内部转发以及客户端重定向" class="headerlink" title="7.服务器内部转发以及客户端重定向"></a>7.服务器内部转发以及客户端重定向</h3><p>1） 服务器内部转发 : request.getRequestDispatcher(“…”).forward(request,response);</p>
<ul>
<li><p>一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的</p>
</li>
<li><p>地址栏没有变化</p>
<p><img src="/2022/12/25/Servlet/image-20221225170624942.png" alt="image-20221225170624942"></p>
</li>
</ul>
<p>2） 客户端重定向： response.sendRedirect(“….”);</p>
<ul>
<li><p>两次请求响应的过程。客户端肯定知道请求URL有变化</p>
</li>
<li><p>地址栏有变化</p>
<p><img src="/2022/12/25/Servlet/image-20221225171039562.png" alt="image-20221225171039562"></p>
</li>
</ul>
<h3 id="8-DispatcherServlet"><a href="#8-DispatcherServlet" class="headerlink" title="8.DispatcherServlet"></a>8.DispatcherServlet</h3><p>首先我们构建的代码结构如图</p>
<p><img src="/2022/12/25/Servlet/image-20230101212049006.png" alt="image-20230101212049006"></p>
<p>如果这样构建servlet的话，结构过于复杂，因此对其进行优化</p>
<p><img src="/2022/12/25/Servlet/image-20230101212503070.png" alt="image-20230101212503070"></p>
<p>如果这样构建servlet，如果还存在与FruitServlet并列的Servlet的话也会产生较为复杂的系统，因此采用一个中央处理器，即DispatcherServlet</p>
<p><img src="/2022/12/25/Servlet/image-20230101212628721.png" alt="image-20230101212628721"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML&amp;CSS&amp;JavaScript</title>
    <url>/2022/12/22/HTML/</url>
    <content><![CDATA[<h1 id="HTML-amp-CSS-amp-JavaScript"><a href="#HTML-amp-CSS-amp-JavaScript" class="headerlink" title="HTML&amp;CSS&amp;JavaScript"></a>HTML&amp;CSS&amp;JavaScript</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)</span><br><span class="line">html语言是解释型语言，不是编译型</span><br><span class="line">浏览器是容错的</span><br><span class="line"></span><br><span class="line">2)</span><br><span class="line">html页面中由一对标签组成：&lt;html&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt; 称之为 开始标签</span><br><span class="line">&lt;/html&gt;称之为 结束标签</span><br><span class="line">3)</span><br><span class="line">title 表示网页的标题</span><br><span class="line">4)</span><br><span class="line">可以在meta标签中设置编码方式</span><br><span class="line">5)</span><br><span class="line">&lt;br/&gt;表示换行 。br标签是一个单标签。单标签：开始标签和结束标签是同一个，斜杠放在单词后面</span><br><span class="line">6)</span><br><span class="line">p 表示段落标签</span><br><span class="line">7)</span><br><span class="line">img 标签图片标签</span><br><span class="line">   src属性表示图片文件的路径</span><br><span class="line">   width和height表示图片的大小</span><br><span class="line">   alt表示图片的提示</span><br><span class="line">8)</span><br><span class="line">路径的问题：</span><br><span class="line">   1. 相对路径</span><br><span class="line">   2. 绝对路径</span><br><span class="line">9)</span><br><span class="line">h1~h6 : 标题标签</span><br><span class="line">10)</span><br><span class="line">列表标签:</span><br><span class="line">- ol 有序列表</span><br><span class="line">   start 表示从*开始，type 显示的类型：A a I i 1(deafult)</span><br><span class="line">- ul 无序列表</span><br><span class="line">   type disc(default) , circle , square</span><br><span class="line">11) u 下划线 b 粗体  i 斜体</span><br><span class="line"></span><br><span class="line">12) 上标 sup   下标 sub</span><br><span class="line"></span><br><span class="line">13) HTML中的实体： 小于号 &amp;lt; 大于等于号 &amp;ge; 版权 &amp;copy;</span><br><span class="line"></span><br><span class="line">14) span 不换行的块标记，可以对这一块进行特殊的修饰处理</span><br><span class="line"></span><br><span class="line">15) a 表示超链接</span><br><span class="line">      href 链接的地址</span><br><span class="line">      target:</span><br><span class="line">         _self 在本窗口打开</span><br><span class="line">         _blank 在一个新窗口打开</span><br><span class="line">         _parent 在父窗口打开</span><br><span class="line">         _top  在顶层窗口打开</span><br><span class="line"></span><br><span class="line">16) div 层</span><br><span class="line"></span><br><span class="line">17) 表格	table</span><br><span class="line">	行		tr</span><br><span class="line">	列		td</span><br><span class="line">	表头列	th</span><br><span class="line"></span><br><span class="line">	table中有如下属性（虽然已经淘汰，但是最好了解一下）</span><br><span class="line">	- border：表格边框的粗细</span><br><span class="line">	- width:表格的宽度</span><br><span class="line">	- cellspacing：单元格间距</span><br><span class="line">	- cellpadding：单元格填充</span><br><span class="line"></span><br><span class="line">	tr中有一个属性： align -&gt; center , left , right </span><br><span class="line"></span><br><span class="line">	rowspan : 行合并</span><br><span class="line">	colspan : 列合并</span><br><span class="line"></span><br><span class="line">18) 表单	form </span><br><span class="line">	action:可以实现点击跳转的功能  method:post、get、put、delete</span><br><span class="line">	</span><br><span class="line">19) input type=&quot;text&quot; 表示文本框 ， 其中 name属性必须要指定，否则这个文本框的数据将来是不会发送给服务器的</span><br><span class="line">	input type=&quot;password&quot; 表示密码框</span><br><span class="line">	input type=&quot;radio&quot; 表示单选按钮。需要注意的是，name属性值保持一致，这样才会有互斥的效果;可以通过checked属性设置默认选中的项</span><br><span class="line">	input type=&quot;checkbox&quot; 表示复选框。name属性值建议保持一致，这样将来我们服务器端获取值的时候获取的是一个数组;可以通过checked属性设置默认选中的项</span><br><span class="line">	select 表示下拉列表。每一个选项是option，其中value属性是发送给服务器的值, selected表示默认选中的项</span><br><span class="line">	textarea 表示多行文本框（或者称之为文本域）,它的value值就是开始结束标签之间的内容</span><br><span class="line">	input type=&quot;submit&quot; 表示提交按钮</span><br><span class="line">	input type=&quot;reset&quot; 表示重置按钮</span><br><span class="line">	input type=&quot;button&quot; 表示普通按钮</span><br><span class="line">	</span><br><span class="line">frameset 表示页面框架 ， 这个标签已经淘汰，了解，不需要掌握</span><br><span class="line">frame表示框架中的具体页面引用</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">1.HTML是解释型的文本标记语言，不区分大小写</span><br><span class="line">2.html,head,title,meta,body,br,p,hr,div,table,form,u,i,b,sup,sub,&amp;nbsp;,span,ul,ol,li,tr,td,th,h1-h6,a,input,select,textarea,img</span><br><span class="line">2-1. html , head , title , meta , body , br , ul , ol , h1-h6 , a , img , &amp;nbsp;, p , div , span</span><br><span class="line">2-2. table tr , th , td </span><br><span class="line">2-3. form(action=&#x27;&#x27; , method=&#x27;post&#x27;) input type=&#x27;text,pasword,radio,checkbox,submit,button,reset&quot;   &lt;select&gt; , &lt;textarea&gt;</span><br></pre></td></tr></table></figure>

<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"><span class="comment">/* 被style标签包围的范围是CSS环境，可以写CSS代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标签样式表 */</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类样式 */</span></span><br><span class="line"><span class="selector-class">.f20</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;!-- 引用外部的CSS样式表文件 --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/demo01<span class="selector-class">.css</span>&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IE浏览器：实际尺寸 = <span class="attribute">width</span></span><br><span class="line">chrome浏览器：实际尺寸= <span class="attribute">width</span>+左右borderwidth+<span class="attribute">padding</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CSS盒子模型：</span><br><span class="line"><span class="number">1</span><span class="selector-class">.border</span> 边框</span><br><span class="line"><span class="number">2</span><span class="selector-class">.margin</span> 间距</span><br><span class="line"><span class="number">3</span><span class="selector-class">.padding</span> 填充</span><br><span class="line"></span><br><span class="line"><span class="attribute">position</span>: absolute -- 绝对定位 , 需要配合使用 left , top</span><br><span class="line">		  relative -- 相对定位 , 一般会和 float , margin , padding .... 一起使用</span><br><span class="line"></span><br><span class="line">float </span><br></pre></td></tr></table></figure>

<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Javascript : 客户端的一个脚本语言</span><br><span class="line">js是一门弱类型的语言 , 变量的数据类型由后面赋的值的类型决定</span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次实验准备工作</title>
    <url>/2022/11/30/first-experiment/</url>
    <content><![CDATA[<hr>
<h1 id="第一次实验的准备工作"><a href="#第一次实验的准备工作" class="headerlink" title="第一次实验的准备工作"></a>第一次实验的准备工作</h1><h3 id="实验项目流程图"><a href="#实验项目流程图" class="headerlink" title="实验项目流程图"></a>实验项目流程图</h3><p><img src="/2022/11/30/first-experiment/image-20221130215616849.png" alt="image-20221130215616849"></p>
<ul>
<li>DPD：预失真</li>
<li>PA：功率放大器</li>
<li>AWG：随机信号发生器，用于密集光梳的产生</li>
<li>PD：电光探测器</li>
</ul>
<h3 id="双光梳的产生"><a href="#双光梳的产生" class="headerlink" title="双光梳的产生"></a>双光梳的产生</h3><h4 id="DD-MZM产生光梳的方式"><a href="#DD-MZM产生光梳的方式" class="headerlink" title="DD-MZM产生光梳的方式"></a>DD-MZM产生光梳的方式</h4><p><img src="/2022/11/30/first-experiment/image-20221130215905698.png" alt="image-20221130215905698"></p>
<ul>
<li>当满足了特定的关系之后，就能够产生平坦光梳</li>
<li>射频源信号功率太弱，因此需要进行功率放大</li>
<li>由于放大的时候会有失真，就是对不同频率的射频信号放大的倍数不一样，因此需要加入预失真</li>
</ul>
<h4 id="密集光梳的产生方式"><a href="#密集光梳的产生方式" class="headerlink" title="密集光梳的产生方式"></a>密集光梳的产生方式</h4><p><img src="/2022/11/30/first-experiment/image-20221130220423651.png" alt="image-20221130220423651"></p>
<ul>
<li>当密集光梳的带宽和一级调制得到的光梳的梳齿间隔相同的时候，会恰好产生密集光梳</li>
<li>采用强度调制的方式调制到稀疏光梳上就可以</li>
</ul>
<p><img src="/2022/11/30/first-experiment/image-20221130235155833.png" alt="image-20221130235155833"></p>
<p>​		                                  <img src="/2022/11/30/first-experiment/image-20221130221308747.png" alt="image-20221130221308747">    </p>
<p><img src="/2022/11/30/first-experiment/image-20221130221341702.png" alt="image-20221130221341702"></p>
<h3 id="频率测量的方式"><a href="#频率测量的方式" class="headerlink" title="频率测量的方式"></a>频率测量的方式</h3><p><img src="/2022/11/30/first-experiment/image-20221130220810468.png" alt="image-20221130220810468"></p>
<p><img src="/2022/11/30/first-experiment/wps1.jpg" alt="img"></p>
<h3 id="各个硬件设备的使用方式"><a href="#各个硬件设备的使用方式" class="headerlink" title="各个硬件设备的使用方式"></a>各个硬件设备的使用方式</h3><h4 id="DD-MZM"><a href="#DD-MZM" class="headerlink" title="DD-MZM"></a><strong>DD-MZM</strong></h4><p><img src="/2022/11/30/first-experiment/image-20221130222201909.png" alt="image-20221130222201909"></p>
<p>DD-MZM：富士通FTM7937EZ双臂RF驱动, 适用调制格式DPSK&#x2F;NRZ, 马赫泽德调制器,最高速率可达40Gbps; 低电压驱动; C+L波段工作, 高消光比.</p>
<p><img src="/2022/11/30/first-experiment/image-20221130223028921.png" alt="image-20221130223028921"></p>
<h4 id="NKT激光器"><a href="#NKT激光器" class="headerlink" title="NKT激光器"></a><strong>NKT激光器</strong></h4><p><img src="/2022/11/30/first-experiment/image-20221130223628606.png" alt="image-20221130223628606"></p>
<h4 id="光电探测器"><a href="#光电探测器" class="headerlink" title="光电探测器"></a><strong>光电探测器</strong></h4><p><img src="/2022/11/30/first-experiment/image-20221130223832311.png" alt="image-20221130223832311"></p>
<p>索拉博平衡光电探测器</p>
<p>Thorlabs PDB48xC-AC Balanced Amplified Photodetectors consist of two well-matched, fiber coupled photodiodes with length matched fibers and an ultra-low noise, ultra-low distortion high-speed transimpedance amplifier that generates an output voltage (RF OUTPUT) proportional to the difference between the photo current in the two photodiodes, i.e. the two optical input signals. Additionally, the unit has two fast monitor outputs (MONITOR+ and MONITOR-) to measure the individual optical input power level as well as low frequency (up to 3 MHz) modulated signals on each detector separately.</p>
<p>An adapter for post mounting can be attached to the bottom or side surface of the PDB48xC-AC housing. This adapter supports #8-32 as well as M4 post mounts. The PDB48xC-AC is supplied with an external linear power supply.</p>
<p><strong>翻译</strong>：</p>
<p>Thorlabs PDB48xC-AC平衡放大光电探测器由两个匹配良好的光纤耦合光电二极管和一个超低噪声、超低失真高速跨阻放大器组成，该放大器产生的输出电压(RF output)与两个光电二极管中的光电流之差成正比，即两个光输入信号。此外，该单元有两个快速监视器输出(monitor +和monitor -)，分别测量单个光输入功率水平以及每个检测器上的低频(高达3 MHz)调制信号。</p>
<p>一个用于安装的适配器可以连接到PDB48xC-AC外壳的底部或侧面。这个适配器支持#8-32以及M4后安装。PDB48xC-AC提供外部线性电源。</p>
<p><img src="/2022/11/30/first-experiment/image-20221130231440806.png" alt="image-20221130231440806"></p>
<ul>
<li><p>光电二极管的损坏阈值为 10 mW （PDB480C-AC） 或 5 mW （PDB481C-交流）！超过此值将永久损坏探测器！</p>
</li>
<li><p>个人理解就是，在一定波长范围内的光，输入到光电探测器之中，然后光电探测器会输出显示在电压上面；在调制频率范围的都可以输出</p>
</li>
</ul>
<p><img src="/2022/11/30/first-experiment/image-20221130233636207.png" alt="image-20221130233636207"></p>
<ul>
<li>PD的适配器</li>
</ul>
<h4 id="功率放大器"><a href="#功率放大器" class="headerlink" title="功率放大器"></a><strong>功率放大器</strong></h4><p><img src="/2022/11/30/first-experiment/image-20221130234046217.png" alt="image-20221130234046217"></p>
<p><img src="/2022/11/30/first-experiment/image-20221130234353704.png" alt="image-20221130234353704"></p>
<p><img src="/2022/11/30/first-experiment/image-20221130234459252.png" alt="image-20221130234459252"></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL复习</title>
    <url>/2022/11/20/SQL/</url>
    <content><![CDATA[<h1 id="MySQL复习"><a href="#MySQL复习" class="headerlink" title="MySQL复习"></a>MySQL复习</h1><p><strong>基础知识：</strong></p>
<ul>
<li><strong>DUAL</strong>: 伪表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span><span class="operator">+</span><span class="number">1</span>,<span class="number">3</span> <span class="operator">*</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL; #dual:伪表</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>AS</strong>:全称：alias(别名)，可以省略</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id emp_id,last_name <span class="keyword">AS</span> lname</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DISTINCT</strong>:去除重复项</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>IFNULL(value,c)</strong>:解决空值影响，如果不为空，那么就取value值，否则为常数c</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, salary &quot;月工资&quot;, salary <span class="operator">*</span> (<span class="number">1</span> <span class="operator">+</span> IFNULL(commission_pct,<span class="number">0</span>)) <span class="operator">*</span> <span class="number">12</span> &quot;年工资&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>运算符：</strong></p>
<ol>
<li><p>算数运算符</p>
<ol>
<li><p>在SQL中，+ 没有连接的作用，就表示加法运算。此时会将字符串转换为数值（隐式转换）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span> <span class="operator">+</span> <span class="string">&#x27;1&#x27;</span> # 在Java中，结果为：<span class="number">1001</span>。</span><br><span class="line"><span class="keyword">FROM</span> DUAL</span><br></pre></td></tr></table></figure>
</li>
<li><p>在SQL中，字符在加法中表示 0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span> <span class="operator">+</span> <span class="string">&#x27;a&#x27;</span> # 此时将a看为<span class="number">0</span>来进行运算</span><br><span class="line"><span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算中NULL的情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span> <span class="operator">+</span> <span class="keyword">NULL</span> # <span class="keyword">null</span>参与运算则结果为<span class="keyword">null</span></span><br><span class="line"><span class="number">100</span> DIV <span class="number">0</span> # 分母如果为<span class="number">0</span>，结果为<span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>比较运算符 &#x3D;   &lt;&#x3D;&gt;   &lt;&gt;   !&#x3D;   &lt;   &lt;&#x3D;   &gt;    &gt;&#x3D;</p>
<ul>
<li>注意：&lt;&#x3D;&gt;:安全等于.记忆技巧：为null而生，有null时结果不为null</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NULL</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>, <span class="number">1</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL; #<span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊运算符</p>
<ul>
<li><p>IS NULL \ IS NOT NULL \ ISNULL</p>
</li>
<li><p>LEAST   \   GREATEST</p>
</li>
<li><p>BETWEEN 条件下界 AND 条件上界（包含边界）</p>
</li>
<li><p>IN (set)  \   NOT IN(set)</p>
</li>
<li><p>LIKE:模糊查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;#包含a的名字</span><br><span class="line"></span><br><span class="line"># 查询第二个字符为_且第<span class="number">3</span>个字符为<span class="string">&#x27;a&#x27;</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_\_a%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>REGEXP \ RLIKE : 正则表达式</p>
<ul>
<li>^ 表示以什么为开头</li>
<li>$ 表示以什么为结束</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑运算符： OR ||    AND &amp;&amp;   NOT   ! XOR（异或）</p>
</li>
<li><p>位运算符： &amp; |  ^  ~  &gt;&gt;   &lt;&lt;</p>
<ul>
<li>^ 异或</li>
<li>~ 取反</li>
</ul>
</li>
</ol>
<hr>
<p><strong>排序：</strong></p>
<ul>
<li>使用ORDER BY对查询到的数据进行排序操作</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#升序操作：<span class="keyword">ASC</span>(ascend)</span><br><span class="line">#降序操作：<span class="keyword">DESC</span>(descend)</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：</p>
<ul>
<li><p>可以利用列的别名进行排序</p>
</li>
<li><p>可以进行二级排序，按照声明的顺序进行排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#练习：显示员工信息，按照department_id的降序排列，salary的升序排列</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">DESC</span>,salary <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>别名只能在ORDER BY 中进行使用，不能在WHERE中进行使用<br><strong>原因</strong>：执行顺序是—&gt;先执行WHERE再进行别名操作，最后进行ORDER BY</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>分页：</strong></p>
<ul>
<li>MySQL使用 limit 来实现数据的分页</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#需求：每页显示pageSize条记录，此时显示第pageNo页：</span><br><span class="line">#公式：LIMIT (pageNo<span class="number">-1</span>) <span class="operator">*</span> pageSize,pageSize;</span><br><span class="line"># 每页显示<span class="number">20</span>条记录，此时显示第<span class="number">3</span>页</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">LIMIT <span class="number">40</span>,<span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明顺序：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 声明顺序如下： <span class="keyword">WHERE</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ...LIMIT </span><br><span class="line"># LIMIT的格式： 严格来说：LIMIT 位置偏移量,条目数</span><br><span class="line"># 结构&quot;LIMIT 0,条目数&quot; 等价于 &quot;LIMIT 条目数&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其他特殊操作</p>
<p>如果表里有107条数据，我们只想要显示第 32、33 条数据怎么办呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">#limit <span class="number">31</span>,<span class="number">2</span>;</span><br><span class="line">LIMIT <span class="number">2</span> <span class="keyword">OFFSET</span> <span class="number">31</span>;</span><br></pre></td></tr></table></figure>

<p>需要查询员工最高工资怎么办呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询员工表中工资最高的员工的信息</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
<p> LIMIT 可以使用在MySQL、PGSQL、MariaDB、SQLite 等数据库中使用，表示分页。</p>
<p>不能使用在SQL Server、DB2、Oracle！</p>
</li>
</ul>
<hr>
<p><strong>多表查询：</strong></p>
<ul>
<li><p>多表查询操作可以在WHERE中进行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.employee_id,dept.department_name,emp.department_id</span><br><span class="line"><span class="keyword">FROM</span> employees emp,departments dept</span><br><span class="line"><span class="keyword">WHERE</span> emp.`department_id` <span class="operator">=</span> dept.department_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多表查询的分类：</p>
<ol>
<li><p>等值连接  vs  非等值连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#非等值连接的例子</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.salary,j.grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e, job_grades j</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="keyword">BETWEEN</span> j.`lowest_sal` <span class="keyword">AND</span> j.`highest_sal`;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自连接  vs  非自连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#自连接的例子：</span><br><span class="line">#练习：查询员工id,员工姓名及其管理者的id和姓名</span><br><span class="line"><span class="keyword">SELECT</span> emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees emp ,employees mgr</span><br><span class="line"><span class="keyword">WHERE</span> emp.`manager_id` <span class="operator">=</span> mgr.`employee_id`;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内连接  vs  外连接</p>
<ul>
<li><p>内连接：合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 两个表不匹配的就被消去了</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="operator">=</span> d.department_id; </span><br></pre></td></tr></table></figure>
</li>
<li><p>外连接：合并具有同一列的两个以上的表的行, 结果集中除了包含一个表与另一个表匹配的行之外，还查询到了左表或右表中不匹配的行。</p>
<ul>
<li><p>外连接的分类：左外连接、右外连接、满外连接</p>
</li>
<li><p>左外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左表中不满足条件的行，这种连接称为左外连接。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure>

<p>右外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回右表中不满足条件的行，这种连接称为右外连接。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>满外连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#满外连接：mysql不支持<span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>UNION  和 UNION ALL的使用</p>
<p>UNION：会执行去重操作</p>
<p>UNION ALL：不会执行去重操作</p>
<p><strong>结论</strong>：如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p>
</li>
<li><p>SQL99语法中关于连接的新特性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">10.</span>SQL99语法的新特性<span class="number">1</span>：自然连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`manager_id` <span class="operator">=</span> d.`manager_id`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">11.</span> SQL99语法的新特性<span class="number">2</span>:<span class="keyword">USING</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">USING</span> (department_id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#拓展：</span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_title,department_name </span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments <span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs </span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id </span><br><span class="line"><span class="keyword">AND</span> employees.job_id <span class="operator">=</span> jobs.job_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>单行函数：</strong></p>
<ul>
<li>包括数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数等，见w3school或者尚硅谷第七章PPT</li>
</ul>
<hr>
<p><strong>聚合函数</strong>:</p>
<ul>
<li>包括求最大值最小值、平均值、计算总数</li>
</ul>
<p>​		GROUP BY：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#结论<span class="number">1</span>：<span class="keyword">SELECT</span>中出现的非组函数的字段必须声明在<span class="keyword">GROUP</span> <span class="keyword">BY</span> 中。</span><br><span class="line">#      反之，<span class="keyword">GROUP</span> <span class="keyword">BY</span>中声明的字段可以不出现在<span class="keyword">SELECT</span>中。</span><br><span class="line">#结论<span class="number">2</span>：<span class="keyword">GROUP</span> <span class="keyword">BY</span> 声明在<span class="keyword">FROM</span>后面、<span class="keyword">WHERE</span>后面，<span class="keyword">ORDER</span> <span class="keyword">BY</span> 前面、LIMIT前面</span><br><span class="line">#结论<span class="number">3</span>：MySQL中<span class="keyword">GROUP</span> <span class="keyword">BY</span>中使用<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>:计算整体的平均</span><br></pre></td></tr></table></figure>

<p>​		HAVING的使用 (作用：用来配合GROUP BY过滤数据的)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary) <span class="operator">&gt;</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>HAVING和WHERE对比</p>
<p>结论：当过滤条件中有聚合函数时，则此过滤条件必须声明在HAVING中。当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE中或HAVING中都可以。但是，建议大家声明在WHERE中。</p>
<ol>
<li>从适用范围上来讲，HAVING的适用范围更广。 </li>
<li>如果过滤条件中没有聚合函数：这种情况下，WHERE的执行效率要高于HAVING</li>
</ol>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">4.</span> <span class="keyword">SQL</span>底层执行原理</span><br><span class="line">#<span class="number">4.1</span> <span class="keyword">SELECT</span> 语句的完整结构</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#sql92语法：</span></span><br><span class="line"><span class="comment">SELECT ....,....,....(存在聚合函数)</span></span><br><span class="line"><span class="comment">FROM ...,....,....</span></span><br><span class="line"><span class="comment">WHERE 多表的连接条件 AND 不包含聚合函数的过滤条件</span></span><br><span class="line"><span class="comment">GROUP BY ...,....</span></span><br><span class="line"><span class="comment">HAVING 包含聚合函数的过滤条件</span></span><br><span class="line"><span class="comment">ORDER BY ....,...(ASC / DESC )</span></span><br><span class="line"><span class="comment">LIMIT ...,....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#sql99语法：</span></span><br><span class="line"><span class="comment">SELECT ....,....,....(存在聚合函数)</span></span><br><span class="line"><span class="comment">FROM ... (LEFT / RIGHT)JOIN ....ON 多表的连接条件 </span></span><br><span class="line"><span class="comment">(LEFT / RIGHT)JOIN ... ON ....</span></span><br><span class="line"><span class="comment">WHERE 不包含聚合函数的过滤条件</span></span><br><span class="line"><span class="comment">GROUP BY ...,....</span></span><br><span class="line"><span class="comment">HAVING 包含聚合函数的过滤条件</span></span><br><span class="line"><span class="comment">ORDER BY ....,...(ASC / DESC )</span></span><br><span class="line"><span class="comment">LIMIT ...,....</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="number">4.2</span> <span class="keyword">SQL</span>语句的执行过程：</span><br><span class="line">#<span class="keyword">FROM</span> ...,...<span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">-</span><span class="operator">&gt;</span> (<span class="keyword">LEFT</span><span class="operator">/</span>RIGNT  <span class="keyword">JOIN</span>) <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">DISTINCT</span> <span class="operator">-</span><span class="operator">&gt;</span> </span><br><span class="line"># <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> LIMIT</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>子查询：</strong></p>
<ul>
<li><p>子查询的引入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>子查询（内查询）在主查询之前一次执行完成。</li>
<li>子查询的结果被主查询（外查询）使用 。</li>
<li>注意事项<ul>
<li>子查询要包含在括号内</li>
<li>将子查询放在比较条件的右侧</li>
<li>单行操作符对应单行子查询，多行操作符对应多行子查询</li>
</ul>
</li>
</ul>
</li>
<li><p>子查询的分类</p>
<ul>
<li><p>单行子查询和多行子查询</p>
<p>单行子查询：	</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, <span class="keyword">CASE</span> department_id </span><br><span class="line">				<span class="keyword">WHEN</span> (<span class="keyword">SELECT</span> department_id</span><br><span class="line">				      <span class="keyword">FROM</span> departments </span><br><span class="line">				      <span class="keyword">WHERE</span> location_id <span class="operator">=</span> <span class="number">1800</span>) <span class="keyword">THEN</span> <span class="string">&#x27;Canada&#x27;</span></span><br><span class="line">				      <span class="keyword">ELSE</span> <span class="string">&#x27;USA&#x27;</span> <span class="keyword">END</span> &quot;location&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>多行子查询：</p>
<p>​	多行子查询的操作符： IN  ANY ALL SOME(同ANY)</p>
<p><img src="/2022/11/20/SQL/image-20221121153248820.png" alt="image-20221121153248820"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, department_id,salary</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  salary <span class="keyword">IN</span></span><br><span class="line">                (<span class="keyword">SELECT</span>   <span class="built_in">MIN</span>(salary)</span><br><span class="line">                 <span class="keyword">FROM</span>     employees</span><br><span class="line">                 <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id); </span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">ANY</span> <span class="operator">/</span> <span class="keyword">ALL</span>:</span><br><span class="line">#题目：返回其它job_id中比job_id为‘IT_PROG’部门某个员工工资低的员工的员工号、</span><br><span class="line">#姓名、job_id 以及salary</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> salary <span class="operator">&lt;</span> <span class="keyword">ANY</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> salary</span><br><span class="line">		<span class="keyword">FROM</span> employees</span><br><span class="line">		<span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">		);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资低的员工的员工号、</span><br><span class="line">#姓名、job_id 以及salary</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> salary <span class="operator">&lt;</span> <span class="keyword">ALL</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> salary</span><br><span class="line">		<span class="keyword">FROM</span> employees</span><br><span class="line">		<span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">		);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结论：在SELECT中，除了GROUP BY 和 LIMIT之外，其他位置都可以声明子查询！</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   SELECT ....,....,....(存在聚合函数)</span></span><br><span class="line"><span class="comment">   FROM ... (LEFT / RIGHT)JOIN ....ON 多表的连接条件 </span></span><br><span class="line"><span class="comment">   (LEFT / RIGHT)JOIN ... ON ....</span></span><br><span class="line"><span class="comment">   WHERE 不包含聚合函数的过滤条件</span></span><br><span class="line"><span class="comment">   GROUP BY ...,....</span></span><br><span class="line"><span class="comment">   HAVING 包含聚合函数的过滤条件</span></span><br><span class="line"><span class="comment">   ORDER BY ....,...(ASC / DESC )</span></span><br><span class="line"><span class="comment">   LIMIT ...,....</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<p><strong>数据处理之增删改</strong></p>
<ul>
<li><p>将查询结果插入到新建的表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp1(id,NAME,salary,hire_date)</span><br><span class="line">#查询语句</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary,hire_date  # 查询的字段一定要与添加到的表的字段一一对应</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="number">70</span>,<span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：emp1表中要添加数据的字段的长度不能低于employees表中查询的字段的长度。如果emp1表中要添加数据的字段的长度低于employees表中查询的字段的长度的话，就有添加不成功的风险。</li>
</ul>
</li>
<li><p>更新数据（或者修改数据）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE .... SET .... WHERE ...</span><br></pre></td></tr></table></figure>

<ul>
<li>可以实现批量修改数据；可以同时修改一条数据的多个字段</li>
</ul>
</li>
<li><p>删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM .... WHERE....</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：</p>
<p>DML操作默认情况下，执行完以后都会自动提交数据。如果希望执行完以后不自动提交数据，则需要使用 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET autocommit = FALSE.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>SQL8新特性：计算列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(</span><br><span class="line">    a <span class="type">INT</span>,</span><br><span class="line">    b <span class="type">INT</span>,</span><br><span class="line">    c <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> (a <span class="operator">+</span> b) VIRTUAL  #字段c即为计算列</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>数据类型：</strong></p>
<ul>
<li>有关数据类型的介绍包括：<ul>
<li>整数类型</li>
<li>浮点类型</li>
<li>定点数类型</li>
<li>位类型</li>
<li>日期与时间类型</li>
<li>文本字符串类型</li>
<li>ENUM枚举类类型</li>
<li>SET类型</li>
<li>二进制字符串类型</li>
<li>JSON类型</li>
<li>空间类型</li>
</ul>
</li>
</ul>
<hr>
<p><strong>约束：</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb的复习</title>
    <url>/2022/11/20/JavaWeb-review/</url>
    <content><![CDATA[<h1 id="JavaWeb的复习"><a href="#JavaWeb的复习" class="headerlink" title="JavaWeb的复习"></a>JavaWeb的复习</h1><p><strong>前言：</strong></p>
<p>在这篇文章之中，主要描述自己认为的重要的知识点和易忘的知识点，可能有些片面或者不足，请多多指教。</p>
<h2 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h2><p><strong>标签：</strong></p>
<ul>
<li>标签的格式：&lt;标签名&gt;封装的数据&lt;&#x2F;标签名&gt;</li>
<li>标签拥有自己的属性<ul>
<li>基本属性：color&#x3D;”red”</li>
<li>事件属性：onclick&#x3D;”alert(‘Hello!’);”</li>
</ul>
</li>
<li>标签的注意事项<ul>
<li>标签不能交叉嵌套</li>
<li>标签必须要正确关闭</li>
<li>标签属性必须有值，属性值必须加引号</li>
<li>注释不能嵌套</li>
</ul>
</li>
<li>常用的标签介绍：<a href="https://www.w3school.com.cn/html/index.asp">w3school</a></li>
</ul>
<p>	</p>
<hr>
<p><strong>表格：</strong></p>
<ul>
<li><p>跨行跨列表格的创建</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!--跨两列--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!--跨两行--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>表单：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">form 标签就是表单</span></span><br><span class="line"><span class="comment">input type=text 是文件输入框 		value 设置默认显示内容</span></span><br><span class="line"><span class="comment">input type=password 是密码输入框  value 设置默认显示内容</span></span><br><span class="line"><span class="comment">input type=radio 是单选框 name 属性可以对其进行分组 checked=&quot;checked&quot;表示默认选中</span></span><br><span class="line"><span class="comment">input type=checkbox 是复选框 	  checked=&quot;checked&quot;表示默认选中</span></span><br><span class="line"><span class="comment">input type=reset 是重置按钮 	     value 属性修改按钮上的文本</span></span><br><span class="line"><span class="comment">input type=submit 是提交按钮 	 value 属性修改按钮上的文本</span></span><br><span class="line"><span class="comment">input type=button 是按钮 		  value 属性修改按钮上的文本</span></span><br><span class="line"><span class="comment">input type=file 是文件上传域</span></span><br><span class="line"><span class="comment">input type=hidden 是隐藏域 当我们要发送某些信息，而这些信息，不需要用户参与，就可以使用隐藏域（提交的时候同时发送给服务器）</span></span><br><span class="line"><span class="comment">select 标签是下拉列表框</span></span><br><span class="line"><span class="comment">option 标签是下拉列表框中的选项 selected=&quot;selected&quot;设置默认选中</span></span><br><span class="line"><span class="comment">textarea 表示多行文本输入框 （起始标签和结束标签中的内容是默认值）</span></span><br><span class="line"><span class="comment">rows 属性设置可以显示几行的高度</span></span><br><span class="line"><span class="comment">cols 属性设置每行可以显示几个字符宽度</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--一些表单提交的细节问题</span></span><br><span class="line"><span class="comment">form 标签是表单标签</span></span><br><span class="line"><span class="comment">action 属性设置提交的服务器地址</span></span><br><span class="line"><span class="comment">method 属性设置提交的方式 GET(默认值)或 POST</span></span><br><span class="line"><span class="comment">表单提交的时候，数据没有发送给服务器的三种情况：</span></span><br><span class="line"><span class="comment">1、表单项没有 name 属性值</span></span><br><span class="line"><span class="comment">2、单选、复选（下拉列表中的 option 标签）都需要添加 value 属性，以便发送给服务器</span></span><br><span class="line"><span class="comment">3、表单项不在提交的 form 标签中</span></span><br><span class="line"><span class="comment">GET 请求的特点是：</span></span><br><span class="line"><span class="comment">1、浏览器地址栏中的地址是：action 属性[+?+请求参数]</span></span><br><span class="line"><span class="comment">请求参数的格式是：name=value&amp;name=value</span></span><br><span class="line"><span class="comment">2、不安全</span></span><br><span class="line"><span class="comment">3、它有数据长度的限制</span></span><br><span class="line"><span class="comment">POST 请求的特点是：</span></span><br><span class="line"><span class="comment">1、浏览器地址栏中只有 action 属性值</span></span><br><span class="line"><span class="comment">2、相对于 GET 请求要安全</span></span><br><span class="line"><span class="comment">3、理论上没有数据长度的限制</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>CSS：</strong></p>
<p>CSS选择器分为以下几种：</p>
<ul>
<li><p>标签名选择器，格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标签名&#123;</span><br><span class="line">	属性：值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>id 选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#id 属性值&#123;</span><br><span class="line">	属性：值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>class选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.class 属性值&#123;</span><br><span class="line">	属性：值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择器 1，选择器 2，选择器 n&#123;</span><br><span class="line">	属性：值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p><strong>JavaScript书写的两种方式：</strong></p>
<ul>
<li><p>在head标签或者body标签中，使用script标签来书写JavaScript代码即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">	<span class="comment">&lt;!-- script 内容 --&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>书写单独的js文件，然后对js文件进行引入即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>变量：</strong></p>
<ul>
<li><p>格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系比较：</p>
<ul>
<li>&#x3D;&#x3D;：表示等于，做的是简单的字面值的比较</li>
<li>&#x3D;&#x3D;&#x3D;：表示全等于，除了比较简单的字面值，也会比较两个变量的类型</li>
</ul>
</li>
<li><p>逻辑运算：</p>
<ul>
<li><p>&amp;&amp;、||、！</p>
</li>
<li><p>运算法则</p>
<ul>
<li><p>&amp;&amp; 且运算。有两种情况：</p>
<ul>
<li>第一种：当表达式全为真的时候。返回最后一个表达式的值。</li>
<li>第二种：当表达式中，有一个为假的时候。返回第一个为假的表达式的值</li>
</ul>
</li>
<li><p>|| 或运算</p>
<ul>
<li>第一种情况：当表达式全为假时，返回最后一个表达式的值</li>
<li>第二种情况：只要有一个表达式为真。就会把回第一个为真的表达式的值</li>
</ul>
</li>
<li><p>&amp;&amp; 与运算 和 ||或运算有短路。短路就是说，当这个&amp;&amp;或||运算有结果了之后 。后面的表达式不再执行</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>数组：</strong></p>
<ul>
<li><p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var 数组名 = []; // 空数组</span><br><span class="line">var 数组名 = [1 , ’abc’ , true]; // 定义数组同时赋值元素</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>函数：</strong></p>
<ul>
<li><p>格式</p>
<ul>
<li>方式一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名(形参列表)&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var 函数名 = function(形参列表) &#123; </span><br><span class="line">	函数体 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 JavaScript 语言中，如何定义带有返回值的函数？</p>
<p>只需要在函数体内<strong>直接使用 return 语句</strong>返回值即可！</p>
</li>
<li><p><strong>注：在 Java 中函数允许重载。但是在 JS 中函数的重载会直接覆盖掉上一次的定义</strong></p>
</li>
<li><p>隐形参数：</p>
<ul>
<li><p>就是在 function 函数中不需要定义，但却可以直接用来获取所有参数的变量。我们管它叫隐形参数。</p>
</li>
<li><p>隐形参数特别像 java 基础的可变长参数一样。public void fun( Object … args );</p>
</li>
<li><p>可变长参数其他是一个数组。那么 js 中的隐形参数也跟 java 的可变长参数一样，操作类似数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a</span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>( <span class="variable language_">arguments</span>.<span class="property">length</span> );<span class="comment">//可看参数个数</span></span><br><span class="line">    <span class="title function_">alert</span>( <span class="variable language_">arguments</span>[<span class="number">0</span>] );</span><br><span class="line">    <span class="title function_">alert</span>( <span class="variable language_">arguments</span>[<span class="number">1</span>] );</span><br><span class="line">    <span class="title function_">alert</span>( <span class="variable language_">arguments</span>[<span class="number">2</span>] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>,<span class="string">&quot;haha&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<p><strong>自定义对象：</strong></p>
<ul>
<li><p>方式一：</p>
<ul>
<li><p>定义的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var 变量名 = new Object(); // 对象实例（空对象）</span><br><span class="line">变量名.属性名 = 值; // 定义一个属性</span><br><span class="line">变量名.函数名 = function()&#123;&#125; // 定义一个函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量名.属性 / 函数名();</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;华仔&quot;</span>;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">obj.<span class="property">fun</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;姓名：&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; , 年龄：&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方式二：</p>
<ul>
<li><p>定义的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = &#123; <span class="comment">// 空对象</span></span><br><span class="line">    属性名：值, <span class="comment">// 定义一个属性</span></span><br><span class="line">    属性名：值, <span class="comment">// 定义一个属性</span></span><br><span class="line">    函数名：<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 定义一个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量名.属性 / 函数名();</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;国哥&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">        fun : <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;姓名：&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; , 年龄：&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<p>​	<strong>事件：</strong></p>
<ul>
<li><p>事件是电脑输入设备与页面进行交互的响应。我们称之为事件。</p>
</li>
<li><p><strong>常用的事件：</strong></p>
<ul>
<li><p>onload 加载完成事件：页面加载完成之后，常用于做页面 js 代码初始化操作</p>
</li>
<li><p>onclick 单击事件：常用于按钮的点击响应操作。</p>
</li>
<li><p>onblur 失去焦点事件：常用用于输入框失去焦点后验证其输入内容是否合法。</p>
</li>
<li><p>onchange 内容发生改变事件：常用于下拉列表和输入框内容发生改变后操作</p>
</li>
<li><p>onsubmit 表单提交事件：常用于表单提交前，验证所有表单项是否合法。</p>
</li>
</ul>
</li>
<li><p><strong>事件的注册</strong></p>
<p>就是告诉浏览器，当事件响应后要执行哪些操作代码，叫事件注册或事件绑定。 <strong>分为静态注册和动态注册两种：</strong></p>
<ul>
<li><p>静态注册事件：通过 html 标签的事件属性直接赋于事件响应后的代码，这种方式我们叫静态注册。 </p>
</li>
<li><p>动态注册事件：是指先通过 js 代码得到标签的 dom 对象，然后再通过 dom 对象.事件名 &#x3D; function(){} 这种形式赋于事件响应后的代码，叫动态注册。</p>
<ul>
<li>动态注册基本步骤：<ol>
<li>获取标签对象</li>
<li>标签对象.事件名 &#x3D; fucntion(){}</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 静态注册失去焦点事件</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">onblurFun</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// console 是控制台对象，是由 JavaScript 语言提供，专门用来向浏览器的控制器打印输出， 用于测试使用</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// log() 是打印的方法</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;静态注册失去焦点事件&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 动态注册 onblur 事件</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//1 获取标签对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> passwordObj = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// alert(passwordObj);</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//2 通过标签对象.事件名 = function()&#123;&#125;;</span></span></span><br><span class="line"><span class="language-javascript">            passwordObj.<span class="property">onblur</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;动态注册失去焦点事件&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>DOM模型：</strong></p>
<ul>
<li><p>DOM 全称是 Document Object Model 文档对象模型</p>
</li>
<li><p>大白话，就是把文档中的标签，属性，文本，转换成为对象来管理。</p>
</li>
<li><p><strong>Document</strong> <strong>对象的理解：</strong></p>
<p><strong>第一点：</strong>Document<strong>它管理了所有的</strong> <strong>HTML</strong> <strong>文档内容。</strong></p>
<p><strong>第二点：</strong>document <strong>它是一种树结构的文档。有层级关系。</strong></p>
<p><strong>第三点：它让我们把所有的标签都对象化</strong></p>
<p><strong>第四点：我们可以通过</strong> <strong>document</strong> <strong>访问所有的标签对象。</strong></p>
</li>
</ul>
<p><img src="/2022/11/20/JavaWeb-review/image-20221120192319116.png" alt="image-20221120192319116"></p>
<ul>
<li><p>Document对象中的方法</p>
<ul>
<li><p>**document.getElementById(elementId)**——通过标签的 id 属性查找标签 dom 对象，elementId 是标签的 id 属性值</p>
</li>
<li><p>**document.getElementsByName(elementName)**——通过标签的 name 属性查找标签 dom 对象，elementName 标签的 name 属性值</p>
</li>
<li><p>**document.getElementsByTagName(tagname)**——通过标签名查找标签 dom 对象。tagname 是标签名</p>
</li>
<li><p>**document.createElement( tagName)**——通过给定的标签名，创建一个标签对象。tagName 是要创建的标签名</p>
</li>
</ul>
</li>
</ul>
<p>​			<strong>注：</strong></p>
<ul>
<li>document 对象的三个查询方法，如果有 id 属性，优先使用 <strong>getElementById</strong> 方法来进行查询</li>
<li>如果没有 id 属性，则优先使用 <strong>getElementsByName</strong> 方法来进行查询</li>
<li>如果 id 属性和 name 属性都没有最后再按标签名查 <strong>getElementsByTagName</strong></li>
<li>以上三个方法，一定要在页面加载完成之后执行，<br>才能查询到标签对象。</li>
</ul>
<hr>
<p><strong>节点</strong></p>
<ul>
<li>childNodes 属性，获取当前节点的所有子节点</li>
<li>firstChild 属性，获取当前节点的第一个子节点</li>
<li>lastChild 属性，获取当前节点的最后一个子节点</li>
<li>parentNode 属性，获取当前节点的父节点</li>
<li>nextSibling 属性，获取当前节点的下一个节点</li>
<li>previousSibling 属性，获取当前节点的上一个节点</li>
<li>className 用于获取或设置标签的 class 属性值</li>
<li>innerHTML 属性，表示获取&#x2F;设置起始标签和结束标签中的内容</li>
<li>innerText 属性，表示获取&#x2F;设置起始标签和结束标签中的文本</li>
</ul>
<hr>
<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><ul>
<li><p>使用方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../script/jquery-1.7.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// window.onload = function () &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var btnObj = document.getElementById(&quot;btnId&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// // alert(btnObj);//[object HTMLButtonElement] ====&gt;&gt;&gt; dom 对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// btnObj.onclick = function () &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// alert(&quot;js 原生的单击事件&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 表示页面加载完成 之后，相当 window.onload = function () &#123;&#125;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> $btnObj = $(<span class="string">&quot;#btnId&quot;</span>); <span class="comment">// 表示按 id 查询标签对象</span></span></span><br><span class="line"><span class="language-javascript">        $btnObj.<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 绑定单击事件</span></span></span><br><span class="line"><span class="language-javascript">        	<span class="title function_">alert</span>(<span class="string">&quot;jQuery 的单击事件&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：使用JQuery必须要引入JQuery库</li>
</ul>
</li>
</ul>
<p><strong>JQuery核心函数</strong></p>
<ul>
<li><p>$ 是JQuery的核心函数，可以完成JQuery的很多功能</p>
</li>
<li><p>调用方式  $()，相当于 window.onload &#x3D; function(){} </p>
</li>
<li><p>传入参数为 [ HTML 字符串 ] 时：会为我们创建这个 html 标签对象</p>
<p>传入参数为 [ 选择器字符串 ] 时：</p>
<p>​				$(“#id 属性值”)：id 选择器，根据 id 查询标签对象</p>
<p>​				$(“标签名”)：标签名选择器，根据指定的标签名查询标签对象</p>
<p>​				$(“.class 属性值”); 类型选择器，可以根据 class 属性查询标签对象</p>
<p>传入参数为 [ DOM 对象 ] 时：会把这个 dom 对象转换为 jQuery 对象</p>
</li>
</ul>
<p><strong>JQuery对象和DOM对象的区别</strong></p>
<p><img src="/2022/11/20/JavaWeb-review/image-20221124162919871.png" alt="image-20221124162919871"></p>
<ul>
<li><strong>jQuery 对象本质上是 dom 对象的数组 + jQuery 提供的一系列功能函数。</strong></li>
</ul>
<p><strong>JQuery对象和DOM对象的相互转换</strong></p>
<p><img src="/2022/11/20/JavaWeb-review/image-20221124163054423.png" alt="image-20221124163054423"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>A review of generics and list</title>
    <url>/2022/11/19/GenericsAndList/</url>
    <content><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List:"></a>List:</h2><h4 id="remove"><a href="#remove" class="headerlink" title="remove():"></a>remove():</h4><p>There are two methods to remove an element from a list.</p>
<ul>
<li>remove by index –&gt; remove(int index)</li>
<li>remove by content –&gt; remove(Object o)</li>
</ul>
<p>List deletes elements by moving the element after the target one index position, setting the last element to null and size-1; So it’s best to delete from large to small.</p>
<h5 id="Some-mistakes"><a href="#Some-mistakes" class="headerlink" title="Some mistakes:"></a>Some mistakes:</h5><p><strong>Error1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = list.size(); i &lt; len; i++)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(list.get(i) == <span class="number">1</span>) &#123;  </span><br><span class="line">       list.remove(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: Index: 3, Size: 3  </span><br><span class="line">    at java.util.ArrayList.RangeCheck(Unknown Source)  </span><br><span class="line">    at java.util.ArrayList.get(Unknown Source)</span><br></pre></td></tr></table></figure>

<ul>
<li>The array is out of bounds. After deleting the element and not changing the corresponding index, it will not be found when iterating through the last one. So throw this exception.</li>
</ul>
<p><strong>Error2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();  </span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();  </span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;  </span><br><span class="line">       list.remove(i); <span class="comment">//错误,ConcurrentModificationException异常。</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>The modCount value of the list object is modified. The modCount value of the iterator is not modified, so it throw out this exception.</li>
</ul>
<h5 id="The-right-method-to-remove-an-element-from-list"><a href="#The-right-method-to-remove-an-element-from-list" class="headerlink" title="The right method to remove an element from list:"></a><strong>The right method to remove an element from list:</strong></h5><p><strong>Method1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = list.size(); i &lt; len; i++)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(list.get(i) == <span class="number">1</span>)&#123;  </span><br><span class="line">       list.remove(i);  </span><br><span class="line">       len--;</span><br><span class="line">       i--;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Method2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();  </span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();  </span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;  </span><br><span class="line">        iterator.remove();  <span class="comment">//正确</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Method3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(target.equals(item))&#123;</span><br><span class="line">        list.remove(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Method4:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; cowList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;String&gt;(list);</span><br><span class="line"><span class="keyword">for</span> (String item : cowList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.equals(target)) &#123;</span><br><span class="line">        cowList.remove(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Solved the list concurrency problem.</li>
</ul>
<hr>
<h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics:"></a>Generics:</h2><p><strong>Some details about generics</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型的使用</span></span><br><span class="line"><span class="comment"> * 1.jdk 5.0新增的特性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.在集合中使用泛型：</span></span><br><span class="line"><span class="comment"> *  总结：</span></span><br><span class="line"><span class="comment"> *  ① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。</span></span><br><span class="line"><span class="comment"> *  ② 在实例化集合类时，可以指明具体的泛型类型</span></span><br><span class="line"><span class="comment"> *  ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</span></span><br><span class="line"><span class="comment"> *    比如：add(E e)  ---&gt;实例化以后：add(Integer e)</span></span><br><span class="line"><span class="comment"> *  ④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</span></span><br><span class="line"><span class="comment"> *  ⑤ 如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>Some notes of generics</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</span><br><span class="line"><span class="number">2.</span> 泛型类的构造器如下：<span class="keyword">public</span> <span class="title function_">GenericClass</span><span class="params">()</span>&#123;&#125;。而下面是错误的：<span class="keyword">public</span> GenericClass&lt;E&gt;()&#123;&#125;</span><br><span class="line"><span class="number">3.</span> 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</span><br><span class="line"><span class="number">4.</span> 泛型不同的引用不能相互赋值。</span><br><span class="line">	&gt;尽管在编译时ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</span><br><span class="line"><span class="number">5.</span> 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用。</span><br><span class="line"><span class="number">6.</span> 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</span><br><span class="line"><span class="number">7.</span> jdk1<span class="number">.7</span>，泛型的简化操作：ArrayList&lt;Fruit&gt; flist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="number">8.</span> 泛型的指定中不能使用基本数据类型，可以使用包装类替换。</span><br><span class="line"><span class="number">9.</span> 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。</span><br><span class="line"><span class="number">10.</span> 异常类不能是泛型的</span><br><span class="line"><span class="number">11.</span> 不能使用<span class="keyword">new</span> <span class="title class_">E</span>[]。但是可以：E[] elements = (E[])<span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</span><br></pre></td></tr></table></figure>

<p><strong>Extend of generics</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</span><br><span class="line">&gt; 子类不保留父类的泛型：按需实现</span><br><span class="line">    &gt; 没有类型 擦除</span><br><span class="line">    &gt; 具体类型</span><br><span class="line">&gt; 子类保留父类的泛型：泛型子类</span><br><span class="line">    &gt; 全部保留</span><br><span class="line">    &gt; 部分保留</span><br><span class="line"></span><br><span class="line">结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型      </span><br></pre></td></tr></table></figure>

<p><strong>The embodiment of generics in terms of inheritance</strong></p>
<p>Although class A is the parent of class B，but the relationship between G<A>  and G<B> is not parent and child, they are paratactic.</B></A></p>
<ul>
<li>For example:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; list1 = null;</span><br><span class="line">  List&lt;String&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">  list1 = list 2; //Error</span><br></pre></td></tr></table></figure>

<ul>
<li>Additional: If class A is parent of class B，A<G> is parent of B<G>.</G></G></li>
</ul>
<p><strong>The use of wildcards</strong></p>
<ul>
<li><p>wildcards: ?</p>
</li>
<li><p>If class A is parent of class B, the relationship between G<A>  and G<B> is not parent and child, their parent is: G&lt;?&gt;</B></A></p>
</li>
<li><p>For example:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        list = list1;</span><br><span class="line">        list = list2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>The use of conditional wildcards</strong></p>
<ul>
<li><p>? extends A:<br>     G&lt;? extends A&gt;  can be parent of G<A> and G<B>, class B is child of class A</B></A></p>
</li>
<li><p>​    ? super A:<br>​         G&lt;? super A&gt; can be parent of G<A> and G<B> , class B is parent of class A</B></A></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();;</span><br><span class="line">List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();;</span><br><span class="line">List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以这么认为：? extends A 代表 ?为A的一个子类，也可以将extends类比于&lt;=;</span></span><br><span class="line">list1 = list3;</span><br><span class="line">list1 = list4;</span><br><span class="line"><span class="comment">// list1 = list5; //error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以这么认为：? super A 代表 ?为A的一个父类，也可以将super类比于&gt;=;</span></span><br><span class="line"><span class="comment">// list2 = list3;//error</span></span><br><span class="line">list2 = list4;</span><br><span class="line">list2 = list4;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode</title>
    <url>/2022/11/14/LeetCode/</url>
    <content><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="Chapter1-Easy"><a href="#Chapter1-Easy" class="headerlink" title="Chapter1-Easy"></a>Chapter1-Easy</h2><h3 id="Question1-Two-Sum"><a href="#Question1-Two-Sum" class="headerlink" title="Question1: Two Sum"></a>Question1: Two Sum</h3><p><strong>题目描述：</strong>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那两个整数，并返回它们的数组下标。</p>
<ul>
<li>可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</li>
<li>可以按任意顺序返回答案。</li>
</ul>
<p><strong>分析</strong>：看到题目第一眼思考就是采用暴力破解的方法，将数组里的全部元素都进行遍历，寻找是否有符合的数字。</p>
<p><strong>解法一：暴力求解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>暴力求解时间复杂度为O(N2)</li>
<li>暴力求解空间复杂度为O(1)</li>
</ul>
<p><strong>解法二：利用哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//Perhaps the best one of all I have seen.</span></span><br><span class="line">        <span class="comment">//First create the result set.</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//Judge the set.</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp)) &#123;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(temp);</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Insert into map</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用哈希表得到的性能优于暴力求解</li>
<li>时间复杂度为O(N)</li>
<li>空间复杂度为O(N)</li>
</ul>
<hr>
<h3 id="Question2-Palindrome"><a href="#Question2-Palindrome" class="headerlink" title="Question2:Palindrome"></a>Question2:Palindrome</h3><p><strong>题目要求：</strong>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p>
<ul>
<li>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</li>
<li>例如，121 是回文，而 123 不是。</li>
</ul>
<p><strong>分析：</strong>最简单的就是转换为一个字符串之后进行一一对比；进一步的思路是，将倒过来的数字求出来，然后进行对比。</p>
<p><strong>解法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toString(x);</span><br><span class="line">        <span class="type">char</span> arr[] = s.toCharArray();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//判断是不是回文数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != arr[arr.length - <span class="number">1</span> - i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二：</strong>将数字进行反转之后比较与原有数字是否相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> ||(x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            reverse = reverse * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp == reverse || temp == reverse / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法三：</strong>对解法二的拓展（官方解答）相当于只做一半的反转，然后进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">revertedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question3-Roman-numerals-to-integers"><a href="#Question3-Roman-numerals-to-integers" class="headerlink" title="Question3:Roman numerals to integers"></a>Question3:Roman numerals to integers</h3><p><strong>题目要求：</strong></p>
<p><img src="/2022/11/14/LeetCode/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.PNG" alt="罗马数字转整数"></p>
<p><strong>分析</strong>：本题目只要读明白题目是不难的。首先，我们要通过一种方式 ，将罗马数字和整数之间有一个对应（评论区有一个枚举法，就是将所有可能的情况全部进行一一对应，然后在进行判断），对应之后，我们判断this的罗马数字和下一位的比较，如果this&gt;this+1,那么就说明正常加即可，但是this&lt;this_1的时候，就需要进行相减。<strong>别忘记判断越界</strong></p>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//本题目是为了将罗马数字转化为普通的数字</span></span><br><span class="line">        <span class="comment">//我们要进行两个判断，首先判断他是谁，然后判断他与下一位的比较，判断正负</span></span><br><span class="line">        <span class="comment">//1.将罗马数字与数字做对应</span></span><br><span class="line">        <span class="comment">//&#123;&#x27;I&#x27;:1,&#x27;V&#x27;:5,&#x27;X&#x27;:10,&#x27;L&#x27;:50,&#x27;C&#x27;:100,&#x27;D&#x27;:500,&#x27;M&#x27;:1000</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">50</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">100</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">500</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">1000</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((i &lt; nums.length - <span class="number">1</span>) &amp;&amp; nums[i] &lt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                res -= nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question4-The-longest-identical-prefix"><a href="#Question4-The-longest-identical-prefix" class="headerlink" title="Question4:The longest identical prefix"></a>Question4:The longest identical prefix</h3><p><strong>题目描述：</strong></p>
<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。</p>
<p><strong>分析：</strong>本题我是采用数据结构老师韩顺平的方法，先写出查找第一个字母是否相同，然后进行推断可以得到一个循环来进行判断。</p>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">//先创建一个数组，把长度添加到数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="type">int</span>[] lenSet = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            lenSet[i] = strs[i].length();</span><br><span class="line">            <span class="keyword">if</span> (strs[i].length() &lt; minLen) &#123;</span><br><span class="line">                minLen = strs[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">//把第一步的做法进行循环即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; minLen; j++) &#123;</span><br><span class="line">            <span class="comment">//我先把第一个字符串的第一个字母取出来</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">fir</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(j);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[i].charAt(j) != fir) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                res.append(fir);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resStr</span> <span class="operator">=</span> res.toString();</span><br><span class="line">        <span class="keyword">return</span> resStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述个人答案属于纵向对比，时间复杂度为O(mn),空间复杂度为O(1)</strong></p>
<p>LeetCode官方还有下述几种算法：</p>
<ul>
<li>横向扫描：拿最长字串去做对比，对比之后更新最长字串</li>
<li>分治算法：yysy，没看懂，以后再来补吧</li>
<li>二分算法：取mid，判断其前缀是否相同来进行判断</li>
</ul>
<hr>
<h3 id="Question5-Valid-Brackets"><a href="#Question5-Valid-Brackets" class="headerlink" title="Question5:Valid Brackets"></a>Question5:Valid Brackets</h3><p><strong>题目描述：</strong></p>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ul>
<p><strong>分析：</strong></p>
<p>题目的意思是，在s这个只含有括号的字符串中，只能含有三种情 况，”()” “{}”  “[]”，不可以进行嵌套，也就是不可以存在”([)]”，本人做法未考虑这种嵌套。</p>
<p><strong>解答：</strong></p>
<p><strong>解法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length() / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">			s = s.replace(<span class="string">&quot;()&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;[]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> s.length() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种解法只考虑了代码的简洁程度，并没有考虑算法的复杂度。</li>
</ul>
<p><strong>解法二：使用栈空间进行求解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            <span class="comment">//碰到左括号，就把相应的右括号入栈</span></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deque.isEmpty() || deque.peek() != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果是右括号判断是否和栈顶元素匹配</span></span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后判断栈中元素是否匹配</span></span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用栈的特性后进先出，将所有的左括号压入栈内，当遇到一个有括号的时候，判断栈顶的括号是否和它匹配，如果匹配就继续，不匹配的话就return false</li>
<li><strong>本题属于遇到的第一个数据结构题目，对于复习数据结构方面的知识还是很有好处的</strong></li>
</ul>
<hr>
<h3 id="Question6-Merge-two-LinkedLists"><a href="#Question6-Merge-two-LinkedLists" class="headerlink" title="Question6:Merge two LinkedLists"></a>Question6:Merge two LinkedLists</h3><p><strong>题目描述：</strong></p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p>
<p><strong>解答：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">//先创建一个新链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> newNode;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当一个链表为空的时候，就把非空的接在后面就行了</span></span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next = list2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>本题比较简单，没有什么很难的点，但是要注意一下链表的定义。</li>
</ul>
<hr>
<h3 id="Question7-Remove-duplicate-numbers"><a href="#Question7-Remove-duplicate-numbers" class="headerlink" title="Question7:Remove duplicate numbers"></a>Question7:Remove duplicate numbers</h3><p><strong>题目描述：</strong></p>
<p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<ul>
<li><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>
</li>
<li><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>
</li>
<li><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</li>
</ul>
<p><strong>测试代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = [...]; <span class="comment">// 输入数组</span></span><br><span class="line"><span class="type">int</span>[] expectedNums = [...]; <span class="comment">// 长度正确的期望答案</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> removeDuplicates(nums); <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> k == expectedNums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="keyword">assert</span> nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>刚开始想把所有的重复的都通过冒泡挪到最后面，但是对于很多情况不适用。看了评论，学会了双指针与单指针的方法。其实大体就是向后判断，后面的要是没有重复，就把它加到前面判断完的后面就行。</p>
<p><strong>解答：</strong></p>
<p><strong>解法一：双指针</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//利用双指针</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( j &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二：单指针判断</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[++index] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question8-Remove-specified-value"><a href="#Question8-Remove-specified-value" class="headerlink" title="Question8:Remove specified value"></a>Question8:Remove specified value</h3><p><strong>题目描述：</strong></p>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<ul>
<li><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
</li>
<li><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</li>
</ul>
<p><strong>分析：</strong></p>
<p>这道题目和上一个类似，都是要取出元素，也可以用指针来做。本人的做法是，构造一个指针指向最末尾的元素，如果前面出现了与指定数字相同的元素，就将这个位置的元素与最后的元素进行交换，<strong>交换之后，还要再继续进行这个位置的遍历</strong>。</p>
<p><strong>题解：</strong></p>
<p><strong>解法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//采用指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= last; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[last];</span><br><span class="line">                nums[last] = temp;</span><br><span class="line">                last--;</span><br><span class="line">                i--;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解答二：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question9-Search-target-number"><a href="#Question9-Search-target-number" class="headerlink" title="Question9:Search target number"></a>Question9:Search target number</h3><p><strong>题目描述：</strong></p>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<ul>
<li>请必须使用时间复杂度为 O(log n) 的算法。</li>
</ul>
<p><strong>分析：</strong></p>
<p>本题就一个二分遍历就完事了</p>
<p><strong>解答：</strong></p>
<p><strong>解法一：直接遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length ==<span class="number">0</span> || nums == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target || nums[i] &gt; target) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二：二分法查找</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question10-Last-word-count"><a href="#Question10-Last-word-count" class="headerlink" title="Question10:Last word count"></a>Question10:Last word count</h3><p><strong>题目描述：</strong></p>
<p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p>
<ul>
<li>单词是指仅由字母组成、不包含任何空格字符的最大子字符串。</li>
</ul>
<p><strong>题解：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question11-Plus-one"><a href="#Question11-Plus-one" class="headerlink" title="Question11:Plus one"></a>Question11:Plus one</h3><p><strong>题目描述：</strong></p>
<p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<ul>
<li><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
</li>
<li><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
</li>
</ul>
<p><strong>分析：</strong></p>
<p>错误原因是考虑不全面，个人思考的是先将这个数组转换为整数，再将整数加1，然后返回加1之后的数组，没有考虑到整数型溢出的问题。</p>
<p>其实本题思路很简单，从后往前遍历，如果遇到一位不是9，那么直接加一，然后返回即可；如果全是9，那么将所有的i置为0，把首位置为1即可。</p>
<p><strong>题解：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">9</span>) &#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question12-Binary-addition"><a href="#Question12-Binary-addition" class="headerlink" title="Question12:Binary addition"></a>Question12:Binary addition</h3><p><strong>题目描述：</strong></p>
<p>给你两个二进制字符串 <code>a</code> 和 <code>b</code> ，以二进制字符串的形式返回它们的和。</p>
<p><strong>分析：</strong></p>
<p>本题做法分为三步：</p>
<ol>
<li>先将二者的长度置为相同，通过对较短的字符串进行补0来实现</li>
<li>设置一个进位数，通过判断当前的值来看是否发生了进位</li>
<li>将判断的结果加入到字符串中，最终对字符串进行反转即可</li>
</ol>
<p><strong>题解：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Math.max(a.length(), b.length()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            carry += i &lt; a.length() ? (a.charAt(a.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.length() ? (b.charAt(b.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.append((<span class="type">char</span>) (carry % <span class="number">2</span> + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question13-Integer-multiples-of-the-square-root"><a href="#Question13-Integer-multiples-of-the-square-root" class="headerlink" title="Question13:Integer multiples of the square root"></a>Question13:Integer multiples of the square root</h3><p><strong>题目描述：</strong></p>
<p>给定一个非负整数 x ，计算并返回 x 的算术平方根 。</p>
<ul>
<li><p>由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。</p>
</li>
<li><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 。</p>
</li>
</ul>
<p><strong>分析：</strong></p>
<p>本题很容易就能想到，你可以找一个数，它的平方小于等于这个给定的数，并且+1之后又大于了这个给定的数，这样就找到了这个数。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong>袖珍计算器法</p>
<p><img src="/2022/11/14/LeetCode/%E5%85%AC%E5%BC%8F%E4%B8%80.png" alt="公式一"></p>
<p><strong>注意</strong>： 由于计算机无法存储浮点数的精确值，而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。因此在得到结果的整数部分 ans 后，我们应当找出ans 与ans+1 中哪一个是真正的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> (<span class="type">int</span>) Math.exp(<span class="number">0.5</span> * Math.log(x));</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">long</span>) (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：二分法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(max - min &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (max + min) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x/mid &lt; mid) &#123;</span><br><span class="line">                max = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：牛顿迭代</strong></p>
<p><a href="https://leetcode.cn/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/">牛顿迭代</a></p>
<hr>
<h3 id="Question14-Climb-stairs"><a href="#Question14-Climb-stairs" class="headerlink" title="Question14:Climb stairs"></a>Question14:Climb stairs</h3><p><strong>题目描述：</strong></p>
<p>一个人爬楼梯，只能爬一个台阶或者两个，问有几种上楼的方法。</p>
<p><strong>分析：</strong></p>
<p>刚开始我认为这是一道迭代的题目，相当于斐波那契数列，但是发现，如果按照迭代来做，超出了时间限制，因此需要用动态规划的思想来看这个题目。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i1+i2;</span><br><span class="line">            i1 = i2;</span><br><span class="line">            i2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：<a href="https://leetcode.cn/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/">矩阵计算法</a></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span>[][] res = pow(q, n);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] pow(<span class="type">int</span>[][] a, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] multiply(<span class="type">int</span>[][] a, <span class="type">int</span>[][] b) &#123;</span><br><span class="line">        <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：利用微分方程的思想</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        double sqrt5 = Math.sqrt(5);</span><br><span class="line">        double fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);</span><br><span class="line">        return (int) Math.round(fibn / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question15-删除排序链表中的重复数据"><a href="#Question15-删除排序链表中的重复数据" class="headerlink" title="Question15:删除排序链表中的重复数据"></a><strong>Question15:删除排序链表中的重复数据</strong></h3><p><strong>题目描述：</strong></p>
<p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p>
<p><strong>题解：</strong></p>
<p><strong>个人解法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//先设置一个指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归法：</strong></p>
<p>如果当前的val和下一个节点的val相等的话，就让当前指针指向下一个节点；不等的话，就处理下一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//先设置一个指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.val == head.next.val) &#123;</span><br><span class="line">            head = deleteDuplicates(head.next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.next = deleteDuplicates(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question16-合并两个有序数组"><a href="#Question16-合并两个有序数组" class="headerlink" title="Question16:合并两个有序数组"></a>Question16:合并两个有序数组</h3><p><strong>题目描述：</strong></p>
<p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：使用最简单的方式，就是把nums2中的所有的数字加到nums1中的空白处，然后对整个数组进行排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums1[m+i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：利用双指针（逆向的就不用考虑后面的移位问题了）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> m-- + n-- - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;=<span class="number">0</span> &amp;&amp; n&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question17-二叉树的中序遍历"><a href="#Question17-二叉树的中序遍历" class="headerlink" title="Question17:二叉树的中序遍历"></a>Question17:二叉树的中序遍历</h3><p><strong>题目描述：</strong></p>
<p>实现二叉树的中序遍历</p>
<p><strong>分析：</strong></p>
<p>这是数据结构课上的一个很简单的例子，一定要把数组创建在方法外！</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：使用递归的方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; res= new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        // TreeNode cur = root;</span><br><span class="line">        if(root != null) &#123;</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            inorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用栈</strong></p>
<p>主要思想就是先将当前节点压入栈内，然后遍历左边的节点并且压入栈，左侧的节点遍历完了就把栈中的数据按照顺序输出，在输出的同时还要判断这个节点有无右节点，有的话就输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">        List&lt;Integer&gt; list= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;          </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：Morris 中序遍历<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">详解</a></strong></p>
<hr>
<h3 id="Question18-判断两个二叉树是否完全相同"><a href="#Question18-判断两个二叉树是否完全相同" class="headerlink" title="Question18:判断两个二叉树是否完全相同"></a>Question18:判断两个二叉树是否完全相同</h3><p><strong>题目描述：</strong></p>
<p>判断两个二叉树是否完全相同（包括结构和数据）</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：使用递归来解决很容易的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span> &amp;&amp; p.val == q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：广度优先算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 广度优先</span></span><br><span class="line">        Queue&lt;TreeNode&gt; tmpQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        tmpQueue.offer(p);</span><br><span class="line">        tmpQueue.offer(q);</span><br><span class="line">        <span class="keyword">while</span>(!tmpQueue.isEmpty())&#123;</span><br><span class="line">            p = tmpQueue.poll();</span><br><span class="line">            q = tmpQueue.poll();</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((p == <span class="literal">null</span> || q == <span class="literal">null</span>) || p.val != q.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpQueue.offer(p.left);</span><br><span class="line">            tmpQueue.offer(q.left);</span><br><span class="line"></span><br><span class="line">            tmpQueue.offer(p.right);</span><br><span class="line">            tmpQueue.offer(q.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>补充：offer()表示向队列里面添加元素，并且返回true，如果队列满了就返回false</p>
<hr>
<h3 id="Question19-判断二叉树是否为对称二叉树"><a href="#Question19-判断二叉树是否为对称二叉树" class="headerlink" title="Question19:判断二叉树是否为对称二叉树"></a>Question19:判断二叉树是否为对称二叉树</h3><p><strong>题目描述：</strong></p>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p>举个例子：</p>
<p><img src="/2022/11/14/LeetCode/Q19%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="Q19对称二叉树"></p>
<p><strong>题解：二叉树的定义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>方法一：使用递归来求</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isEqual(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(TreeNode node1, TreeNode node2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span> || node1.val != node2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isEqual(node1.left,node2.right) &amp;&amp; isEqual(node1.right,node2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用迭代来做</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//使用迭代法来求</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span> || node1.val != node2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(node1.left);</span><br><span class="line">            queue.offer(node2.right);</span><br><span class="line">            queue.offer(node1.right);</span><br><span class="line">            queue.offer(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question20-求二叉树的最大深度"><a href="#Question20-求二叉树的最大深度" class="headerlink" title="Question20:求二叉树的最大深度"></a>Question20:求二叉树的最大深度</h3><p><strong>题目描述：</strong></p>
<p>给定一个二叉树，找出其最大深度。</p>
<ul>
<li>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>解法一：递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二：BFS(广度优先就是先把这一层判断之后再判断下一层)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法三：DFS(深度优先，就是先把这一个分支判断之后再判断其他分支，实时更新最大深度)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLevel</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> maxLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (level &gt; maxLevel) maxLevel = level;</span><br><span class="line">        dfs(root.left, level + <span class="number">1</span>);</span><br><span class="line">        dfs(root.right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question21-路径总和问题"><a href="#Question21-路径总和问题" class="headerlink" title="Question21:路径总和问题"></a>Question21:路径总和问题</h3><p><strong>题目描述：</strong></p>
<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<ul>
<li>叶子节点 是指没有子节点的节点</li>
<li>注意，如果给定的二叉树为空并且targetNum&#x3D;0，结果依旧是false</li>
</ul>
<p><strong>题解：</strong></p>
<p>这是一个简单的递归的题目，我们采取逆向思维</p>
<ol>
<li>先找叶子节点，如果此时判断的节点为叶子节点，那就看看目标值-叶子结点的值是否等于前面路径上的值之和</li>
<li>如果不是叶子节点，进行递归，将目标值减去当前节点的值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum-root.val == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,targetSum-root.val)</span><br><span class="line">                || hasPathSum(root.right,targetSum-root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question22-杨辉三角"><a href="#Question22-杨辉三角" class="headerlink" title="Question22:杨辉三角"></a>Question22:杨辉三角</h3><p><strong>题目描述：</strong></p>
<p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><strong>题解：</strong></p>
<p>本题不难，就是求出一个杨辉三角形即可，个人的难点就是使用List集合的时候不够熟练，平时都是用数组来做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; mid = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span> || j==i) &#123;</span><br><span class="line">                    mid.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//先获取上一行的值</span></span><br><span class="line">                    List&lt;Integer&gt; up = res.get(i-<span class="number">1</span>);</span><br><span class="line">                    mid.add(up.get(j-<span class="number">1</span>) + up.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question23-杨辉三角Ⅱ"><a href="#Question23-杨辉三角Ⅱ" class="headerlink" title="Question23:杨辉三角Ⅱ"></a>Question23:杨辉三角Ⅱ</h3><p><strong>题目描述：</strong></p>
<p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p>
<ul>
<li>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</li>
</ul>
<p><strong>题解：</strong></p>
<p>本题和上一道题区别就在于一个返回的是全部集合，一个是返回指定行的集合。</p>
<p><strong>方法一：创建出杨辉三角，然后取指定的那一行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; mid = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span> || j==i) &#123;</span><br><span class="line">                    mid.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//先获取上一行的值</span></span><br><span class="line">                    List&lt;Integer&gt; up = res.get(i-<span class="number">1</span>);</span><br><span class="line">                    mid.add(up.get(j-<span class="number">1</span>) + up.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.get(rowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：利用杨辉三角形同行之间的关系来求</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取杨辉三角的指定行</span></span><br><span class="line"><span class="comment"> * 直接使用组合公式C(n,i) = n!/(i!*(n-i)!)</span></span><br><span class="line"><span class="comment"> * 则第(i+1)项是第i项的倍数=(n-i)/(i+1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(rowIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">            res.add((<span class="type">int</span>) cur);</span><br><span class="line">            cur = cur * (rowIndex-i)/(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度更低，优先记这个</li>
</ul>
<hr>
<h3 id="Question24-计算最大收益"><a href="#Question24-计算最大收益" class="headerlink" title="Question24:计算最大收益"></a>Question24:计算最大收益</h3><p><strong>题目描述：</strong></p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p><strong>题解：线性规划</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - minPrice &gt; maxProfit) &#123;</span><br><span class="line">                maxProfit = prices[i] - minPrice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>本题最简单的思路是，采用两次循环，来求出最大的利润，这样的作法时间复杂度太高，会超出时间范围，因此在这里不做赘述。</p>
<hr>
<h3 id="Question25：判断回文数"><a href="#Question25：判断回文数" class="headerlink" title="Question25：判断回文数"></a>Question25：判断回文数</h3><p><strong>题目描述：</strong></p>
<p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p>
<ul>
<li><p>字母和数字都属于字母数字字符。</p>
</li>
<li><p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p>
</li>
</ul>
<p><strong>题解</strong>：</p>
<p><strong>方法一：</strong></p>
<p>最简单的办法就是去除所有标点和空格之后，再进行判断，注意要将所有的字符串都转换为小写的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(String s) &#123;</span><br><span class="line">        String str1 = s.replaceAll(&quot;[^0-9a-zA-Z]&quot;,&quot;&quot;);</span><br><span class="line">        String str = str1.toLowerCase();</span><br><span class="line">        boolean flag = true;</span><br><span class="line">        for(int i = 0; i &lt; str.length()/2; i++) &#123;</span><br><span class="line">            if(str.charAt(i) != str.charAt(str.length() - i - 1))&#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>将字符串反转之后判断和源字符串是否相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sgood</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetterOrDigit(ch)) &#123;</span><br><span class="line">                sgood.append(Character.toLowerCase(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sgood_rev</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(sgood).reverse();</span><br><span class="line">        <span class="keyword">return</span> sgood.toString().equals(sgood_rev.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：双指针（性能最优）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question26-只出现一次的数字"><a href="#Question26-只出现一次的数字" class="headerlink" title="Question26:只出现一次的数字"></a>Question26:只出现一次的数字</h3><p><strong>题目描述：</strong></p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>题解分析：</strong></p>
<ul>
<li><p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p>
</li>
<li><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p>
</li>
<li><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p>
</li>
</ul>
<p><strong>题解：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//先将数组进行排序，然后加一个减一个，减去之后，如果返回的值不是0就说明找到了</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res += nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res -= nums[i];</span><br><span class="line">                <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：位运算，最后剩下的就是最终结果、</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">single</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question27-判断链表中是否含有环形"><a href="#Question27-判断链表中是否含有环形" class="headerlink" title="Question27:判断链表中是否含有环形"></a>Question27:判断链表中是否含有环形</h3><p><strong>题目描述：</strong></p>
<p>给你一个链表的头节点 head ，判断链表中是否有环。如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p><strong>分析：</strong></p>
<p>这道题是为了判断在链表中是否含有环，可以分为下面两种思路：</p>
<ol>
<li>利用Set中的元素不能重复这个原则，将节点加入到set中，如果返回为false，代表有环。</li>
<li>使用一个快指针，一个慢指针，如果有环的话，那终会有一个时刻二者相遇。</li>
</ol>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//首先用哈希集合的方法来做（由于哈希集不能有重复）</span></span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//使用第二种方法，即龟兔赛跑</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question28-二叉树的前序遍历"><a href="#Question28-二叉树的前序遍历" class="headerlink" title="Question28:二叉树的前序遍历"></a>Question28:二叉树的前序遍历</h3><p><strong>题目描述：</strong></p>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; preOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> preOrder;</span><br><span class="line">       &#125;</span><br><span class="line">       preOrder.add(root.val);</span><br><span class="line">       <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">           preorderTraversal(root.left);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">           preorderTraversal(root.right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> preOrder;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面是自己做出来的解法，迭代和Mirrors解法看leetcode官方解答</li>
</ul>
<hr>
<h3 id="Question29-实现二叉树的后序遍历"><a href="#Question29-实现二叉树的后序遍历" class="headerlink" title="Question29:实现二叉树的后序遍历"></a>Question29:实现二叉树的后序遍历</h3><p><strong>题目描述:</strong></p>
<p>实现二叉树的后序遍历</p>
<p><strong>题解：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; postOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> postOrder;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            postorderTraversal(root.left);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            postorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> postOrder;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question30-获取两个链表相交的节点"><a href="#Question30-获取两个链表相交的节点" class="headerlink" title="Question30:获取两个链表相交的节点"></a>Question30:获取两个链表相交的节点</h3><p><strong>题目描述：</strong></p>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<ul>
<li><p>题目数据 保证 整个链式结构中不存在环。</p>
</li>
<li><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：个人做法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">//个人思路：先将一个链表的所有节点加入到一个Set集合之中，</span></span><br><span class="line">        <span class="comment">//再判断另一个链表中的点是否在这个集合之中即可</span></span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (headA != <span class="literal">null</span>) &#123;</span><br><span class="line">            set.add(headA);</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在有了链表A的节点集合，判断B</span></span><br><span class="line">        <span class="keyword">while</span> (set.add(headB)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(headB.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headB;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<ol>
<li>首先判断两个链表是否为空，若为空，直接返回null，否则进行下一步</li>
<li>将一个指针指向链表A的头部，另一个指针指向链表B的头部</li>
<li>将两个链表向后移，如果A指针走到了最后，那么就把他再次指向链表B；同理，如果B指针指向了最后，就把它再次指向链表A；如此做来，如果有交点，那么在进行过程中总会相遇的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question31-Excel表列名称"><a href="#Question31-Excel表列名称" class="headerlink" title="Question31:Excel表列名称"></a>Question31:Excel表列名称</h3><p><strong>题目描述：</strong></p>
<p><img src="/2022/11/14/LeetCode/Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0.png" alt="Excel表列名称"></p>
<p><strong>题解：</strong></p>
<p>这个题目坏就坏在他是从1开始的，要是从0开始就能构成26进制数，就很简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> &#123;</span><br><span class="line">        <span class="comment">// //记录字母的个数</span></span><br><span class="line">        <span class="comment">// int num = 0;</span></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt; 7; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     if(Math.pow(26,i)/25-26/25 &gt;= columnNumber) &#123;</span></span><br><span class="line">        <span class="comment">//         num = i-1;</span></span><br><span class="line">        <span class="comment">//         break;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">//在ASCII中A对应65</span></span><br><span class="line">        <span class="keyword">while</span>(columnNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (columnNumber-<span class="number">1</span>) % <span class="number">26</span>;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ins</span> <span class="operator">=</span> (<span class="type">char</span>) (mod + <span class="number">65</span>);</span><br><span class="line">            sb.append(ins);</span><br><span class="line">            columnNumber = (columnNumber-<span class="number">1</span>) / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question32-寻找数组中出现次数多的数字"><a href="#Question32-寻找数组中出现次数多的数字" class="headerlink" title="Question32:寻找数组中出现次数多的数字"></a>Question32:寻找数组中出现次数多的数字</h3><p><strong>题目描述：</strong></p>
<p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<ul>
<li>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</li>
</ul>
<p><strong>题解 ：</strong></p>
<p><strong>方法一：</strong></p>
<p>使用最简单的方法，将数组进行排序，将排序后的数组进行判断，当前项是否等于n&#x2F;2项后的那一项，如果等于就返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//寻找数组中出现一半以上的元素</span></span><br><span class="line">        <span class="comment">//第一种，最简单的方法</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[(nums.length+i) / <span class="number">2</span>])&#123;</span><br><span class="line">                res = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的方法进行进一步的简化可得：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于算法题，不建议使用已有的api，因此使用下列解答</li>
</ul>
<p><strong>方法二：概率化</strong></p>
<p>使用概率的思想，由于寻找的数字出现的概率很大，因此我们随机抽取一个数来判断这个数是不是我们要找的数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randRange</span><span class="params">(Random rand, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(max - min) + min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countOccurences</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == num) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">majorityCount</span> <span class="operator">=</span> nums.length / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> nums[randRange(rand, <span class="number">0</span>, nums.length)];</span><br><span class="line">            <span class="keyword">if</span> (countOccurences(nums, candidate) &gt; majorityCount) &#123;</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用Map</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//获取数组的map集合，也就是数字-&gt;出现次数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; <span class="title function_">getMap</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(nums[i])) &#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i],map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = getMap(nums);</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; majorityEntry = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() &gt; nums.length / <span class="number">2</span>) &#123;</span><br><span class="line">                res = entry.getKey();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果还不如第一种方法</li>
</ul>
<hr>
<h3 id="Question33-寻找Excel的序列号"><a href="#Question33-寻找Excel的序列号" class="headerlink" title="Question33:寻找Excel的序列号"></a>Question33:寻找Excel的序列号</h3><p><strong>题目描述：</strong></p>
<p><img src="/2022/11/14/LeetCode/Excel%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7.png" alt="Excel的序列号"></p>
<p><strong>题解：</strong></p>
<p><strong>方法一：也就是Q31的逆过程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(String columnTitle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> columnTitle.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            res += (<span class="type">int</span>) (columnTitle.charAt(i) - <span class="number">64</span>) * Math.pow(<span class="number">26</span>,num-<span class="number">1</span>-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question34-寻找1的个数"><a href="#Question34-寻找1的个数" class="headerlink" title="Question34:寻找1的个数"></a>Question34:寻找1的个数</h3><p><strong>题目描述：</strong></p>
<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<p><strong>提示：</strong></p>
<ul>
<li><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</p>
</li>
<li><p>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此,在上面的示例 3 中，输入表示有符号整数 -3。</p>
</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>思路：我们可以直接循环检查给定整数 n的二进制位的每一位是否为 1。</p>
<ul>
<li>具体代码中，当检查第 i 位时，我们可以让 n 与 2^i 进行与运算，当且仅当 n 的第 i 位为 1 时，运算结果不为 0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>思路：将n与(n-1)进行运算时，会把n中的最小位置上的 1 置为 0。举例如：6 &#x3D; (110) , 5 &#x3D; (101).对二者进行与运算之后成为(100)，也就是把6中的第二个1置为了0。在没有变成 0 之前的计算次数就是1的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不用一个一个判断，运算速度更快。</li>
</ul>
<hr>
<h3 id="Question35-判断一个数是不是快乐数"><a href="#Question35-判断一个数是不是快乐数" class="headerlink" title="Question35:判断一个数是不是快乐数"></a>Question35:判断一个数是不是快乐数</h3><p><strong>题目描述：</strong></p>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p><strong>快乐数定义为：</strong></p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</li>
<li>如果这个过程 结果为 1，那么这个数就是快乐数。</li>
<li>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>使用一个较大的循环次数来判断他是不是快乐数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            int ans = 0;</span><br><span class="line">            while (n &gt; 0) &#123;</span><br><span class="line">                ans += (n%10) * (n%10);</span><br><span class="line">                n /= 10;</span><br><span class="line">            &#125;</span><br><span class="line">            n = ans;</span><br><span class="line">            if (n == 1) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>对一个数字进行题目描述的过程，最终会有三种结果出现：</p>
<ol>
<li>最终会得到 11。</li>
<li>最终会进入循环。</li>
<li>值会越来越大，最后接近无穷大</li>
</ol>
<p>因此这里我们先采取哈希集合来存放出现过的数字，如果重复出现了，就代表它不是一个快乐数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !seen.contains(n)) &#123;</span><br><span class="line">            seen.add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong></p>
<p>之前使用过的快慢指针法（判断是否存在环形的时候使用过）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowRunner</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fastRunner</span> <span class="operator">=</span> getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question36-判断两个字符串是不是同构字符串"><a href="#Question36-判断两个字符串是不是同构字符串" class="headerlink" title="Question36:判断两个字符串是不是同构字符串"></a>Question36:判断两个字符串是不是同构字符串</h3><p><strong>题目描述：</strong></p>
<p>给定两个字符串 s 和 t ，判断它们是否是同构的。</p>
<ul>
<li><p>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</p>
</li>
<li><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
</li>
<li><p>例如add和egg就是同构字符串</p>
</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<ol>
<li>创建一个HashMap，存放s的第i个字符  -  t的第i个字符</li>
<li>加入的时候进行判断，如果map的key中存在当前字符，那么value也会存在当前字符</li>
<li>再判断前一个位置是不是也是这一对</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建s-t的hashmap，再进行判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsValue(t.charAt(i))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(s.charAt(i),t.charAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(s.charAt(i)) != t.charAt(i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question37-对链表进行反转"><a href="#Question37-对链表进行反转" class="headerlink" title="Question37:对链表进行反转"></a>Question37:对链表进行反转</h3><p><strong>题目描述：</strong></p>
<p>根据给定链表的头节点，对链表进行反转</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：迭代</strong></p>
<ol>
<li>创建一个新的反转链表</li>
<li>对原有的链表从头到尾进行遍历，对当前取出的节点加入到新的反转链表最前面，即可实现反转</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个新的链表，然后遍历链表，将每一次遍历到的节点</span></span><br><span class="line">        <span class="comment">//加入到新链表的头部</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reverseNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;<span class="comment">//这是辅助节点，用来遍历链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//表示下一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = reverseNode.next;</span><br><span class="line">            reverseNode.next = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以链表1-&gt;2-&gt;3-&gt;4-&gt;5举例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                直到当前节点的下一个节点为空时返回当前节点</span></span><br><span class="line"><span class="comment">                由于5没有下一个节点了，所以此处返回节点5</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归传入下一个节点，目的是为了到达最后一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一轮出栈，head为5，head.next为空，返回5</span></span><br><span class="line"><span class="comment">            第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，</span></span><br><span class="line"><span class="comment">                      把当前节点的子节点的子节点指向当前节点</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2，</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，</span></span><br><span class="line"><span class="comment">                      此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question38-判断数组是否存在重复元素"><a href="#Question38-判断数组是否存在重复元素" class="headerlink" title="Question38:判断数组是否存在重复元素"></a>Question38:判断数组是否存在重复元素</h3><p><strong>题目描述：</strong></p>
<p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>将所有的元素进行排序，然后看相邻的元素是否相等，相等就返回true，否则返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>将元素加入到HashSet之中，然后遍历数组，如果set中已有就返回true，反之则为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先创建一个set</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question39-判断存在重复元素Ⅱ"><a href="#Question39-判断存在重复元素Ⅱ" class="headerlink" title="Question39:判断存在重复元素Ⅱ"></a>Question39:判断存在重复元素Ⅱ</h3><p><strong>题目描述：</strong></p>
<p>给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] &#x3D;&#x3D; nums[j] 且 abs(i - j) &lt;&#x3D; k 。如果存在，返回 true ；否则，返回 false 。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<ol>
<li>创建一个HashMap，构建nums[i] &lt;-&gt; i 的一个map</li>
<li>当有重复数字出现的时候，来判断一下，二者之间的距离是否小于等于k</li>
<li>如果不是，那么就用现在的这个这个下标代替之前的键值对</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先创建一个HashMap</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(map.get(nums[i])-i) &lt;= k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用滑动窗口</strong></p>
<p>考虑数组nums 中的每个长度不超过 k + 1 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过 k。如果存在一个滑动窗口，其中有重复元素，则返回true；如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k) &#123;</span><br><span class="line">                set.remove(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question40-使用队列完成栈"><a href="#Question40-使用队列完成栈" class="headerlink" title="Question40:使用队列完成栈"></a>Question40:使用队列完成栈</h3><p><strong>题目描述：</strong></p>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<ul>
<li><p>void push(int x) 将元素 x 压入栈顶。</p>
</li>
<li><p>int pop() 移除并返回栈顶元素。</p>
</li>
<li><p>int top() 返回栈顶元素。</p>
</li>
<li><p>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。</p>
</li>
<li><p>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：双队列</strong></p>
<p><strong>大致思路：</strong></p>
<ol>
<li>创建两个队列，queue1是栈，queue2是辅助队列</li>
<li>在添加元素的时候，先将元素加入到queue2队列之中，再把queue1中的元素按照顺序加入到queue2中，这个时候queue2就实现了后入先出</li>
<li>再将queue1和queue2交换即可</li>
<li>其余操作均对queue1进行即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue1;</span><br><span class="line">   Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">       queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">       queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">       <span class="comment">//采用双队列</span></span><br><span class="line">       queue2.offer(x);</span><br><span class="line">       <span class="keyword">while</span>(!queue1.isEmpty())&#123;</span><br><span class="line">           queue2.offer(queue1.poll());</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">       queue1 = queue2;</span><br><span class="line">       queue2 = temp;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> queue1.poll();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> queue1.peek(); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：单队列</strong></p>
<p><strong>大致思路：</strong></p>
<ol>
<li>创建一个队列</li>
<li>在添加元素的时候，先将现有元素的个数n获取到，然后将元素加入到队列中，再将前n个元素依次加到队列的尾部即可</li>
<li>其余操作均对queue执行即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用单队列完成</span></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question41-使用栈实现队列"><a href="#Question41-使用栈实现队列" class="headerlink" title="Question41:使用栈实现队列"></a>Question41:使用栈实现队列</h3><p><strong>题目描述：</strong></p>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p><strong>实现 MyQueue 类：</strong></p>
<ul>
<li><p>void push(int x) 将元素 x 推到队列的末尾</p>
</li>
<li><p>int pop() 从队列的开头移除并返回元素</p>
</li>
<li><p>int peek() 返回队列开头的元素</p>
</li>
<li><p>boolean empty() 如果队列为空，返回 true ；否则，返回 false</p>
</li>
</ul>
<p><strong>说明：</strong></p>
<p>你只能使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<p><strong>题解：</strong></p>
<ul>
<li>注意这个题目和上一个题目的区别，上个题目是对输入操作进行处理，这个是对输出进行处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用栈实现队列，也就是后入先出转换为先入先出</span></span><br><span class="line">    <span class="comment">//使用双栈的方式</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question42-实现二叉树的反转"><a href="#Question42-实现二叉树的反转" class="headerlink" title="Question42:实现二叉树的反转"></a>Question42:实现二叉树的反转</h3><p><strong>题目描述：</strong></p>
<p><img src="/2022/11/14/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8D%E8%BD%AC.png" alt="二叉树反转"></p>
<p><strong>题解：</strong></p>
<p><strong>方法一：递归</strong></p>
<ul>
<li>这里要注意一下，使用递归的时候，一般采用设置一个新函数，然后调用这个函数即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        //递归实现</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        inverse(root);</span><br><span class="line">        return root;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void inverse(TreeNode node) &#123;</span><br><span class="line">        if(node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        TreeNode temp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        inverse(node.left);</span><br><span class="line">        inverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question43-给数组元素划分区间"><a href="#Question43-给数组元素划分区间" class="headerlink" title="Question43:给数组元素划分区间"></a>Question43:给数组元素划分区间</h3><p><strong>题目描述：</strong></p>
<p>给定一个  无重复元素 的 有序 整数数组 nums 。</p>
<ul>
<li><p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p>
</li>
<li><p>列表中的每个区间范围 [a,b] 应该按如下格式输出：</p>
<p>“a-&gt;b” ，如果 a !&#x3D; b<br>“a” ，如果 a &#x3D;&#x3D; b</p>
</li>
</ul>
<p><strong>举例：</strong></p>
<p><img src="/2022/11/14/LeetCode/%E5%88%92%E5%88%86%E5%8C%BA%E9%97%B4.png" alt="划分区间"></p>
<p><strong>题解：</strong></p>
<p>设置双指针，如果值相等，输出一个数字，否则输出指定形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">summaryRanges</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(Integer.toString(nums[low]));</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                temp.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                temp.append(Integer.toString(nums[high]));</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(temp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question44-判断一个数是不是2的幂次"><a href="#Question44-判断一个数是不是2的幂次" class="headerlink" title="Question44:判断一个数是不是2的幂次"></a>Question44:判断一个数是不是2的幂次</h3><p><strong>题目描述：</strong></p>
<p>输入一个数，判断这个数是不是2的幂次</p>
<p><strong>题解：</strong></p>
<ul>
<li>首先要注意，负数和0都不是2的幂次</li>
</ul>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据二进制数可以知道，如果一个数为2的幂次，那么这个数的二进制一定只有一个1，因此将n和(n-1)做与运算所得结果一定是0.</p>
<p><strong>方法二：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; -n) == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在计算机系统之中，负数是根据补码来保存的，因此通过n和-n的与运算也可以判断这个数是不是2的幂次。</p>
<p><strong>方法三：个人做法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question45-设计Goal解析器"><a href="#Question45-设计Goal解析器" class="headerlink" title="Question45:设计Goal解析器"></a>Question45:设计Goal解析器</h3><p><strong>题目描述：</strong></p>
<p>请你设计一个可以解释字符串 command 的 Goal 解析器 。command 由 “G”、”()” 和&#x2F;或 “(al)” 按某种顺序组成。Goal 解析器会将 “G” 解释为字符串 “G”、”()” 解释为字符串 “o” ，”(al)” 解释为字符串 “al” 。然后，按原顺序将经解释得到的字符串连接成一个字符串。</p>
<ul>
<li>给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>采用判断子字符串的方法，分别讨论出现三种情况下的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String interpret(String command) &#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; command.length(); i++) &#123;</span><br><span class="line">            if (command.substring(i,i+1).equals(&quot;G&quot;))&#123;</span><br><span class="line">                sb.append(&quot;G&quot;);</span><br><span class="line">            &#125; else if (command.substring(i,i+2).equals(&quot;()&quot;))&#123;</span><br><span class="line">                sb.append(&quot;o&quot;);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sb.append(&quot;al&quot;);</span><br><span class="line">                i+=3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String res = sb.toString();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<ul>
<li>代码简洁，但是时间复杂度和空间复杂度都不好</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> command.replace(<span class="string">&quot;()&quot;</span>,<span class="string">&quot;o&quot;</span>).replace(<span class="string">&quot;(al)&quot;</span>,<span class="string">&quot;al&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question46-判断回文链表"><a href="#Question46-判断回文链表" class="headerlink" title="Question46:判断回文链表"></a>Question46:判断回文链表</h3><p><strong>题目描述：</strong></p>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> </p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>要实现O(n)的时间复杂度和O(1)的空间复杂度，就需要反转后半部分来做</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">        //要实现O(n)的时间复杂度和O(1)的空间复杂度，就需要反转后半部分来做</span><br><span class="line">        if(head == null || head.next == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line"></span><br><span class="line">        //利用快慢指针，来找到中间节点</span><br><span class="line">        while(fast.next != null &amp;&amp; fast.next.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //反转后半部分链表</span><br><span class="line">        slow = reverse(slow.next);</span><br><span class="line">        while(slow != null) &#123;</span><br><span class="line">            if(head.val != slow.val) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    反转的方法（迭代法）</span><br><span class="line">     */</span><br><span class="line">    private ListNode reverse(ListNode head) &#123;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode next = null;</span><br><span class="line"></span><br><span class="line">        while(head != null) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    反转的方式（递归）</span><br><span class="line">     */</span><br><span class="line">    private ListNode reverse1(ListNode head)&#123;</span><br><span class="line">        // 递归到最后一个节点，返回新的新的头结点</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = null;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意反转的操作</li>
</ul>
<hr>
<h3 id="Question47-有效的字母异位词"><a href="#Question47-有效的字母异位词" class="headerlink" title="Question47:有效的字母异位词"></a>Question47:有效的字母异位词</h3><p><strong>题目描述：</strong></p>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<ul>
<li>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：个人做法</strong></p>
<p>把两个字符串中的字符出现的次数放入到两个map之中，然后比较这两个map是否相同即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用两个map来保存两个字符串分别出现的次数</span></span><br><span class="line">        Map&lt;Character,Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character,Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map1.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                map1.put(s.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                map1.put(s.charAt(i),map1.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!map2.containsKey(t.charAt(i))) &#123;</span><br><span class="line">                map2.put(t.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                map2.put(t.charAt(i),map2.get(t.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map1.equals(map2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>将两个字符串进行排序，比较排序之后的字符串是否相同即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        if (s.length() != t.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] str1 = s.toCharArray();</span><br><span class="line">        char[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        return Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：哈希表</strong></p>
<p>从另一个角度考虑，t 是 s 的异位词等价于<strong>两个字符串中字符出现的种类和次数均相等</strong>。由于字符串只包含 26 个小写字母，因此我们可以维护一个长度为 26 的频次数组table，先遍历记录字符串 s 中字符出现的频次，然后遍历字符串 t，减去table 中对应的频次，如果出现table[i]&lt;0，则说明 t 包含一个不在 s 中的额外字符，返回false 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] table = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            table[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            table[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (table[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question48-各位相加"><a href="#Question48-各位相加" class="headerlink" title="Question48:各位相加"></a>Question48:各位相加</h3><p><strong>题目描述：</strong></p>
<p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p>
<p><strong>举个例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 38</span><br><span class="line">输出: 2 </span><br><span class="line">解释: 各位相加的过程为：</span><br><span class="line">38 --&gt; 3 + 8 --&gt; 11</span><br><span class="line">11 --&gt; 1 + 1 --&gt; 2</span><br><span class="line">由于 2 是一位数，所以返回 2。</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>思路最简单的方法，就是利用迭代，一直对数字进行处理，直到数字为个位数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += num % <span class="number">10</span>;</span><br><span class="line">                num /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>利用数根的思想</p>
<p><img src="/2022/11/14/LeetCode/%E6%A0%91%E6%A0%B9.png" alt="树根"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question49-丑数"><a href="#Question49-丑数" class="headerlink" title="Question49:丑数"></a>Question49:丑数</h3><p><strong>题目描述：</strong></p>
<p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和 <code>5</code> 的正整数。</p>
<p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>题解：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] factors = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> factor : factors) &#123;</span><br><span class="line">            <span class="keyword">while</span>(n % factor == <span class="number">0</span>) &#123;</span><br><span class="line">                n /= factor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question50-丢失的数字"><a href="#Question50-丢失的数字" class="headerlink" title="Question50:丢失的数字"></a>Question50:丢失的数字</h3><p><strong>题目描述：</strong></p>
<p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<ol>
<li>将数组进行排序</li>
<li>遍历排序后的数组，看nums[i] 和 i是否相等</li>
<li>如果不相等，就代表i缺失</li>
<li>如果遍历的结果发现都相等，那么缺失的就是最后一个数字，返回n即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">missing</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i)) &#123;</span><br><span class="line">                missing = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：位运算</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            xor ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            xor ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法四：数学计算</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arrSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total - arrSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question51-统计一致字符串的数目"><a href="#Question51-统计一致字符串的数目" class="headerlink" title="Question51:统计一致字符串的数目"></a>Question51:统计一致字符串的数目</h3><p><strong>题目描述：</strong></p>
<p>给你一个由不同字符组成的字符串 allowed 和一个字符串数组 words 。如果一个字符串的每一个字符都在 allowed 中，就称这个字符串是 一致字符串 。</p>
<ul>
<li>请你返回 words 数组中 一致字符串的数目。</li>
</ul>
<p><strong>举例子：</strong></p>
<p><img src="/2022/11/14/LeetCode/%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%9B%AE.png" alt="统计数目"></p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>个人做法：</p>
<ol>
<li>对allowed字符串进行遍历，取出每一个字符放到一个Set集合之中</li>
<li>然后对word进行遍历，只要有一个字符不在allowed之中，就返回false</li>
<li>否则，执行count++</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countConsistentStrings</span><span class="params">(String allowed, String[] words)</span> &#123;</span><br><span class="line">        <span class="comment">//先将allowed中的每一个字符都取出放入一个set集合之中</span></span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allowed.length(); i++) &#123;</span><br><span class="line">            set.add(allowed.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(words[i].charAt(j)))&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question52-第一个错误版本"><a href="#Question52-第一个错误版本" class="headerlink" title="Question52:第一个错误版本"></a>Question52:第一个错误版本</h3><p><strong>题目描述：</strong></p>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<ul>
<li><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
</li>
<li><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
</li>
</ul>
<p><strong>题解：</strong></p>
<p>题目思路很简单，就是利用二分查找法就可以了，不断循环为right赋值即可</p>
<ul>
<li>注意：二分法要采用left + (right-left)&#x2F;2的方式，不然就超界限了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* The isBadVersion API is defined in the parent class VersionControl.</span><br><span class="line">      boolean isBadVersion(int version); */</span><br><span class="line"></span><br><span class="line">public class Solution extends VersionControl &#123;</span><br><span class="line">    public int firstBadVersion(int n) &#123;</span><br><span class="line">        //简单的二分查找算法</span><br><span class="line">        int left = 1;</span><br><span class="line">        int right = n;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(left &lt;= right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if(isBadVersion(mid)) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question53-移动零"><a href="#Question53-移动零" class="headerlink" title="Question53:移动零"></a>Question53:移动零</h3><p><strong>题目描述：</strong></p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<ul>
<li><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：遍历</strong></p>
<p>个人思路很简单</p>
<ol>
<li>首先先遍历数组，在遇到0的时候停下来</li>
<li>找0后面的第一个不是0的数据</li>
<li>将这两个数据做交换即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                        nums[i] = nums[j];</span><br><span class="line">                        nums[j] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：二次遍历</strong></p>
<ul>
<li>比刚刚的算法要好的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public void moveZeroes(int[] nums) &#123;</span><br><span class="line">		if(nums==null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]</span><br><span class="line">		int j = 0;</span><br><span class="line">		for(int i=0;i&lt;nums.length;++i) &#123;</span><br><span class="line">			if(nums[i]!=0) &#123;</span><br><span class="line">				nums[j++] = nums[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//非0元素统计完了，剩下的都是0了</span><br><span class="line">		//所以第二次遍历把末尾的元素都赋为0即可</span><br><span class="line">		for(int i=j;i&lt;nums.length;++i) &#123;</span><br><span class="line">			nums[i] = 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question54-单词规律"><a href="#Question54-单词规律" class="headerlink" title="Question54:单词规律"></a>Question54:单词规律</h3><p><strong>题目描述：</strong></p>
<p>给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。</p>
<ul>
<li>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。</li>
</ul>
<p><strong>举例：</strong></p>
<p><img src="/2022/11/14/LeetCode/%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B.png" alt="单词规律"></p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>个人解法：</p>
<ol>
<li>首先将整个字符串分割成一个一个的单词</li>
<li>创建一个hashmap，里面存储character-string键值对</li>
<li>有两种情况会出现false 一是不含key，但是含有value；一种是不匹配</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String s)</span> &#123;</span><br><span class="line">        <span class="comment">//个人思路是利用HashMap来进行判断</span></span><br><span class="line">        String[] strings = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pattern.length() != strings.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(pattern.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsValue(strings[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(map.containsKey(pattern.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.get(pattern.charAt(i)).equals(strings[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(pattern.charAt(i),strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：双表</strong></p>
<p>思路是创建两个hashmap来判断对应关系</p>
<p>降低了时间复杂度，运行性能更好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String str)</span> &#123;</span><br><span class="line">        Map&lt;String, Character&gt; str2ch = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Character&gt;();</span><br><span class="line">        Map&lt;Character, String&gt; ch2str = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; pattern.length(); ++p) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> pattern.charAt(p);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; m &amp;&amp; str.charAt(j) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> str.substring(i, j);</span><br><span class="line">            <span class="keyword">if</span> (str2ch.containsKey(tmp) &amp;&amp; str2ch.get(tmp) != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch2str.containsKey(ch) &amp;&amp; !tmp.equals(ch2str.get(ch))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str2ch.put(tmp, ch);</span><br><span class="line">            ch2str.put(ch, tmp);</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question55-Nim游戏"><a href="#Question55-Nim游戏" class="headerlink" title="Question55:Nim游戏"></a>Question55:Nim游戏</h3><p><strong>题目描述：</strong></p>
<p><img src="/2022/11/14/LeetCode/nim%E6%B8%B8%E6%88%8F.png" alt="nim游戏"></p>
<p><strong>题解：</strong></p>
<ul>
<li>分析：这个题目涉及到数学问题，如果场上只有四个的话，那么你拿多少个对方都会赢；如果大于四个的话，你就可以拿走n个，使得场上始终是4的倍数，这样的话你就总是会赢。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question56-区域和检索–数组不可变"><a href="#Question56-区域和检索–数组不可变" class="headerlink" title="Question56:区域和检索–数组不可变"></a>Question56:区域和检索–数组不可变</h3><p><strong>题目描述：</strong></p>
<p>给定一个整数数组  nums，处理以下类型的多个查询:</p>
<p>计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;&#x3D; right<br>实现 NumArray 类：</p>
<ul>
<li><p>NumArray(int[] nums) 使用数组 nums 初始化对象</p>
</li>
<li><p>int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + … + nums[right] )</p>
</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：前缀法</strong></p>
<ul>
<li>避免了每一次都要循环计算的笨蛋方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sums[i] = sums[i-<span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sums[right];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sums[right] - sums[left-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question57-判断数字是否为3的幂次"><a href="#Question57-判断数字是否为3的幂次" class="headerlink" title="Question57:判断数字是否为3的幂次"></a>Question57:判断数字是否为3的幂次</h3><p><strong>题目描述：</strong></p>
<p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>整体思路就是最简单的判断，一直取模，结果为0的话就一直除以3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span> &amp;&amp; n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>奇技淫巧：用整数范围内的最大整数对这个数取模，如果结果为0，就代表这个数为3的幂次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question58-比特位计数"><a href="#Question58-比特位计数" class="headerlink" title="Question58:比特位计数"></a>Question58:比特位计数</h3><p><strong>题目描述：</strong></p>
<p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>直接计算其中的每一个数字的1的位数，然后进行返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nums[i] = countOnes(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countOnes</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= x-<span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：最高有效位</strong></p>
<p>举个例子就是，如果当前要判断的数字是7，7的二进制为111，他比(7-4)&#x3D;3的二进制11只多了一个1，所以3的1的个数+1就是7的二进制中的1的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">highBit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：最低有效位</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法四：最低设置位</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question59-判断数字是否为4的幂次"><a href="#Question59-判断数字是否为4的幂次" class="headerlink" title="Question59:判断数字是否为4的幂次"></a>Question59:判断数字是否为4的幂次</h3><p><strong>题目描述：</strong></p>
<p>判断一个数字是不是4的幂次。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：迭代法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n /= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：数学法</strong></p>
<ul>
<li>一个数如果是4的幂次，那么n%3的值为1；并且一定是2的幂次</li>
<li>如果一个数是2的幂次而不是4的幂次，那么n%3的值为2，因此根据上述的两个条件就可以判断这个数是否为4的幂次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    bool <span class="title function_">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; n % <span class="number">3</span> == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question60-反转字符串"><a href="#Question60-反转字符串" class="headerlink" title="Question60:反转字符串"></a>Question60:反转字符串</h3><p><strong>题目描述：</strong></p>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<ul>
<li>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</li>
</ul>
<p>举例：</p>
<p><img src="/2022/11/14/LeetCode/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="反转字符串"></p>
<p><strong>题解：</strong></p>
<p><strong>方法一：单指针</strong></p>
<p>个人做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[i];</span><br><span class="line">            s[i] = s[n-<span class="number">1</span>-i];</span><br><span class="line">            s[n-<span class="number">1</span>-i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：双指针</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没啥可说的，很简单的题目</li>
</ul>
<hr>
<h3 id="Question61-判断字符串的两半是否相似"><a href="#Question61-判断字符串的两半是否相似" class="headerlink" title="Question61:判断字符串的两半是否相似"></a>Question61:判断字符串的两半是否相似</h3><p><strong>题目描述：</strong></p>
<p>给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。</p>
<ul>
<li><p>两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。</p>
</li>
<li><p>如果 a 和 b 相似，返回 true ；否则，返回 false 。</p>
</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">halvesAreAlike</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) == <span class="string">&#x27;a&#x27;</span> || </span><br><span class="line">            s.charAt(left) == <span class="string">&#x27;e&#x27;</span> ||</span><br><span class="line">            s.charAt(left) == <span class="string">&#x27;i&#x27;</span> ||</span><br><span class="line">            s.charAt(left) == <span class="string">&#x27;o&#x27;</span> ||</span><br><span class="line">            s.charAt(left) == <span class="string">&#x27;u&#x27;</span> ||</span><br><span class="line">            s.charAt(left) == <span class="string">&#x27;A&#x27;</span> ||</span><br><span class="line">            s.charAt(left) == <span class="string">&#x27;E&#x27;</span> ||</span><br><span class="line">            s.charAt(left) == <span class="string">&#x27;I&#x27;</span> ||</span><br><span class="line">            s.charAt(left) == <span class="string">&#x27;O&#x27;</span> ||</span><br><span class="line">            s.charAt(left) == <span class="string">&#x27;U&#x27;</span> )&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(right) == <span class="string">&#x27;a&#x27;</span> || </span><br><span class="line">            s.charAt(right) == <span class="string">&#x27;e&#x27;</span> ||</span><br><span class="line">            s.charAt(right) == <span class="string">&#x27;i&#x27;</span> ||</span><br><span class="line">            s.charAt(right) == <span class="string">&#x27;o&#x27;</span> ||</span><br><span class="line">            s.charAt(right) == <span class="string">&#x27;u&#x27;</span> ||</span><br><span class="line">            s.charAt(right) == <span class="string">&#x27;A&#x27;</span> ||</span><br><span class="line">            s.charAt(right) == <span class="string">&#x27;E&#x27;</span> ||</span><br><span class="line">            s.charAt(right) == <span class="string">&#x27;I&#x27;</span> ||</span><br><span class="line">            s.charAt(right) == <span class="string">&#x27;O&#x27;</span> ||</span><br><span class="line">            s.charAt(right) == <span class="string">&#x27;U&#x27;</span> )&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样写代码的可读性容易，但是运行性能也很差</li>
</ul>
<p><strong>方法二：官方解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">halvesAreAlike</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, s.length() / <span class="number">2</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> s.substring(s.length() / <span class="number">2</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">h</span> <span class="operator">=</span> <span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h.indexOf(a.charAt(i)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h.indexOf(b.charAt(i)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum1 == sum2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码易理解并且运行性能好于第一种方法</li>
</ul>
<p><strong>方法三：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">halvesAreAlike</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">h</span> <span class="operator">=</span> <span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(h.indexOf(s.charAt(left)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(h.indexOf(s.charAt(right)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>借鉴官方答案之后修改的方法一，运行性能最优</li>
</ul>
<hr>
<h3 id="Question62-反转字符串中的元音字母"><a href="#Question62-反转字符串中的元音字母" class="headerlink" title="Question62:反转字符串中的元音字母"></a>Question62:反转字符串中的元音字母</h3><p><strong>题目描述：</strong></p>
<p>给你一个字符串 <code>s</code> ，仅反转字符串中的所有元音字母，并返回结果字符串。</p>
<ul>
<li>元音字母包括 <code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code>、<code>&#39;u&#39;</code>，且可能以大小写两种形式出现。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseVowels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="type">String</span> <span class="variable">h</span> <span class="operator">=</span> <span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(h.indexOf(s.charAt(left)) &gt;= <span class="number">0</span> &amp;&amp; h.indexOf(s.charAt(right)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                temp = str[left];</span><br><span class="line">                str[left] = str[right];</span><br><span class="line">                str[right] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(h.indexOf(s.charAt(left)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(h.indexOf(s.charAt(right)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question63-求两个数组的交集"><a href="#Question63-求两个数组的交集" class="headerlink" title="Question63:求两个数组的交集"></a>Question63:求两个数组的交集</h3><p><strong>题目描述：</strong></p>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> </p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            set2.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getIntersection(set1, set2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getIntersection(Set&lt;Integer&gt; set1, Set&lt;Integer&gt; set2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set1.size() &gt; set2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIntersection(set2, set1);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; intersectionSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.contains(num)) &#123;</span><br><span class="line">                intersectionSet.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] intersection = <span class="keyword">new</span> <span class="title class_">int</span>[intersectionSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : intersectionSet) &#123;</span><br><span class="line">            intersection[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>性能一般</li>
</ul>
<p><strong>方法二：</strong></p>
<p>对数组进行排序之后再进行判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span>[] intersection = <span class="keyword">new</span> <span class="title class_">int</span>[length1 + length2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                <span class="comment">// 保证加入元素的唯一性</span></span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span> || num1 != intersection[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                    intersection[index++] = num1;</span><br><span class="line">                &#125;</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(intersection, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question64-将有序数组转化为二叉平衡树"><a href="#Question64-将有序数组转化为二叉平衡树" class="headerlink" title="Question64:将有序数组转化为二叉平衡树"></a>Question64:将有序数组转化为二叉平衡树</h3><p><strong>题目描述：</strong></p>
<p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<ul>
<li>高度平衡二叉树是一棵满足每个节点的左右两个子树的高度差的绝对值不超过 1 的二叉树。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums == <span class="literal">null</span> ? <span class="literal">null</span> : buildTree(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = buildTree(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question65-判断二叉树是否为平衡二叉树"><a href="#Question65-判断二叉树是否为平衡二叉树" class="headerlink" title="Question65:判断二叉树是否为平衡二叉树"></a>Question65:判断二叉树是否为平衡二叉树</h3><p><strong>题目描述：</strong></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<ul>
<li>本题中，高度平衡二叉树定义为：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：由上到下递归判断</strong></p>
<p>思路：就是从根节点开始向下递归判断当前节点的左子树和右子树是否满足平衡树的条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(height(root.left), height(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：从下到上的判断</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> height(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> height(root.right);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果子树为不平衡的，那么整个树也一定是不平衡的</li>
<li>空间复杂度不变的情况下，将时间复杂度减少了。从O(n*n)–&gt;O(n)</li>
</ul>
<hr>
<h3 id="Question66-求二叉树的最小深度"><a href="#Question66-求二叉树的最小深度" class="headerlink" title="Question66:求二叉树的最小深度"></a>Question66:求二叉树的最小深度</h3><p><strong>题目描述：</strong></p>
<p>求一个二叉树的最小深度</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>和之前求最大深度一样（Q20），只不过把max改成min即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 执行用时：12 ms, 在所有 Java 提交中击败了10.41%的用户</span></span><br><span class="line"><span class="comment">内存消耗：61.5 MB, 在所有 Java 提交中击败了17.58%的用户</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Math.min(minDepth(root.left),minDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：深度优先算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行用时：6 ms, 在所有 Java 提交中击败了67.72%的用户</span></span><br><span class="line"><span class="comment">内存消耗：61 MB, 在所有 Java 提交中击败了56.08%的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min_depth</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：广度优先算法</strong></p>
<p>思想就是，我们在找到一个叶子结点的时候，就把这个节点的深度返回，这样就保证了最先搜索到的叶子结点的深度最小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 执行用时：1 ms, 在所有 Java 提交中击败了92.98%的用户</span></span><br><span class="line"><span class="comment">内存消耗：60.3 MB, 在所有 Java 提交中击败了89.46%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">QueueNode</span> &#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">QueueNode</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">            <span class="built_in">this</span>.depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;QueueNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;QueueNode&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">QueueNode</span>(root, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">QueueNode</span> <span class="variable">nodeDepth</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeDepth.node;</span><br><span class="line">            <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> nodeDepth.depth;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">QueueNode</span>(node.left, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">QueueNode</span>(node.right, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question67-二叉树的所有路径"><a href="#Question67-二叉树的所有路径" class="headerlink" title="Question67:二叉树的所有路径"></a>Question67:二叉树的所有路径</h3><p><strong>题目描述：</strong></p>
<p><img src="/2022/11/14/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84.png" alt="二叉树的路径"></p>
<p><strong>题解：</strong></p>
<p><strong>方法一：深度优先算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**执行用时：8 ms, 在所有 Java 提交中击败了32.05%的用户</span></span><br><span class="line"><span class="comment">内存消耗：41.9 MB, 在所有 Java 提交中击败了23.43%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        addList(root,<span class="string">&quot;&quot;</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addList</span><span class="params">(TreeNode root, String str, List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str += root.val;</span><br><span class="line">        <span class="comment">//遍历到叶子节点的时候</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            addList(root.left, str , list);</span><br><span class="line">            addList(root.right, str , list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：广度优先算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> paths;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;String&gt; pathQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        pathQueue.offer(Integer.toString(root.val));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeQueue.poll(); </span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> pathQueue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                paths.add(path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nodeQueue.offer(node.left);</span><br><span class="line">                    pathQueue.offer(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(path).append(<span class="string">&quot;-&gt;&quot;</span>).append(node.left.val).toString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nodeQueue.offer(node.right);</span><br><span class="line">                    pathQueue.offer(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(path).append(<span class="string">&quot;-&gt;&quot;</span>).append(node.right.val).toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question68-两个数组的交集"><a href="#Question68-两个数组的交集" class="headerlink" title="Question68:两个数组的交集"></a>Question68:两个数组的交集</h3><p><strong>题目描述：</strong></p>
<p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
<p><strong>题解：</strong></p>
<ul>
<li>一共有三种方法放在一起介绍了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用集合来实现</span></span><br><span class="line"><span class="comment">     * 执行用时：10 ms, 在所有 Java 提交中击败了5.09%的用户</span></span><br><span class="line"><span class="comment">     * 内存消耗：41.3 MB, 在所有 Java 提交中击败了85.25%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect_1(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num1 : nums1) &#123;</span><br><span class="line">            list1.add(num1);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num2 : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.contains(num2)) &#123;</span><br><span class="line">                list2.add(num2);</span><br><span class="line">                list1.remove(Integer.valueOf(num2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list2.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : list2) &#123;</span><br><span class="line">            res[i++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用map实现</span></span><br><span class="line"><span class="comment">     * 执行用时：3 ms, 在所有 Java 提交中击败了40.89%的用户</span></span><br><span class="line"><span class="comment">     * 内存消耗：41.7 MB, 在所有 Java 提交中击败了32.18%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect_2(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//将nums1的元素放入到map之中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : nums1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(value)) &#123;</span><br><span class="line">                map.put(value, map.get(value)+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(value,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//逐个取出nums2之中的元素，来判断是否位于map中，如果位于map之中，</span></span><br><span class="line">        <span class="comment">// 那么就将他加到list之中，并且要将这个值的次数减一</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(value)) &#123;</span><br><span class="line">                list.add(value);</span><br><span class="line">                map.put(value,map.get(value)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : list) &#123;</span><br><span class="line">            res[i++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用预排序的方法</span></span><br><span class="line"><span class="comment">     * 执行用时：2 ms, 在所有 Java 提交中击败了95.48%的用户</span></span><br><span class="line"><span class="comment">     * 内存消耗：41.5 MB, 在所有 Java 提交中击败了55.10%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect_3(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//首先对两个数组进行排序</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;i &lt; nums1.length &amp;&amp; j &lt; nums2.length;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : list) &#123;</span><br><span class="line">            res[i++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question69-判断一个数字是否为完全平方数"><a href="#Question69-判断一个数字是否为完全平方数" class="headerlink" title="Question69:判断一个数字是否为完全平方数"></a>Question69:判断一个数字是否为完全平方数</h3><p><strong>题目描述：</strong></p>
<p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<ul>
<li>进阶：不要 使用任何内置的库函数，如  sqrt 。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<ul>
<li>利用二分法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//num == mid * mid 越界了</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> num / mid;</span><br><span class="line">            <span class="keyword">if</span> (t == mid) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num % mid == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; mid) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question70-猜数字的大小"><a href="#Question70-猜数字的大小" class="headerlink" title="Question70:猜数字的大小"></a>Question70:猜数字的大小</h3><p><strong>题目描述：</strong></p>
<p>猜数字游戏的规则如下：</p>
<p>每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。<br>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。<br>你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：</p>
<ul>
<li>-1：我选出的数字比你猜的数字小 pick &lt; num</li>
<li>1：我选出的数字比你猜的数字大 pick &gt; num</li>
<li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick &#x3D;&#x3D; num</li>
<li>返回我选出的数字。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：二分法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Forward declaration of guess API.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  num   your guess</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 	     -1 if num is higher than the picked number</span></span><br><span class="line"><span class="comment"> *			      1 if num is lower than the picked number</span></span><br><span class="line"><span class="comment"> *               otherwise return 0</span></span><br><span class="line"><span class="comment"> * int guess(int num);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：37.9 MB, 在所有 Java 提交中击败了97.94%的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">GuessGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">guess</span> <span class="operator">=</span> guess(mid);</span><br><span class="line">            <span class="keyword">if</span> (guess == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guess == <span class="number">1</span>) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question71-卡车上的最大单元数"><a href="#Question71-卡车上的最大单元数" class="headerlink" title="Question71:卡车上的最大单元数"></a>Question71:卡车上的最大单元数</h3><p><strong>题目描述：</strong></p>
<p>请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] &#x3D; [numberOfBoxes, numberOfUnitsPerBox] ：</p>
<ul>
<li><ul>
<li>numberOfBoxes 是类型 i 的箱子的数量。</li>
<li>numberOfUnitsPerBox 是类型 i 每个箱子可以装载的单元数量。</li>
<li>整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。</li>
</ul>
</li>
<li>返回卡车可以装载 单元 的 最大 总数。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>分析：</strong></p>
<p>先理解题目的意思：就是说要往卡车上装箱子，卡车可以容纳的箱子数量是一定的，但是每个箱子可以装的东西数目不一样，如何可以往卡车中装入最多的东西</p>
<p>思路就是把能装最多东西的箱子放上去，以此类推。</p>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行用时：22 ms, 在所有 Java 提交中击败了15.88%的用户</span></span><br><span class="line"><span class="comment">内存消耗：41.6 MB, 在所有 Java 提交中击败了81.10%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumUnits</span><span class="params">(<span class="type">int</span>[][] boxTypes, <span class="type">int</span> truckSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (truckSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxBox</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//寻找最大储货量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">numBox</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//存放出货量最大的箱子的数目</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; boxTypes.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (boxTypes[i][<span class="number">1</span>] &gt; maxBox) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    numBox = boxTypes[i][<span class="number">0</span>];</span><br><span class="line">                    maxBox = boxTypes[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxBox == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (truckSize &gt; numBox) &#123;</span><br><span class="line">                res += (numBox * maxBox);</span><br><span class="line">                truckSize -= numBox;</span><br><span class="line">                boxTypes[index][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += truckSize * maxBox;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>贪心算法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumUnits</span><span class="params">(<span class="type">int</span>[][] boxTypes, <span class="type">int</span> truckSize)</span> &#123;</span><br><span class="line">        Arrays.sort(boxTypes, (a, b) -&gt; b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] boxType : boxTypes) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numberOfBoxes</span> <span class="operator">=</span> boxType[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">numberOfUnitsPerBox</span> <span class="operator">=</span> boxType[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (numberOfBoxes &lt; truckSize) &#123;</span><br><span class="line">                res += numberOfBoxes * numberOfUnitsPerBox;</span><br><span class="line">                truckSize -= numberOfBoxes;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += truckSize * numberOfUnitsPerBox;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question72-找到最高海拔"><a href="#Question72-找到最高海拔" class="headerlink" title="Question72:找到最高海拔"></a>Question72:找到最高海拔</h3><p><strong>题目描述：</strong></p>
<p>有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。自行车手从海拔为 0 的点 0 开始骑行。</p>
<ul>
<li>给你一个长度为 n 的整数数组 gain ，其中 gain[i] 是点 i 和点 i + 1 的净海拔高度差（0 &lt;&#x3D; i &lt; n）。请你返回最高点的海拔 。</li>
<li>就是说在骑行过程中，自行车手有可能在上坡也有可能在下坡，找到他途径的最高的地方的海拔。</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<ul>
<li>创建一个数组，将所有途经的海拔都放进去</li>
<li>对数组进行排序，取出最大的数字</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestAltitude</span><span class="params">(<span class="type">int</span>[] gain)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[gain.length + <span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= gain.length; i++) &#123;</span><br><span class="line">            res[i] = res[i-<span class="number">1</span>] + gain[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res[gain.length];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度过高，不予考虑</li>
</ul>
<p><strong>方法二：</strong></p>
<ul>
<li>对方法一的优化，不再创建数组来求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">	内存消耗：39.2 MB, 在所有 Java 提交中击败了45.39%的用户</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestAltitude</span><span class="params">(<span class="type">int</span>[] gain)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gain.length; i++) &#123;</span><br><span class="line">            h += gain[i];</span><br><span class="line">            ans = Math.max(ans,h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question73-找到所有数组中消失的数字"><a href="#Question73-找到所有数组中消失的数字" class="headerlink" title="Question73:找到所有数组中消失的数字"></a>Question73:找到所有数组中消失的数字</h3><p><strong>题目描述：</strong></p>
<p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p>
<p><strong>题解：</strong></p>
<ul>
<li>个人思路当然是暴力法进行求解，不出所料会超时</li>
</ul>
<p><strong>官方解答：</strong></p>
<ol>
<li>首先，先取出现在的这个数字，减去1得到这个数字对应的下标</li>
<li>对这个下标对应的数字进行加n的操作</li>
<li>然后再遍历这个数组，其中数字小于n的就代表没有被操作过</li>
<li>这个下标+1即为未出现的数字</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：3 ms, 在所有 Java 提交中击败了99.63%的用户</span></span><br><span class="line"><span class="comment">内存消耗：49.3 MB, 在所有 Java 提交中击败了66.35%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//首先，先将出现的数字所对应的下标的数字加上n</span></span><br><span class="line">        <span class="comment">//为了防止当前数字已经实现了+n操作，下标溢出，因此进行取模操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (num - <span class="number">1</span>) % n;</span><br><span class="line">            nums[index] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将所有小于n的数字的下标+1加入到结果集之中即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= n) &#123;</span><br><span class="line">                res.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question74-汉明距离"><a href="#Question74-汉明距离" class="headerlink" title="Question74:汉明距离"></a>Question74:汉明距离</h3><p><strong>题目描述：</strong></p>
<p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：38.9 MB, 在所有 Java 提交中击败了5.15%的用户 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">//个人思路：可以先求两个数字&amp;之后的1的个数，</span></span><br><span class="line">        <span class="comment">//再求两个数字|之后的1的个数，用后者减去前者即可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res1</span> <span class="operator">=</span> x &amp; y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res2</span> <span class="operator">=</span> x | y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(res1 != <span class="number">0</span>) &#123;</span><br><span class="line">            res1 &amp;= res1-<span class="number">1</span>;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res2 != <span class="number">0</span>) &#123;</span><br><span class="line">            res2 &amp;= res2-<span class="number">1</span>;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count2 - count1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：内置函数法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：改进的方法一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：38.4 MB, 在所有 Java 提交中击败了49.04%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> x ^ y, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s!=<span class="number">0</span>) &#123;</span><br><span class="line">            s &amp;= s-<span class="number">1</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="Charpter2-Midium"><a href="#Charpter2-Midium" class="headerlink" title="Charpter2-Midium"></a>Charpter2-Midium</h2><h3 id="Question1-两数相加"><a href="#Question1-两数相加" class="headerlink" title="Question1:两数相加"></a>Question1:两数相加</h3><p><strong>题目描述：</strong></p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<ul>
<li><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
</li>
<li><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</li>
</ul>
<p><strong>举例：</strong></p>
<p><img src="/2022/11/14/LeetCode/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.png" alt="两数相加"></p>
<p><strong>题解：</strong></p>
<p>本题中等题目里面较容易地吧，就将两数相加来判断是否产生进位，产生进位的话就把进位的数字也加到下一次相加之中，最后判断是否产生进位，从而再创建一个新节点。最后返回头节点即可。</p>
<p><strong>思路：</strong></p>
<ul>
<li>首先先判断当前节点是否为空，空则赋值为0</li>
<li>将当前两个链表对应的节点以及上一个链表节点的进位相加</li>
<li>如果最后一个节点也有进位产生，则再创建一个值为1的节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num1 + num2 + carry;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>这种题一定不要转换为整数，然后相加之后在转换为链表。因为这样的题目一般long型都不够用的。</p>
<hr>
<h3 id="Question2-找无重复字母的最长子串"><a href="#Question2-找无重复字母的最长子串" class="headerlink" title="Question2:找无重复字母的最长子串"></a>Question2:找无重复字母的最长子串</h3><p><strong>题目描述：</strong></p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>个人认为最简单的就是，采用双指针，不断更新长度即可。</p>
<ol>
<li>先用一个set集合来存储已经出现的字符，并且大小作为最后的返回。</li>
<li>左指针不动，将右指针向右移，遇到重复的数字停下来，然后比较得到子串长度和现有的最长的做对比。</li>
<li>将左指针右移，并且将最左边的字符从set集合中取出。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(end))) &#123;</span><br><span class="line">                set.add(s.charAt(end));</span><br><span class="line">                end++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                set.remove(s.charAt(start));</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(set.size(),max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：（暂时还未理解）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rk</span> <span class="operator">=</span> -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question3-全局倒置与局部倒置"><a href="#Question3-全局倒置与局部倒置" class="headerlink" title="Question3:全局倒置与局部倒置"></a>Question3:全局倒置与局部倒置</h3><p><strong>题目描述：</strong></p>
<p>给你一个长度为 n 的整数数组 nums，表示由范围 [0, n - 1] 内所有整数组成的一个排列。</p>
<p>全局倒置的数目等于满足下述条件不同下标对 (i, j) 的数目：</p>
<ul>
<li><p>0 &lt;&#x3D; i &lt; j &lt; n</p>
</li>
<li><p>nums[i] &gt; nums[j]</p>
</li>
</ul>
<p>局部倒置的数目等于满足下述条件的下标 i 的数目：</p>
<ul>
<li><p>0 &lt;&#x3D; i &lt; n - 1</p>
</li>
<li><p>nums[i] &gt; nums[i + 1]</p>
</li>
</ul>
<p>当数组 nums 中全局倒置的数量等于局部倒置的数量时，返回 true；否则，返回 false 。</p>
<p><strong>题解：</strong></p>
<p>本题采用暴力解决的话会超出时间限制，哪怕只判断这个数组是否有非局部倒置</p>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：1 ms, 在所有 Java 提交中击败了99.46%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：50.4 MB, 在所有 Java 提交中击败了79.89%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIdealPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; min) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min = Math.min(min,nums[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>通过找规律可以发现，当前值要和下标相差小于等于1，不然一定会存在非局部倒置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIdealPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(nums[i] - i) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question4-匹配子序列的单词数"><a href="#Question4-匹配子序列的单词数" class="headerlink" title="Question4:匹配子序列的单词数"></a>Question4:匹配子序列的单词数</h3><p><strong>题目描述：</strong></p>
<p>给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。</p>
<ul>
<li>字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。</li>
<li>例如， “ace” 是 “abcde” 的子序列，但是“aec”就不是“abcde”的子序列</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<ul>
<li>创建一个List数组，里面存储26个数组，分别表示字符串s中每个字母在字符串中的位置</li>
<li>利用二分法来寻找字母在字母在字符串中的位置，如果这个字母不存在，或者它的位置比上一个字母的位置下标小，那么就会去掉这个。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行用时：169 ms, 在所有 Java 提交中击败了20.79%的用户</span></span><br><span class="line"><span class="comment">内存消耗：48.9 MB, 在所有 Java 提交中击败了45.95%的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numMatchingSubseq</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt;[] pos = <span class="keyword">new</span> <span class="title class_">List</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            pos[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            pos[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w.length() &gt; s.length()) &#123;</span><br><span class="line">                --res;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; w.length(); ++i) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> w.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (pos[c - <span class="string">&#x27;a&#x27;</span>].isEmpty() || pos[c - <span class="string">&#x27;a&#x27;</span>].get(pos[c - <span class="string">&#x27;a&#x27;</span>].size() - <span class="number">1</span>) &lt;= p) &#123;</span><br><span class="line">                    --res;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = binarySearch(pos[c - <span class="string">&#x27;a&#x27;</span>], p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;Integer&gt; list, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (list.get(mid) &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<p>​		在上述方法基础上进行优化，因为方法一中是每一个单词分别和字符串 s 进行匹配，这样对于每一次匹配都需要从头开始遍历字符串 s，这增加了额外的时间开销。所以我们考虑将字符串数组 words 中的全部字符串和字符串 s 同时进行匹配——同样对于每一个需要匹配的字符串我们用一个指针来指向它需要匹配的字符，那么在遍历字符串 s 的过程中，对于当前遍历到的字符如果有可以匹配的字符串，那么将对应的字符串指针往后移动一单位即可。那么当字符串 s 遍历结束时，字符串数组中全部字符串的匹配情况也就全部知道了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numMatchingSubseq</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt;[] p = <span class="keyword">new</span> <span class="title class_">Queue</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            p[i] = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; ++i) &#123;</span><br><span class="line">            p[words[i].charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>].offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> p[c - <span class="string">&#x27;a&#x27;</span>].size();</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span>[] t = p[c - <span class="string">&#x27;a&#x27;</span>].poll();</span><br><span class="line">                <span class="keyword">if</span> (t[<span class="number">1</span>] == words[t[<span class="number">0</span>]].length() - <span class="number">1</span>) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++t[<span class="number">1</span>];</span><br><span class="line">                    p[words[t[<span class="number">0</span>]].charAt(t[<span class="number">1</span>]) - <span class="string">&#x27;a&#x27;</span>].offer(t);</span><br><span class="line">                &#125;</span><br><span class="line">                --len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question5-香槟塔"><a href="#Question5-香槟塔" class="headerlink" title="Question5:香槟塔"></a>Question5:香槟塔</h3><p><strong>题目描述：</strong></p>
<p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p>
<ul>
<li><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p>
</li>
<li><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p>
</li>
</ul>
<p><img src="/2022/11/14/LeetCode/image-20221120110112288.png" alt="image-20221120110112288"></p>
<p><strong>题解：</strong></p>
<p><strong>错误解答：</strong></p>
<ul>
<li>自己的想法是，我把这一层倒满之后，剩下的所有的去倒入下一层，所以我只需要考虑每一层的各个杯子所占的比重就可以了</li>
<li>错误原因：不是说这一层全满之后才会流向下一层，中间的杯子肯定先满，然后流向下一层，所以不能计算权重来求解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">champagneTower</span><span class="params">(<span class="type">int</span> poured, <span class="type">int</span> query_row, <span class="type">int</span> query_glass)</span> &#123;</span><br><span class="line">        <span class="comment">//首先，如果上面的香槟没有满的话是不会继续向下流的</span></span><br><span class="line">        <span class="keyword">if</span>((query_row+<span class="number">1</span>)*query_row/<span class="number">2</span> &gt;= poured) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> poured - (query_row+<span class="number">1</span>)*query_row/<span class="number">2</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> curWeight(query_row,query_glass) * res;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法返回当前杯子的权重</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">curWeight</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="type">double</span>[][] weight = <span class="keyword">new</span> <span class="title class_">double</span>[row+<span class="number">1</span>][row+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= row; i++) &#123;</span><br><span class="line">            weight[i][<span class="number">0</span>] = weight[i][i] = Math.pow(<span class="number">0.5</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; row; j++) &#123;</span><br><span class="line">                weight[i][j] = (weight[i-<span class="number">1</span>][j-<span class="number">1</span>]+weight[i-<span class="number">1</span>][j])/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weight[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确解答：</strong></p>
<ul>
<li>实时更新每一层</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">champagneTower</span><span class="params">(<span class="type">int</span> poured, <span class="type">int</span> query_row, <span class="type">int</span> query_glass)</span> &#123;</span><br><span class="line">        <span class="type">double</span> count[] = <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;(<span class="type">double</span>)poured&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= query_row; i++) &#123;</span><br><span class="line">            <span class="type">double</span> arr[] = <span class="keyword">new</span> <span class="title class_">double</span>[i+<span class="number">1</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = Math.max(<span class="number">0</span>,count[<span class="number">0</span>]-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            arr[i] = Math.max(<span class="number">0</span>,count[i-<span class="number">1</span>]-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                arr[j] = (Math.max(<span class="number">0</span>,count[j-<span class="number">1</span>]-<span class="number">1</span>) + Math.max(<span class="number">0</span>,count[j]-<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count = arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(<span class="number">1</span>,count[query_glass]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Question6-分汤"><a href="#Question6-分汤" class="headerlink" title="Question6:分汤"></a>Question6:分汤</h3><p><strong>题目描述：</strong></p>
<p>有 A 和 B 两种类型的汤。一开始每种类型的汤各有 n 毫升。有四种分配操作：</p>
<ul>
<li>提供 100ml 的汤A 和 0ml 的汤B 。</li>
<li>提供 75ml 的汤A 和 25ml 的汤B 。</li>
<li>提供 50ml 的汤A 和 50ml 的汤B 。</li>
<li>提供 25ml 的汤A 和 75ml 的汤B 。</li>
</ul>
<p>当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。</p>
<ul>
<li>注意不存在先分配 100 ml 汤B 的操作。</li>
</ul>
<p>需要返回的值： 汤A 先分配完的概率 +  汤A和汤B 同时分配完的概率 &#x2F; 2。返回值在正确答案 10-5 的范围内将被认为是正确的。</p>
<p><strong>题解：</strong></p>
<ul>
<li><p>个人没什么思路，感觉要用递归来做，其实这个问题不是一个递归问题</p>
</li>
<li><p>由于分配的汤都是25的倍数，因此首先先除以25然后来进行后续的判断</p>
</li>
</ul>
<p><img src="/2022/11/14/LeetCode/image-20221121102912403.png" alt="image-20221121102912403"></p>
<ul>
<li>当n&gt;179*25的时候，基本上都是A先分完，此时，让结果等于1即可</li>
</ul>
<p><strong>方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">soupServings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        n = (<span class="type">int</span>) Math.ceil((<span class="type">double</span>) n / <span class="number">25</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">179</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span>[][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = (dp[Math.max(<span class="number">0</span>, i - <span class="number">4</span>)][j] + dp[Math.max(<span class="number">0</span>, i - <span class="number">3</span>)][Math.max(<span class="number">0</span>, j - <span class="number">1</span>)] + dp[Math.max(<span class="number">0</span>, i - <span class="number">2</span>)][Math.max(<span class="number">0</span>, j - <span class="number">2</span>)] + dp[Math.max(<span class="number">0</span>, i - <span class="number">1</span>)][Math.max(<span class="number">0</span>, j - <span class="number">3</span>)]) / <span class="number">4.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法一的思想是动态规划，也就是自底向上，逐步进行求解</li>
</ul>
<p><strong>方法二：</strong></p>
<ul>
<li>由于方法一自底向上的方法，有着很多的资源浪费，因此，我们可以采取自顶向下的记忆化搜索方式来进行求解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：38.4 MB, 在所有 Java 提交中击败了88.99%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">soupServings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        n = (<span class="type">int</span>) Math.ceil((<span class="type">double</span>) n / <span class="number">25</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">179</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">double</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(n, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[a][b] == <span class="number">0</span>) &#123;</span><br><span class="line">            memo[a][b] = <span class="number">0.25</span> * (dfs(a - <span class="number">4</span>, b) + dfs(a - <span class="number">3</span>, b - <span class="number">1</span>) + dfs(a - <span class="number">2</span>, b - <span class="number">2</span>) + dfs(a - <span class="number">1</span>, b - <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[a][b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question7-最长回文子串"><a href="#Question7-最长回文子串" class="headerlink" title="Question7:最长回文子串"></a>Question7:最长回文子串</h3><p><strong>题目描述：</strong></p>
<p>给定一个字符串s，求字符串中的最长回文子串。</p>
<p><strong>题解：</strong></p>
<p><strong>个人解法：（超时）</strong></p>
<p>最简单的思路：遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length(); j &gt;= i; j--) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> s.substring(i,j);</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str1);</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> sb1.reverse();</span><br><span class="line">                <span class="keyword">if</span> (str1.equals(String.valueOf(sb2))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (str1.length() &gt; res) &#123;</span><br><span class="line">                        res = str1.length();</span><br><span class="line">                        resStr = str1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>超出时间限制啦！得想别的优化算法</li>
</ul>
<p><strong>方法一：</strong></p>
<p>整体思路：动态规划</p>
<ol>
<li><p>首先先判断长度小于等于2的字符串的回文子串情况</p>
</li>
<li><p>然后将长度从2开始递增，如果当前字符串首i尾j一致，那么它的情况就和i+1到j-1的子串的回文情况一致</p>
<p><img src="/2022/11/14/LeetCode/image-20221124123407319.png" alt="image-20221124123407319"></p>
</li>
<li><p>最后记录最长字串和起始位置即可</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行用时：</span></span><br><span class="line"><span class="comment">115 ms, 在所有 Java 提交中击败了41.14%的用户</span></span><br><span class="line"><span class="comment">内存消耗：</span></span><br><span class="line"><span class="comment">44.5 MB, 在所有 Java 提交中击败了19.71%的用户 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 递推开始</span></span><br><span class="line">        <span class="comment">// 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">2</span>; L &lt;= len; L++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：中心扩散算法</strong></p>
<ul>
<li>基于方法一的优化，我们可以找一个最小字串，让他从中心向两边扩散</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 Java 提交中击败了86.20%的用户</span></span><br><span class="line"><span class="comment">内存消耗：41.5 MB, 在所有 Java 提交中击败了68.28%的用户 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//分别代表奇数子串和偶数字串</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> maxLength(s, i, i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> maxLength(s, i, i+<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.max(len1,len2);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; end-start) &#123;</span><br><span class="line">                end = i+len/<span class="number">2</span>;</span><br><span class="line">                start = i-(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLength</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：Manacher算法</strong></p>
<ul>
<li>暂未理解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：15 ms, 在所有 Java 提交中击败了88.65%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：41.6 MB, 在所有 Java 提交中击败了62.46%的用户 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            t.append(s.charAt(i));</span><br><span class="line">            t.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        t.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        s = t.toString();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; arm_len = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> -<span class="number">1</span>, j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur_arm_len;</span><br><span class="line">            <span class="keyword">if</span> (right &gt;= i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i_sym</span> <span class="operator">=</span> j * <span class="number">2</span> - i;</span><br><span class="line">                <span class="type">int</span> <span class="variable">min_arm_len</span> <span class="operator">=</span> Math.min(arm_len.get(i_sym), right - i);</span><br><span class="line">                cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_arm_len = expand(s, i, i);</span><br><span class="line">            &#125;</span><br><span class="line">            arm_len.add(cur_arm_len);</span><br><span class="line">            <span class="keyword">if</span> (i + cur_arm_len &gt; right) &#123;</span><br><span class="line">                j = i;</span><br><span class="line">                right = i + cur_arm_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur_arm_len * <span class="number">2</span> + <span class="number">1</span> &gt; end - start) &#123;</span><br><span class="line">                start = i - cur_arm_len;</span><br><span class="line">                end = i + cur_arm_len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ans.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expand</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right - left - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question8-区间子数组的个数"><a href="#Question8-区间子数组的个数" class="headerlink" title="Question8:区间子数组的个数"></a>Question8:区间子数组的个数</h3><p><strong>题目描述：</strong></p>
<p>给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。</p>
<p><img src="/2022/11/14/LeetCode/image-20221124153411667.png" alt="image-20221124153411667"></p>
<p><strong>题解：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：3 ms, 在所有 Java 提交中击败了90.06%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：49.1 MB, 在所有 Java 提交中击败了28.62%的用户 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayBoundedMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subarrayBoundedMax(nums,right) - subarrayBoundedMax(nums,left-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">subarrayBoundedMax</span><span class="params">(<span class="type">int</span>[] num, <span class="type">int</span> MAX)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resBounded</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] &lt;= MAX) &#123;</span><br><span class="line">                resBounded++;</span><br><span class="line">                res+=resBounded;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resBounded = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question9-情感丰富的单词"><a href="#Question9-情感丰富的单词" class="headerlink" title="Question9:情感丰富的单词"></a>Question9:情感丰富的单词</h3><p><strong>题目描述：</strong></p>
<p>有时候人们会用重复写一些字母来表示额外的感受，比如 “hello” -&gt; “heeellooo”, “hi” -&gt; “hiii”。我们将相邻字母都相同的一串字符定义为相同字母组，例如：”h”, “eee”, “ll”, “ooo”。</p>
<p>对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 c ），然后往其中添加相同的字母 c 使其长度达到 3 或以上。</p>
<ul>
<li><p>例如，以 “hello” 为例，我们可以对字母组 “o” 扩张得到 “hellooo”，但是无法以同样的方法得到 “helloo” 因为字母组 “oo” 长度小于 3。此外，我们可以进行另一种扩张 “ll” -&gt; “lllll” 以获得 “helllllooo”。如果 S &#x3D; “helllllooo”，那么查询词 “hello” 是可扩张的，因为可以对它执行这两种扩张操作使得 query &#x3D; “hello” -&gt; “hellooo” -&gt; “helllllooo” &#x3D; S。</p>
</li>
<li><p>输入一组查询单词，输出其中可扩张的单词数量。</p>
</li>
</ul>
<p><strong>题意解析：</strong></p>
<p>就是说，首先给定一个字符串数组words，然后给定一个字符串s，然后逐一判断words中的字符串是否可以通过扩展变成s；返回可以变成s的字符串的个数。</p>
<ul>
<li>扩展规则：扩展之后这个字母的次数必须大于等于3</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：1 ms, 在所有 Java 提交中击败了97.85%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：39.4 MB, 在所有 Java 提交中击败了98.39%的用户 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expressiveWords</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isExpressiveWord(word,s)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先写一个函数用来判断是否为这类字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 扩展前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 扩展后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果t是s扩展后的字符串，返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isExpressiveWord</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;<span class="comment">//创建两个指针，分别用来遍历s和t</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != t.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnti</span> <span class="operator">=</span> <span class="number">0</span>, cntj = <span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; s.charAt(i) == ch) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++cnti;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &lt; t.length() &amp;&amp; t.charAt(j) == ch) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">                ++cntj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cntj &lt; cnti) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cnti != cntj &amp;&amp; cntj &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i==s.length() &amp;&amp; j==t.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question10-寻找盛水最多的容器"><a href="#Question10-寻找盛水最多的容器" class="headerlink" title="Question10:寻找盛水最多的容器"></a>Question10:寻找盛水最多的容器</h3><p><strong>题目描述：</strong></p>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<ul>
<li>返回容器可以储存的最大水量。</li>
<li>说明：你不能倾斜容器。</li>
</ul>
<p><img src="/2022/11/14/LeetCode/image-20221127103817412.png" alt="image-20221127103817412"></p>
<p><strong>题解：</strong></p>
<p><strong>方法一：</strong></p>
<p>思路是创建一个双指针</p>
<ul>
<li>一个指针指向最左边，一个指针指向最右边</li>
<li>哪边的高度比较低，就把哪边的向中心移动，以求获取最大的高度，从而获得最大的容积</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：4 ms, 在所有 Java 提交中击败了59.85%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：51.2 MB, 在所有 Java 提交中击败了89.00%的用户 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            res = Math.max(res,(right-left)*Math.min(height[left],height[right]));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question11-三数之和"><a href="#Question11-三数之和" class="headerlink" title="Question11:三数之和"></a>Question11:三数之和</h3><p><strong>题目描述：</strong></p>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>题解：</strong></p>
<ul>
<li>首先，本题第一反应还是使用循环来做暴力求解，这样的话所有的数字都要遍历三遍，复杂度为O(N3)，复杂度较高，影响性能。</li>
<li>想要降低复杂度到O(N2)，需要使用双指针；先将数组进行排序，然后一个指针指向头部，一个指针指向尾部，对中间的数字进行遍历，相关注释加到代码里</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：20 ms, 在所有 Java 提交中击败了76.56%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：45.8 MB, 在所有 Java 提交中击败了31.97%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    	<span class="comment">//创建最终的返回集合</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//先对数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>; first &lt; n; first++) &#123;</span><br><span class="line">        	<span class="comment">//保证下一个数字和上一个数字不一样</span></span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[first];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first+<span class="number">1</span>; second &lt; n; second++) &#123;</span><br><span class="line">            	<span class="comment">//保证数字和上一个不一样</span></span><br><span class="line">                <span class="keyword">if</span> (second &gt; first+<span class="number">1</span> &amp;&amp; nums[second] == nums[second-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果二者加和大于了目标值，就需要将最后一个数字向左移动</span></span><br><span class="line">                <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当两个指针重合，就不需要再继续了，直接break</span></span><br><span class="line">                <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//满足要求的添加到数组之中</span></span><br><span class="line">                <span class="keyword">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(nums[first]);</span><br><span class="line">                    list.add(nums[second]);</span><br><span class="line">                    list.add(nums[third]);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question12-电话号码中的字母组合"><a href="#Question12-电话号码中的字母组合" class="headerlink" title="Question12:电话号码中的字母组合"></a>Question12:电话号码中的字母组合</h3><p><strong>题目描述：</strong></p>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/2022/11/14/LeetCode/image-20221208104753044.png" alt="image-20221208104753044"></p>
<p><strong>题解：</strong></p>
<ul>
<li>分析一下，对于这道题，我们肯定是想要先看有几个数字，如果是两个数字，比如23，那么就利用双层循环就可以获取到所有的值。如果是三个数字234，那么就使用三层循环获取所有的排列组合。</li>
<li>但是在写的时候就会发现，根据数字的个数写几层循环代码上不可实现。</li>
<li>因此本题我们需要用<strong>回溯算法</strong></li>
</ul>
<p><strong>回溯算法</strong></p>
<ul>
<li>回溯算法其实说白了就是平时所说的试试看的想法，先试试，可以的话就返回，不可以的话就回来再试。第一次接触应该是在数据结构课上的八皇后问题。先将一个皇后放在这个位置，然后放下一个皇后，直到下一个皇后没法放的时候，进行回溯，来改变上一个皇后的位置；如果还是无解，就再向上回溯，直到第一个皇后。其思想类似于枚举法，就是将所有的情况都做枚举。</li>
<li>使用回溯法解决问题的过程，实际上是建立一棵“状态树”的过程。例如，在解决列举集合{1,2,3}所有子集的问题中，对于每个元素，都有两种状态，取还是舍，所以构建的状态树为：</li>
</ul>
<p><img src="/2022/11/14/LeetCode/image-20221208105938888.png" alt="image-20221208105938888"></p>
<ul>
<li>回溯算法的求解过程实质上是先序遍历“状态树”的过程。树中每一个叶子结点，都有可能是问题的答案。图 1 中的状态树是满二叉树，得到的叶子结点全部都是问题的解。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：39.9 MB, 在所有 Java 提交中击败了72.58%的用户 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;2&#x27;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;3&#x27;</span>,<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;4&#x27;</span>,<span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;5&#x27;</span>,<span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;6&#x27;</span>,<span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;7&#x27;</span>,<span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;8&#x27;</span>,<span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;9&#x27;</span>,<span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        <span class="comment">//回溯算法</span></span><br><span class="line">        backTrack(combinations,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(),<span class="number">0</span>,digits,map);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;String&gt; combinations, StringBuffer combination, <span class="type">int</span> index, String digits, Map&lt;Character, String&gt; map)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">str</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">            <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> map.get(str);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backTrack(combinations,combination,index+<span class="number">1</span>,digits,map);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question13-删除链表中倒数第N个节点"><a href="#Question13-删除链表中倒数第N个节点" class="headerlink" title="Question13:删除链表中倒数第N个节点"></a>Question13:删除链表中倒数第N个节点</h3><p><strong>题目描述：</strong></p>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>题解：</strong></p>
<p><strong>方法一：普通方法</strong></p>
<ul>
<li>先找到链表中节点的个数</li>
<li>然后进行遍历，到正数第sum-n的地方进行操作即可</li>
</ul>
<p><img src="/2022/11/14/LeetCode/image-20221209120309077.png" alt="image-20221209120309077"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：40.1 MB, 在所有 Java 提交中击败了5.11%的用户 */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//删除链表中的倒数第n个节点</span></span><br><span class="line">        <span class="comment">//先统计一共有几个节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果n大于个数，就return null</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; sum || sum==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果第一个节点是要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span>(sum == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == sum-n) &#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用栈</strong></p>
<ul>
<li>将所有的链表节点加入到栈中</li>
<li>将栈中的数据取出n-1个</li>
<li>返回栈顶元素，也就是要删除节点的前一个节点</li>
<li>进行删除操作即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;ListNode&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    	stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">    prev.next = prev.next.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：双指针</strong></p>
<p>我们也可以在不预处理出链表的长度，以及使用常数空间的前提下解决本题。</p>
<p>由于我们需要找到倒数第 n 个节点，因此我们可以使用两个指针<strong>first</strong> 和 <strong>second</strong> 同时对链表进行遍历，并且<strong>first</strong> 比 <strong>second</strong> 超前 n 个节点。当 <strong>first</strong> 遍历到链表的末尾时，<strong>second</strong> 就恰好处于倒数第 n 个节点。</p>
<p>具体地，初始时 <strong>first</strong> 和 <strong>second</strong> 均指向头节点。我们首先使用 <strong>first</strong> 对链表进行遍历，遍历的次数为 n。此时，<strong>first</strong> 和 <strong>second</strong> 之间间隔了 n-1 个节点，即 <strong>first</strong> 比 <strong>second</strong> 超前了 n 个节点。</p>
<p>在这之后，我们同时使用 <strong>first</strong> 和 <strong>second</strong> 对链表进行遍历。当 <strong>first</strong> 遍历到链表的末尾（即 <strong>first</strong> 为空指针）时，<strong>second</strong> 恰好指向倒数第 n 个节点。</p>
<p>根据方法一和方法二，如果我们能够得到的是倒数第 n 个节点的前驱节点而不是倒数第 n 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 <strong>second</strong> 指向哑节点，其余的操作步骤不变。这样一来，当 <strong>first</strong> 遍历到链表的末尾时，<strong>second</strong> 的下一个节点就是我们需要删除的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question14-括号的生成"><a href="#Question14-括号的生成" class="headerlink" title="Question14:括号的生成"></a>Question14:括号的生成</h3><p><strong>题目描述：</strong></p>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<ul>
<li>注意不可以产生交叉的括号</li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：暴力求解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//方法一：暴力法求解</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        整体思路就是，将所有的可能的情况列举出来，然后再进行判断是否可行</span></span><br><span class="line"><span class="comment">        执行用时：2 ms, 在所有 Java 提交中击败了25.13%的用户</span></span><br><span class="line"><span class="comment">        内存消耗：41.6 MB, 在所有 Java 提交中击败了34.94%的用户</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        generateAll(<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>*n],<span class="number">0</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成最后返回的序列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateAll</span><span class="params">(<span class="type">char</span>[] current, <span class="type">int</span> pos, List&lt;String&gt; result)</span>&#123;</span><br><span class="line">        <span class="comment">//在遍历到最后的位置的时候进行判断并添加到结果集</span></span><br><span class="line">        <span class="keyword">if</span>(pos == current.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(current))&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">String</span>(current));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//进行递归遍历</span></span><br><span class="line">            current[pos] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            generateAll(current,pos+<span class="number">1</span>,result);</span><br><span class="line">            current[pos] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            generateAll(current,pos+<span class="number">1</span>,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否有效的函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[] current)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : current) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                balance += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                balance -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(balance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：回溯法</strong></p>
<ul>
<li>相当于方法一的拓展，只有在序列还有效的时候进行加左括号或者右括号的操作</li>
<li>如果左括号数量不大于 <em>n</em>，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        backtrack(ans, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; ans, StringBuilder cur, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            backtrack(ans, cur, open + <span class="number">1</span>, close, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            backtrack(ans, cur, open, close + <span class="number">1</span>, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：递归法</strong></p>
<ul>
<li>剩余左括号总数要小于等于右括号，递归把所有符合要求的加上去就行了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：1 ms, 在所有 Java 提交中击败了76.13%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：41.3 MB, 在所有 Java 提交中击败了78.55%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; </span><br><span class="line">        generateAll(<span class="string">&quot;&quot;</span>,n,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 生成最后返回的序列</span></span><br><span class="line"><span class="comment">    left:左括号剩余的数量 right:右括号剩余的数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateAll</span><span class="params">(String str, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">            <span class="comment">//数量相等的时候，只能加入左括号</span></span><br><span class="line">            generateAll(str+<span class="string">&quot;(&quot;</span> , left-<span class="number">1</span>,right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//剩余左括号小于右括号的时候，下一个既可以是左括号也可以是右括号</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                generateAll(str+<span class="string">&quot;(&quot;</span>,left-<span class="number">1</span>,right);</span><br><span class="line">            &#125;</span><br><span class="line">            generateAll(str+<span class="string">&quot;)&quot;</span>,left,right-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question15-下一个排列"><a href="#Question15-下一个排列" class="headerlink" title="Question15:下一个排列"></a>Question15:下一个排列</h3><p><strong>题目描述：</strong></p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
<li>下一个排列就是指的按照排列所得的大小进行排序，然后取出本个组合的下一个序列。</li>
</ul>
<p><strong>题解：</strong></p>
<p>思路：</p>
<p>以<code>[4,5,2,6,3,1] </code>为例</p>
<ul>
<li>先找到要反转的位置，也就是找到前一位小于后一位这个位置也就是<code>nums[i]=2</code></li>
<li>设置另一个指针，从后面的数中找出略大于上面位置的数字<code>nums[j]=3</code></li>
<li>将<code>nums[i]</code>和<code>nums[j]</code>进行调换位置，之后再对<code>nums[i]</code>后面的位置进行反转即可(从最大反转到最小)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：41.9 MB, 在所有 Java 提交中击败了35.21%的用户 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question16-搜索旋转排序数组"><a href="#Question16-搜索旋转排序数组" class="headerlink" title="Question16:搜索旋转排序数组"></a>Question16:搜索旋转排序数组</h3><p><strong>题目描述：</strong></p>
<p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p><img src="/2022/11/14/LeetCode/image-20230227134427424.png" alt="image-20230227134427424"></p>
<p><strong>题解：</strong></p>
<p>本题主要是在非完全有序数组中利用二分法的思想。</p>
<p>分析：首先二分法是针对有序数组的一种查找条件，就是从数组中间一分为二进行查找。但是本体在将数组进行一分为二的时候，，分开的左右数组必有一个是有序数组，另一个是部分有序数组，因此采取以下思路</p>
<p><strong>算法设计：</strong></p>
<ol>
<li>利用二分法将数组一分为二，并且判断左右哪一段为有序数组，判断方法：如果nums[mid] &lt; nums[right]那么右边的数组有序；如果nums[mid] &gt; nums[left]那么左边的数组有序；</li>
<li>如果左边的数组有序，那么判断target是否位于左边数组中，位于则right&#x3D;mid-1，否则left&#x3D;mid+1</li>
<li>若未找到数字，返回-1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">    内存消耗：40.9 MB, 在所有 Java 提交中击败了69.04%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question17：有序数组中查找元素的第一和最后位置"><a href="#Question17：有序数组中查找元素的第一和最后位置" class="headerlink" title="Question17：有序数组中查找元素的第一和最后位置"></a>Question17：有序数组中查找元素的第一和最后位置</h3><p><strong>题目描述：</strong></p>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<ul>
<li><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
</li>
<li><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
</li>
</ul>
<p><strong>题解</strong>：</p>
<p><strong>解题思路：</strong></p>
<p>本题使用二分法，最好是将查找左边界与查找右边界分开，这样不容易出错。</p>
<p>以查找右边界为例：</p>
<ol>
<li>首先按照二分法获取当前区间的中间<code>(left+right) / 2</code>，判断下标对应的数字是否大于目标数字</li>
<li>如果大于目标数，则<code>right = middle - 1</code></li>
<li>否则<code>left = middle + 1</code>；<code>rightBorder = left</code></li>
<li>循环执行，最终得到右边界+1的位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBorder</span> <span class="operator">=</span> getLeftBorder(nums,target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBorder</span> <span class="operator">=</span> getRightBorder(nums,target);</span><br><span class="line">        <span class="keyword">if</span> (leftBorder == -<span class="number">2</span> || rightBorder == -<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightBorder - leftBorder &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBorder+<span class="number">1</span>,rightBorder-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用来获取数组的右边界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightBorder</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBorder</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用来获取数组的左边界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftBorder</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBorder</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="Chapter3-Hard"><a href="#Chapter3-Hard" class="headerlink" title="Chapter3:Hard"></a>Chapter3:Hard</h2><h3 id="Question1-子序列宽度之和"><a href="#Question1-子序列宽度之和" class="headerlink" title="Question1:子序列宽度之和"></a>Question1:子序列宽度之和</h3><p><strong>题目描述：</strong></p>
<p>一个序列的宽度 定义为该序列中最大元素和最小元素的差值。</p>
<ul>
<li><p>给你一个整数数组 nums ，返回 nums 的所有非空子序列的宽度之和。由于答案可能非常大，请返回对 1000000007 取余后的结果。</p>
</li>
<li><p>子序列定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。</p>
</li>
</ul>
<p><img src="/2022/11/14/LeetCode/image-20221118105516721.png" alt="image-20221118105516721"></p>
<p><strong>题解：</strong></p>
<p><strong>数学法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行用时：34 ms, 在所有 Java 提交中击败了94.74%的用户</span></span><br><span class="line"><span class="comment">内存消耗：48.7 MB, 在所有 Java 提交中击败了98.68%的用户 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubseqWidths</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> nums[<span class="number">0</span>], y=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            res = (res + nums[j]*(y-<span class="number">1</span>) - x) % MOD;</span><br><span class="line">            x = (<span class="number">2</span>*x+nums[j]) % MOD;</span><br><span class="line">            y = (<span class="number">2</span> * y) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Question2-第N个神奇数字"><a href="#Question2-第N个神奇数字" class="headerlink" title="Question2:第N个神奇数字"></a>Question2:第N个神奇数字</h3><p><strong>题目描述：</strong></p>
<p>一个正整数如果能被 a 或 b 整除，那么它是神奇的。</p>
<ul>
<li><p>给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。</p>
</li>
<li><p>我再来解读一下题目想要表达的意思：就是除a或者除b能除开的数字就是神奇的数，我们现在要寻找第N个能除开他们的数</p>
</li>
</ul>
<p><strong>题解：</strong></p>
<p>思路：其实本题很简单，就是取一个并集再减去交集即可；也就是说。除以a可以除开的数和除以b可以除开的数，必有重复，把重复的数字去除即可。</p>
<ul>
<li><p>首先寻找到a和b的最小公倍数</p>
</li>
<li><p>利用公式<br>$$<br>f(x)&#x3D;[x&#x2F;a]+[x&#x2F;b]+[x&#x2F;c]<br>$$</p>
</li>
<li><p>x即为第x个数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthMagicalNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">long</span> l=Math.min(a,b),r=(<span class="type">long</span>)n*Math.min(a,b);<span class="comment">//这样的话一定至少有n个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a * b / gcd(a,b);<span class="comment">//c即为最小公倍数</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> (r+l) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> mid / a + mid / b - mid / c;<span class="comment">//分析中的公式</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt;= n) &#123;<span class="comment">//包含等于n的情况，多减了1，因此返回时加上1</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ((r+<span class="number">1</span>) % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先写一个方法寻找两个数中的最小公约数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;b ? gcd(b,a) : ((a%b==<span class="number">0</span>)?b : gcd(b,a%b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>找规律的方法见力扣官方解答</strong></p>
<hr>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
