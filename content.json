{"posts":[{"title":"Lottery抽奖系统","text":"DAY01：环境搭建按照小册子搭建环境即可。 注意 如果使用的数据库是8版本以上，还需要再对配置文件的进行修改 将该模块下的yml配置文件中将driver-class-name 调整为com.mysql.cj.jdbc.Driver ，且因为MySQL8连接要求，必须在连接url后跟上serverTimezone 的配置，即url: jdbc:mysql://127.0.0.1:3306/lottery?useUnicode=true&amp;serverTimezone=Asia/Shanghai DDD架构：两篇文章： 美团篇：领域驱动设计在互联网业务开发中的实践 - 美团技术团队 (meituan.com) 腾讯篇：后台开发进阶：白话DDD从入门到实践 - 元宇宙 (yitb.com) RPC：之前的学习以及做的项目都是一个单体项目，也就是用户直接通过X来调用A应用，然后来实现自己的需求。但是这样的系统结构在面对一些高并发的场景时，会由于流量过多而发生异常。因此引入了扩容，即一个RPC对应一个应用的实例，当流量进入的时候，可以将流量分散开，从而保证系统正常运行。 一般RPC的结构实现： pom文件修改：如果将所有的依赖都添加在父工程的pom文件中，那么就会导致子工程在加载时会引入所有父工程的依赖，因此父工程只定义springboot和jdk版本的依赖。 关于pom文件中两种build的理解： (5条消息) POM.XML的build标签中resources标签_狂丰的博客-CSDN博客 今日总结： 今天按照小傅哥的册子跑通了广播模式RPC过程调用，过程可谓一波三折，总结以下几个问题： 首先在引入小傅哥的文件时，要修改相关的配置以及引用 在修改数据库版本的时候，要注意修改配置文件中的url和driver-class-name 注意每一个模块对其他模块的调用以及打包方式（只有interfaces层采用war包） 注意@Service是Dubbo中的注解而不是引用Spring中的 刚开始不知道为什么报错，后来又莫名其妙好了，这个我还没有想明白 注意在进行单元测试的时候，首先要向数据库添加数据，否则会报错 明日计划： 将第三节的代码自己编写一遍 学习一个简单的Dubbo项目 DAY02：今日工作： 重新编写DAY01的代码并提交到代码库中 整理代码框架 对整个框架以及DDD结构有了全新的理解 DDD架构的个人理解如果是一个单体项目采用DDD结构，那么RPC层不存在，剩余的层： interface层：接口层，负责接收前端发给的请求并且进行处理，然后调用应用层的方法来实现请求并且将结果返回给前端 application层：应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装 domain层：领域层，负责核心业务代码的编写 infrastructure层：为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响 如果是分布式项目： RPC层：作用是提供远程调用接口 PO、VO、DO、DTO的对比参考自小傅哥： PO：persistent object 持久对象 有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。（一般存放在infrastructure层中，如上图中的Activity） 在Mybatis持久化框架中与insert/delet操作密切相关。 PO中不应该包含任何对数据库的操作。 POJO ：plain ordinary java object 无规则简单java对象 VO：value object 值对象 / view object 表现层对象（一般放在domain层中） 主要对应页面显示（web页面/swt、swing界面）的数据对象。 可以和表对应，也可以不，这根据业务的需要。 可以细分包括 req、res（请求时的实体类、返回的实体类） DO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。通常可以代替部分 PO 的职责。 DTO（TO）：Data Transfer Object 数据传输对象 用在需要跨进程或远程传输时，它不应该包含业务逻辑。 比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。 DAY03：抽奖活动策略表设计 抽奖活动策略表设计 分库分表分表的意义： MySQL数据库采用B+树来进行数据的存储和查找，如果数据量太大的话，SQL查询效率就会变低。如果一个查询SQL没有命中，那么就回去在海量数据中进行查找，从而影响性能甚至崩溃。 就算是命中，但是如果数据过多，比如千万级别。那么B+树就会变高，从而影响查询。 B+树工作原理： InnoDB存储引擎最小单元是页，一页大小就是16KB，B+树叶子节点存储的是索引和数据(针对主键而言)内部节点存储的是键值和指针。 索引组织表通过非叶子节点的二分查找法以及指针确定数据具体在哪个页里，再从数据页中寻找需要的数据。 假设B+树高度是2，(根节点占一格高度，和若干叶子节点)。这颗B+树存放的总记录数 = 根节点指针数 * 单个叶子节点记录行数 如果一行记录数的数据是1k，那么叶子节点 (单个)能存储的数据量就是 16k / k = 16 非叶子节点内存放多少指针呢？我们假设主键ID为bigint类型，长度为8字节(面试官问你int类型，一个int就是32位，4字节)，而指针大小在InnoDB源码中设置为6字节，所以就是 8+6=14 字节，16k /14B = 16 * 1024B /14B =1170 因此，一棵高度为2的B+树，能存放1170（第一层的索引数量） * 16（第二层每一个索引指向的数量）=18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 =21902400，大概可以存放两千万左右的记录。B+树高度一般为1-3层，如果B+到了4层，查询的时候会多查磁盘的次数（即磁盘IO），SQL就会变慢。 如果说不进行分表，那么一行记录数的数据就会变大，单个叶子结点储存的信息数量就会减少，就会导致B+树高度变大 分库的意义：在本业务中，用户参与活动记录和次数，用户是否中奖，中奖信息需要分库 本身这些操作，属于是非常非常高频的一些操作，如果业务量剧增，数据库可能会出现性能瓶颈，这时候我们就需要考虑拆分数据库。从这几方面来看 磁盘存储业务量剧增，MySOL单机磁盘容量会撑爆，拆成多个数据库，磁盘使用率大大降低 并发连接支撑数据库的连接是有限的，在高并发场景下，大量请求访问数据库，MySQL单机无法承受，因此我们的项目采用微服务架构，通过将订单，用户，商品等不同模块都拆分成一个domain。并且将单个数据库也拆分成多个不同功能模块的数据库，或者是相同功能，放在多个库里分摊连接请求。 (同时可以采用缓存架构来降低访问) 分库分表的意义： 解决连接数瓶颈，解决数据增量，通常数据存量200万-300万，增量在单表50万就要考虑拆表了 (一开始可能很小，都设计成分库分表)因为拆分的库大多都是虚拟机上的，不会对服务器资源造成太大浪费，后续数量增多时，再迁徙物理机。 分库分表之后，数据分散，通过路由规则和负载均衡策略保证请求均衡打在不同库表上，不用担心会集中打在某个库表上造成数据库瘫痪。 本质上为:减少数据库压力，提高数据库效率，缩短查询时间 总结： 分库：解决qps过高，连接数不够用 分表：解决数据量过大，查询效率不高 分库分表：解决qps过高和查询效率不高 抽奖策略开发抽奖策略分类：场景：奖品A B C的中奖概率分别为：50%、30%、20% 总体概率：如果说A奖品被抽完了，那么B、C的中奖概率分别为60%和40% 单项概率：如果A奖品抽空后，B和C保持目前中奖概率，用户抽奖扔有20%中为A，因A库存抽空则结果展示为未中奖。为了运营成本，通常这种情况的使用的比较多 在库表设计上我们把抽奖需要的策略配置和策略明细，它们的关系是1vn。 DDD架构： model，用于提供vo、req、res 和 aggregates 聚合对象。 repository，提供仓储服务，其实也就是对Mysql、Redis等数据的统一包装。后面的话只在domain编写接口，实现类放到infrastructure层中。 service，是具体的业务领域逻辑实现层，在这个包下定义了algorithm抽奖算法实现和具体的抽奖策略包装 draw 层，对外提供抽奖接口。 算法设计：总体概率：分别把A、B、C对应的概率值转换成阶梯范围值，A=(0~0.2」、B=(0.2-0.5」、C=(0.5-1.0」，当使用随机数方法生成一个随机数后，与阶梯范围值进行循环比对找到对应的区域，匹配到中奖结果。 实现过程： 首先要从总的中奖列表中排除掉那些被排除掉的奖品，这些奖品会涉及到概率的值重新计算。 如果排除后剩下的奖品列表小于等于1，则可以直接返回对应信息 接下来就使用随机数工具生产一个100内的随值与奖品列表中的值进行循环比对，算法时间复杂度O(n) 单项概率：算法描述：单项概率算法不涉及奖品概率重新计算的问题，那么也就是说我们分配好的概率结果是可以固定下来的。好，这里就有一个可以优化的算法，不需要在轮训匹配O(n)时间复杂度来处理中奖信息，而是可以根据概率值存放到HashMap或者自定义散列数组进行存放结果，这样就可以根据概率值直接定义中奖结果，时间复杂度由O(n)降低到O(1)。这样的设计在一般电商大促并发较高的情况下，达到优化接口响应时间的目的。也就是说，现在只需要根据索引值来查找相对应的索引即可。 对于流程的分析，等代码开发完成之后进行总结。 今日总结： 完成抽奖活动策略表的设计与理解 学习分库分表的意义，以及数据库存储方式的B+树 学习第05节的视频和小册，并且理清楚相关的类 DAY04：今日任务： 代码撰写，将第05节代码进行编写 整理今天学到的知识，完成小傅哥的作业 梳理交互过程算法模块 梳理流程： （1）首先定义一个接口：IDrawAlgorithm，其中有三个方法 initRateTuple(Long strategyId, List&lt;AwardRateInfo&gt; awardRateInfoList) 1234567 定义了一个初始化的方法，也就是将每一个奖品都放置到100斐波那契散列之中，如下图这样 &lt;img src=&quot;Lottery/image-20230428151915087.png&quot; alt=&quot;image-20230428151915087&quot; style=&quot;zoom:33%;&quot; /&gt;- ``` isExistRateTuple 判断是否已经，做了数据初始化 ```randomDraw 12345678910111213 生成随机数，索引到对应的奖品信息返回结果，该方法在基础算法中不进行实现，在实际落地的算法中才加以实现（2）编写基础算法实现类BaseAlgorithm，并且重写initRateTuple和isExistRateTuple方法，还有hashIdx方法在这里先补一下关于斐波那契散列的相关知识- 哈希算法： ```java keyIndex = ((value + 1) * HASH_INCREMENT) &amp; (length - 1); //斐波那契（Fibonacci）散列法，计算哈希索引下标值；将100个奖品映射到128个空格中 //HASH_INCREMENT是常量0x61c88647；length表示数组初始化的长度，就是要定义多长的数组来放置100个奖品 算法实现： 首先定义相关的成员变量 1234567891011// 斐波那契散列增量，逻辑：黄金分割点：(√5 - 1) / 2 = 0.6180339887，Math.pow(2, 32) * 0.6180339887 = 0x61c88647private final int HASH_INCREMENT = 0x61c88647;// 数组初始化长度private final int RATE_TUPLE_LENGTH = 128;// 存放概率与奖品对应的散列结果，strategyId -&gt; rateTuple(数组长度为128，用来存放奖品的id)protected Map&lt;Long, String[]&gt; rateTupleMap = new ConcurrentHashMap&lt;&gt;();// 奖品区间概率值，strategyId -&gt; [awardId-&gt;begin、awardId-&gt;end](这个成员变量用于后面总体概率法的时候重新计算概率使用)protected Map&lt;Long, List&lt;AwardRateInfo&gt;&gt; awardRateInfoMap = new ConcurrentHashMap&lt;&gt;(); initRateTuple算法实现 1234567891011121314151617181920212223@Overridepublic void initRateTuple(Long strategyId, List&lt;AwardRateInfo&gt; awardRateInfoList) { // 保存奖品概率信息 awardRateInfoMap.put(strategyId, awardRateInfoList); // 创建奖品对应的斐波那契散列表 computeIfAbsent：如果没有就创建 String[] rateTuple = rateTupleMap.computeIfAbsent(strategyId, k -&gt; new String[RATE_TUPLE_LENGTH]); int cursorVal = 0; //按照概率，取出中奖概率对应的长度，即如果概率为0.2，那么rateVal为20 for (AwardRateInfo awardRateInfo : awardRateInfoList) { int rateVal = awardRateInfo.getAwardRate().multiply(new BigDecimal(100)).intValue(); // 循环填充概率范围值 // 计算hashindex来将对应位置填充为相应的AwardId for (int i = cursorVal + 1; i &lt;= (rateVal + cursorVal); i++) { rateTuple[hashIdx(i)] = awardRateInfo.getAwardId(); } cursorVal += rateVal; }} 重写isExistRateTuple 1234@Overridepublic boolean isExistRateTuple(Long strategyId) { return rateTupleMap.containsKey(strategyId);} 斐波那契散列法计算哈希索引下标值 12345678910/** * 斐波那契（Fibonacci）散列法，计算哈希索引下标值 * * @param val 值 * @return 索引 */protected int hashIdx(int val) { int hashCode = val * HASH_INCREMENT + HASH_INCREMENT; return hashCode &amp; (RATE_TUPLE_LENGTH - 1);} （3）编写单体概率实现方法（抽到库存为0的直接显示未中奖） 123456789101112131415161718192021@Component(&quot;singleRateRandomDrawAlgorithm&quot;)public class SingleRateRandomDrawAlgorithm extends BaseAlgorithm { @Override public String randomDraw(Long strategyId, List&lt;String&gt; excludeAwardIds) { // 获取策略对应的元祖 String[] rateTuple = super.rateTupleMap.get(strategyId); assert rateTuple != null; // 随机索引 int randomVal = new SecureRandom().nextInt(100) + 1; int idx = super.hashIdx(randomVal); // 返回结果 String awardId = rateTuple[idx]; // 库存为0则未中奖 if (excludeAwardIds.contains(awardId)) return &quot;未中奖&quot;; return awardId; }} SecureRandom方法与Random方法的区别是： SecureRandom 提供加密的强随机数生成器 (RNG)，要求种子必须是不可预知的，产生非确定性输出。 个人认为是产生相同的概率会减小 （4）编写总体概率实现方法（必中奖策略抽奖，排掉已经中奖的概率，重新计算中奖范围） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component(&quot;defaultRateRandomDrawAlgorithm&quot;)public class DefaultRateRandomDrawAlgorithm extends BaseAlgorithm { @Override public String randomDraw(Long strategyId, List&lt;String&gt; excludeAwardIds) { // 此时场上还存在的中奖概率（如果场上产品只有A：0.2和B：0.5，则这个值为0.7，用于重新计算概率作为被除数） BigDecimal differenceDenominator = BigDecimal.ZERO; // 排除掉不在抽奖范围的奖品ID集合 List&lt;AwardRateInfo&gt; differenceAwardRateList = new ArrayList&lt;&gt;(); List&lt;AwardRateInfo&gt; awardRateIntervalValList = awardRateInfoMap.get(strategyId); for (AwardRateInfo awardRateInfo : awardRateIntervalValList) { String awardId = awardRateInfo.getAwardId(); if (excludeAwardIds.contains(awardId)) { continue; } differenceAwardRateList.add(awardRateInfo); differenceDenominator = differenceDenominator.add(awardRateInfo.getAwardRate()); } // 前置判断 if (differenceAwardRateList.size() == 0) return &quot;&quot;; if (differenceAwardRateList.size() == 1) return differenceAwardRateList.get(0).getAwardId(); // 获取随机概率值 SecureRandom secureRandom = new SecureRandom(); int randomVal = secureRandom.nextInt(100) + 1; // 循环获取奖品 String awardId = &quot;&quot;; int cursorVal = 0; for (AwardRateInfo awardRateInfo : differenceAwardRateList) { // awardRateInfo.getAwardRate() / differenceDenominator int rateVal = awardRateInfo.getAwardRate().divide(differenceDenominator, 2, BigDecimal.ROUND_UP).multiply(new BigDecimal(100)).intValue(); if (randomVal &lt;= (cursorVal + rateVal)) { awardId = awardRateInfo.getAwardId(); break; } cursorVal += rateVal; } // 返回中奖结果 return awardId; }} 算法实现模块实现流程（抽奖实现接口） （1）DrawConfig（提供一个配置类，将两种策略进行封装） 12345678910111213141516public class DrawConfig { @Resource private IDrawAlgorithm defaultRateRandomDrawAlgorithm; @Resource private IDrawAlgorithm singleRateRandomDrawAlgorithm; protected static Map&lt;Integer, IDrawAlgorithm&gt; drawAlgorithmMap = new ConcurrentHashMap&lt;&gt;(); @PostConstruct public void init() { drawAlgorithmMap.put(1, defaultRateRandomDrawAlgorithm); drawAlgorithmMap.put(2, singleRateRandomDrawAlgorithm); }} 解析@PostConstruct ： @PostConstruct该注解被用来修饰一个非静态的 void() 方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。@PostConstruct在构造函数之后执行，init() 方法之前执行。 该注解的方法在整个Bean初始化中的执行顺序： Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法) 使用该注解可以保证在init()之前将@Resource注解的对象已经注入 （2）DrawBase 123456789101112131415161718192021public class DrawBase extends DrawConfig { public void checkAndInitRateData(Long strategyId, Integer strategyMode, List&lt;StrategyDetail&gt; strategyDetailList) { // 表示策略1需要进行初始化；策略2不需要下面的初始化过程 if (1 != strategyMode) return; IDrawAlgorithm drawAlgorithm = drawAlgorithmMap.get(strategyMode); // 初始化 boolean existRateTuple = drawAlgorithm.isExistRateTuple(strategyId); if (existRateTuple) return; List&lt;AwardRateInfo&gt; awardRateInfoList = new ArrayList&lt;&gt;(strategyDetailList.size()); for (StrategyDetail strategyDetail : strategyDetailList) { awardRateInfoList.add(new AwardRateInfo(strategyDetail.getAwardId(), strategyDetail.getAwardRate())); } drawAlgorithm.initRateTuple(strategyId, awardRateInfoList); }} （3）IDrawExec 12345public interface IDrawExec { DrawResult doDrawExec(DrawReq req);} 提供一个方法接口 （4）DrawExecImpl 12345678910111213141516171819202122232425262728293031323334@Service(&quot;drawExec&quot;)public class DrawExecImpl extends DrawBase implements IDrawExec { private Logger logger = LoggerFactory.getLogger(DrawExecImpl.class); @Resource private IStrategyRepository strategyRepository; @Override public DrawResult doDrawExec(DrawReq req) { logger.info(&quot;执行策略抽奖开始，strategyId：{}&quot;, req.getStrategyId()); // 获取抽奖策略配置数据 StrategyRich strategyRich = strategyRepository.queryStrategyRich(req.getStrategyId()); Strategy strategy = strategyRich.getStrategy(); List&lt;StrategyDetail&gt; strategyDetailList = strategyRich.getStrategyDetailList(); // 校验和初始化数据 checkAndInitRateData(req.getStrategyId(), strategy.getStrategyMode(), strategyDetailList); // 根据策略方式抽奖 IDrawAlgorithm drawAlgorithm = drawAlgorithmMap.get(strategy.getStrategyMode()); String awardId = drawAlgorithm.randomDraw(req.getStrategyId(), new ArrayList&lt;&gt;()); // 获取奖品信息 Award award = strategyRepository.queryAwardInfo(awardId); logger.info(&quot;执行策略抽奖完成，中奖用户：{} 奖品ID：{} 奖品名称：{}&quot;, req.getuId(), awardId, award.getAwardName()); // 封装结果 return new DrawResult(req.getuId(), req.getStrategyId(), awardId, award.getAwardName()); }} 抽奖策略的实现 测试略 注意： 除了上面核心业务的开发以外，还有一些实体类和一些mapper方法需要编写 编写相关代码第一遍先仿照小傅哥的代码进行编写 DAY05:今日计划： 完成代码编写与测试 处理BUG：在按照上面的算法流程编写相应的代码，在测试的时候遇到了以下问题 首先在小傅哥的代码中，创建数据库和xml中查询都是直接命名为驼峰的，但是在我的代码中，并没有使用这种方式。而是使用的下划线方式来命名数据库列表的，因此造成了第一个问题就是找不到相关的列 当我把查询改为下划线格式的时候，发现始终只能查询到id，其他属性全都没有，这是由于mybatis没有配置驼峰映射，采取的第一种方式是在applicat.yml配置文件中加上 123mybatis: configuration: map-underscore-to-camel-case: true 结果报错 1Property 'configuration' and 'configLocation' can not specified with together 也就是上面的配置不能和下面的配置一起声明 123mybatis: mapper-locations: classpath:/mybatis/mapper/*.xml config-location: classpath:/mybatis/config/mybatis-config.xml 因此采取resultMap方式来进行配置，在每一个xml查询中都插入 123456789&lt;resultMap id=&quot;strategyDetailMap&quot; type=&quot;cn.spy.lottery.infrastructure.po.StrategyDetail&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;strategy_id&quot; property=&quot;strategyId&quot;/&gt; &lt;result column=&quot;award_id&quot; property=&quot;awardId&quot;/&gt; &lt;result column=&quot;award_count&quot; property=&quot;awardCount&quot;/&gt; &lt;result column=&quot;award_rate&quot; property=&quot;awardRate&quot;/&gt; &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot;/&gt; &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot;/&gt;&lt;/resultMap&gt; 然后将下面的查询中的resultType改为resultMap的id即可 12345&lt;select id=&quot;queryStrategyDetailList&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;strategyDetailMap&quot;&gt; SELECT id, strategy_id, award_id, award_count, award_rate, create_time, update_time FROM strategy_detail WHERE strategy_id = #{strategyId}&lt;/select&gt; 注意： 这个问题改了很久，在这期间学会使用debug来不断进行排错，然后也要将自己的疑惑来及时百度来改正 DAY06: 将之前的算法以及调用流程使用模板模式处理 实现流程将配置类中的常量封装到常量枚举类之中 12345@PostConstructpublic void init(){ drawAlgorithmMap.put(Constants.StrategyMode.ENTIRETY.getCode(), defaultRateRandomDrawAlgorithm); drawAlgorithmMap.put(Constants.StrategyMode.SINGLE.getCode(), singleRateRandomDrawAlgorithm);} 优点： 使用这种方式不仅可以让后面的人更好的读懂代码，也可以方便以后加相关的策略 整体框架 核心部分：12345678910111213141516171819@Overridepublic DrawResult doDrawExec(DrawReq req) { // 1.获取抽奖策略 StrategyRich strategyRich = strategyRepository.queryStrategyRich(req.getStrategyId()); Strategy strategy = strategyRich.getStrategy(); // 2.校验和初始化数据 checkAndInitRateData(req.getStrategyId(), strategy.getStrategyMode(), strategyRich.getStrategyDetailList()); // 3.获取不在抽奖范围内的列表，包括：奖品库存为空、风控风险、临时调整等 List&lt;String&gt; excludeAwardIds = this.queryExcludeAwardIds(strategy.getStrategyId()); // 4.根据策略方式抽奖 String awardId = this.drawAlgorithm(req.getStrategyId(), drawAlgorithmMap.get(strategy.getStrategyMode()), excludeAwardIds); // 5. 包装中奖结果 return buildDrawResult(req.getuId(), req.getStrategyId(), awardId);} 模板模式就是要让过程尽可能的简洁明了，每一步都有固定的作用，关于每一步的实现逻辑方法封装到其他方法中进行实现。 对于不一样的部分在实现类中进行实现，相同的部分，比如结果封装则在抽象类中就加以实现 代码调试在写完代码使用单元测试进行代码调试的时候，为了测试库存不足时的返回情况，将库存都设置为0，遇到了这个问题 即Truncated incorrect DOUBLE value：类型不匹配问题 问题根源是，在单项概率实现策略里面 返回值为一个字符串，返回值类型有错误，应该返回null 此时测试通过 其它补充：dependencies和dependencymanagement的区别： Dependencies相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。 dependencyManagement里只是声明依赖，并不自动实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。 DAY07：今日计划： 按照 Mysql 库表使用规范调整表字段名称，如 activityId 调整为 activity_id，注意修改字符集类型 继续按照 P3C 标准，在 IDEA 插件 Alibaba Java Coding Guidelines 提醒下，修改所有涉及到的领域层、基础层中类、方法、字段的注释信息。 运用简单工厂设计模式，搭建发奖领域服务。介绍：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 工厂模式：如果在代码中，使用if-else来控制使用哪种策略，这是一种方法，但是如果策略很多，在后期修改维护的时候会带来很大的不方便，很有可能会牵一发而动全身。因此尽可能使用设计模式来代替if-else，让每一个类都有自己的职责来进行业务处理。 整体流程 进行测试在测试中最初存在NPE的Bug，排查原因是发现，GoodsConfig这个配置类上面没有加入注解：@Configuration，也就表示在使用实现类的时候还未将GoodsConfig注入到容器中。两种解决方式： 在配置类上面加入注解@Configuration 在实现类集成GoodsConfig Day08：之前由于小论文进度较慢，今天开始赶进度 今日计划： 完成Lottery8节——活动领域的配置与状态模式 具体流程：1. 调整依赖 之前我们使用domain层调用infrastructure层，将仓储服务接口和实现都放在了领域层。现在我们要将infrastructure引入domain从而将仓储服务的实现放在infrastructure层，只在domain保留接口，从而符合规范。 记得要将原来的依赖注释掉 此时许多domain层的依赖丢失，解决办法是在domain中的model模块引入每一个service需要的实体类 在domain层引入spring-tx依赖，开启事务管理 2. 梳理流程2.1.1 活动部署模块只有一个简单的接口与实现 其中接口实现方法： 12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class ActivityDeploy implements IActivityDeploy { private Logger logger = LoggerFactory.getLogger(ActivityDeploy.class); @Resource private IActivityRepository activityRepository; @Transactional(rollbackFor = Exception.class) @Override public void createActivity(ActivityConfigReq req) { logger.info(&quot;创建活动配置开始，activityId：{}&quot;, req.getActivityId()); ActivityConfigRich activityConfigRich = req.getActivityConfigRich(); try { // 添加活动配置 ActivityVO activity = activityConfigRich.getActivity(); activityRepository.addActivity(activity); // 添加奖品配置 List&lt;AwardVO&gt; awardList = activityConfigRich.getAwardList(); activityRepository.addAward(awardList); // 添加策略配置 StrategyVO strategy = activityConfigRich.getStrategy(); activityRepository.addStrategy(strategy); // 添加策略明细配置 List&lt;StrategyDetailVO&gt; strategyDetailList = activityConfigRich.getStrategy().getStrategyDetailList(); activityRepository.addStrategyDetailList(strategyDetailList); logger.info(&quot;创建活动配置完成，activityId：{}&quot;, req.getActivityId()); } catch (Exception e) { logger.error(&quot;创建活动配置失败，唯一索引冲突 activityId：{} reqJson：{}&quot;, req.getActivityId(), JSON.toJSONString(req), e); throw e; } } @Override public void updateActivity(ActivityConfigReq req) { // TODO 后期开发相关功能 }} 需要在dao和mapper中编写相应的添加语句 添加活动配置、添加奖品配置、添加策略配置、添加策略明细配置在一个事务中，所以加一个@Transactional注解 2.2.2 状态变更模块 对于这七种状态模式以及对应的方法，根据以下规则： 也可以看这张星友总结的： 使用设计模式中的状态模式，优化掉原本需要在各个流程节点中的转换使用 ifelse 的场景，这样操作以后也可以更加方便进行扩展。当然其实这里还可以使用如工作流的方式进行处理 3. 单元测试遇到的BUG： 首先是有两个@Service注解忘记加报的错误，NoSuchBeanFactory 第二个是，StrategyDetail中的awardName忘记写getter和setter方法，导致数据库一直没有相应的数据生成 4. 其它问题4.1 为什么仓储接口定义在领域层？为了领域层多聚合，如果仓储接口交给基础层实现，那么这个接口从使用上就不具备独立领域指责，其他模块都可以使用，最终就变得非常混乱了。将各自需要的接口定义在领域层，然后在基础层实现，可以避免混乱。 ID生成开发前须知 使用策略模式把三种生成ID的算法进行统一包装，由调用方决定使用哪种生成ID的策略。策略模式属于行为模式的一种，一个类的行为或算法可以在运行时进行更改 雪花算法本章节使用的是工具包 hutool 包装好的工具类，一般在实际使用雪花算法时需要做一些优化处理，比如支持时间回拨、支持手工插入、简短生成长度、提升生成速度等 而日期拼接和随机数工具包生成方式，都需要自己保证唯一性，一般使用此方式生成的ID，都用在单表中，本身可以在数据库配置唯一ID。那为什么不用自增ID，因为自增ID通常容易被外界知晓你的运营数据，以及后续需要做数据迁移到分库分表中都会有些麻烦 三种策略： 随机生成数 1234567@Componentpublic class RandomNumeric implements IIdGenerator { @Override public long nextId() { return Long.parseLong(RandomStringUtils.randomNumeric(11)); }} 雪花算法 1234567891011121314151617181920212223242526272829@Componentpublic class SnowFlake implements IIdGenerator { private Snowflake snowflake; @PostConstruct public void init() { // 0 ~ 31 位，可以采用配置的方式使用 long workerId; try { // 获取机器号 workerId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()); } catch (Exception e) { workerId = NetUtil.getLocalhostStr().hashCode(); } // 将机器号限制在31以内，也就是五位以内 workerId = workerId &gt;&gt; 16 &amp; 31; long dataCenterId = 1L; snowflake = IdUtil.createSnowflake(workerId, dataCenterId); } @Override public synchronized long nextId() { // 调用Snowflake中生成id的方法 return snowflake.nextId(); }} Java 根据雪花算法生成ID的方式 上图中的工作机器id，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。也就是可以部署1024个机器，一般没有这么高的需求。 对一些ID生成策略见processon 日期拼接随机数 123456789101112131415161718192021222324252627@Componentpublic class ShortCode implements IIdGenerator { /** * synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区， * 同时它还可以保证共享变量的内存可见性，Java中每一个对象都可以作为锁，这是synchronized实现同步的基础。 * @return */ @Override public synchronized long nextId() { Calendar calendar = Calendar.getInstance(); int year = calendar.get(Calendar.YEAR); int week = calendar.get(Calendar.WEEK_OF_YEAR); int day = calendar.get(Calendar.DAY_OF_WEEK); int hour = calendar.get(Calendar.HOUR_OF_DAY); // 打乱排序：2020年为准 + 小时 + 周期 + 日 + 三位随机数 StringBuilder idStr = new StringBuilder(); idStr.append(year - 2023); idStr.append(hour); idStr.append(String.format(&quot;%02d&quot;, week)); idStr.append(day); idStr.append(String.format(&quot;%03d&quot;, new Random().nextInt(1000))); return Long.parseLong(idStr.toString()); }} Day09:分布式路由组件spring.factories的作用 当启动类和配置类不在同一个包的时候，没有办法进行自动扫描，因此，在resources目录下新建一个META-INF的目录，然后新建一个spring.factories的文件，里面内容为： 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.bugstack.middleware.db.router.config.DataSourceAutoConfig 即可扫描相应的包 流程分析首先先来看整体的包结构 为什么要用分库分表： 由于业务体量较大，数据增长较快，所以需要把用户数据拆分到不同的库表中去，减轻数据库压力。 分库分表操作分类： 垂直拆分：指按照业务将表进行分类，分布到不同的数据库上，这样也就将数据的压力分担到不同的库上面。最终一个数据库由很多表的构成，每个表对应着不同的业务，也就是专库专用。 水平拆分：如果垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而本章节需要实现的水平拆分，是把同一个表拆到不同的数据库中。如：user_001、user_002 涉及技术： AOP 切面拦截的使用，这是因为需要给使用数据库路由的方法做上标记，便于处理分库分表逻辑。 数据源的切换操作，既然有分库那么就会涉及在多个数据源间进行链接切换，以便把数据分配给不同的数据库。 数据库表寻址操作，一条数据分配到哪个数据库，哪张表，都需要进行索引计算。在方法调用的过程中最终通过 ThreadLocal 记录。 为了能让数据均匀的分配到不同的库表中去，还需要考虑如何进行数据散列的操作，不能分库分表后，让数据都集中在某个库的某个表，这样就失去了分库分表的意义。 设计实现1. DBRouter12345678@Documented@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE, ElementType.METHOD})public @interface DBRouter { String key() default &quot;&quot;;} 其中： @Documented表示该注解将被包含在Javadoc中生成的文档中。 @Retention(RetentionPolicy.RUNTIME)指定该注解将在运行时可用，这意味着可以在程序运行时访问该注解信息。 @Target({ElementType.TYPE, ElementType.METHOD})指定了该注解的目标元素，可以应用于类和方法上。 public @interface DBRouter声明这是一个注解，注解名为DBRouter。 String key() default &quot;&quot;定义了一个名为key的属性，类型为字符串，并设置了一个默认值为空字符串，也就是后续调用这个组件的时候会传入一个属性参数 2. 解析路由配置 2.1 在配置类 1234@Configurationpublic class DataSourceAutoConfig implements EnvironmentAware { //} 2.1.1 数据源配置提取： 12345678910111213@Overridepublic void setEnvironment(Environment environment) { String prefix = &quot;router.jdbc.datasource.&quot;; dbCount = Integer.valueOf(environment.getProperty(prefix + &quot;dbCount&quot;)); tbCount = Integer.valueOf(environment.getProperty(prefix + &quot;tbCount&quot;)); String dataSources = environment.getProperty(prefix + &quot;list&quot;); for (String dbInfo : dataSources.split(&quot;,&quot;)) { Map&lt;String, Object&gt; dataSourceProps = PropertyUtil.handle(environment, prefix + dbInfo, Map.class); dataSourceMap.put(dbInfo, dataSourceProps); }} prefix，是数据源配置的开头信息，你可以自定义需要的开头内容。 dbCount、tbCount、dataSources、dataSourceProps，都是对配置信息的提取，并存放到 dataSourceMap 中便于后续使用。 其中PropertyUtil.handle()方法类为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class PropertyUtil { private static int springBootVersion = 1; static { try { Class.forName(&quot;org.springframework.boot.bind.RelaxedPropertyResolver&quot;); } catch (ClassNotFoundException e) { springBootVersion = 2; } } /** * Spring Boot 1.x is compatible with Spring Boot 2.x by Using Java Reflect. * @param environment : the environment context * @param prefix : the prefix part of property key * @param targetClass : the target class type of result * @param &lt;T&gt; : refer to @param targetClass * @return T */ @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T handle(final Environment environment, final String prefix, final Class&lt;T&gt; targetClass) { switch (springBootVersion) { case 1: return (T) v1(environment, prefix); default: return (T) v2(environment, prefix, targetClass); } } private static Object v1(final Environment environment, final String prefix) { try { Class&lt;?&gt; resolverClass = Class.forName(&quot;org.springframework.boot.bind.RelaxedPropertyResolver&quot;); Constructor&lt;?&gt; resolverConstructor = resolverClass.getDeclaredConstructor(PropertyResolver.class); Method getSubPropertiesMethod = resolverClass.getDeclaredMethod(&quot;getSubProperties&quot;, String.class); Object resolverObject = resolverConstructor.newInstance(environment); String prefixParam = prefix.endsWith(&quot;.&quot;) ? prefix : prefix + &quot;.&quot;; return getSubPropertiesMethod.invoke(resolverObject, prefixParam); } catch (final ClassNotFoundException | NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) { throw new RuntimeException(ex.getMessage(), ex); } } private static Object v2(final Environment environment, final String prefix, final Class&lt;?&gt; targetClass) { try { Class&lt;?&gt; binderClass = Class.forName(&quot;org.springframework.boot.context.properties.bind.Binder&quot;); Method getMethod = binderClass.getDeclaredMethod(&quot;get&quot;, Environment.class); Method bindMethod = binderClass.getDeclaredMethod(&quot;bind&quot;, String.class, Class.class); Object binderObject = getMethod.invoke(null, environment); String prefixParam = prefix.endsWith(&quot;.&quot;) ? prefix.substring(0, prefix.length() - 1) : prefix; Object bindResultObject = bindMethod.invoke(binderObject, prefixParam, targetClass); Method resultGetMethod = bindResultObject.getClass().getDeclaredMethod(&quot;get&quot;); return resultGetMethod.invoke(bindResultObject); } catch (final ClassNotFoundException | NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) { throw new RuntimeException(ex.getMessage(), ex); } }} 这个类的主要作用是在Spring Boot 1.x 和 2.x之间提供属性配置文件读取的统一接口，使得代码可以兼容这两个版本。在不同的Spring Boot版本中，读取属性配置文件的方式有所不同，而这个类通过使用Java的反射机制，根据不同的版本使用不同的方法读取属性配置文件，从而保证代码的兼容性。 2.2.2 创建数据源 12345678910111213@Beanpublic DataSource dataSource() { // 创建数据源 Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(); for (String dbInfo : dataSourceMap.keySet()) { Map&lt;String, Object&gt; objMap = dataSourceMap.get(dbInfo); targetDataSources.put(dbInfo, new DriverManagerDataSource(objMap.get(&quot;url&quot;).toString(), objMap.get(&quot;username&quot;).toString(), objMap.get(&quot;password&quot;).toString())); } // 设置数据源 DynamicDataSource dynamicDataSource = new DynamicDataSource(); dynamicDataSource.setTargetDataSources(targetDataSources); return dynamicDataSource;} 这里是一个简化的创建案例，把基于从配置信息中读取到的数据源信息，进行实例化创建。 数据源创建完成后存放到 DynamicDataSource 中，它是一个继承了 AbstractRoutingDataSource 的实现类，这个类里可以存放和读取相应的具体调用的数据源信息 总结来说，DataSourceAutoConfig类的作用是获取到配置文件中的配置，并且创建了新的数据源，并且在另一个类中实现了1.x版本和2.x版本的兼容使用 3.切面拦截12345@Aspect@Component(&quot;db-router-point&quot;)public class DBRouterJoinPoint { //} 在 AOP 的切面拦截中需要完成；数据库路由计算、扰动函数加强散列、计算库表索引、设置到 ThreadLocal 传递数据源，整体案例代码如下： 1234567891011121314151617181920212223242526272829@Around(&quot;aopPoint() &amp;&amp; @annotation(dbRouter)&quot;)public Object doRouter(ProceedingJoinPoint jp, DBRouter dbRouter) throws Throwable { String dbKey = dbRouter.key(); if (StringUtils.isBlank(dbKey)) throw new RuntimeException(&quot;annotation DBRouter key is null！&quot;); // 计算路由 String dbKeyAttr = getAttrValue(dbKey, jp.getArgs()); int size = dbRouterConfig.getDbCount() * dbRouterConfig.getTbCount(); // 扰动函数 int idx = (size - 1) &amp; (dbKeyAttr.hashCode() ^ (dbKeyAttr.hashCode() &gt;&gt;&gt; 16)); // 库表索引 int dbIdx = idx / dbRouterConfig.getTbCount() + 1; int tbIdx = idx - dbRouterConfig.getTbCount() * (dbIdx - 1); // 设置到 ThreadLocal DBContextHolder.setDBKey(String.format(&quot;%02d&quot;, dbIdx)); DBContextHolder.setTBKey(String.format(&quot;%02d&quot;, tbIdx)); logger.info(&quot;数据库路由 method：{} dbIdx：{} tbIdx：{}&quot;, getMethod(jp).getName(), dbIdx, tbIdx); // 返回结果 try { return jp.proceed(); } finally { DBContextHolder.clearDBKey(); DBContextHolder.clearTBKey(); }} @Aspect 表示这是一个切面类 @Component(“db-router-point”) 表示这是一个Spring组件，名称为”db-router-point” @Pointcut(“@annotation(cn.bugstack.middleware.db.router.annotation.DBRouter)”) 表示定义一个切入点，通过@annotation指定对标注有@DBRouter注解的方法进行切入。 @Around(“aopPoint() &amp;&amp; @annotation(dbRouter)”) 表示定义环绕通知，在目标方法执行之前和之后都会执行，并且可以阻止目标方法的执行。这里通过@annotation(dbRouter)指定了切入点所在方法的DBRouter注解。 在doRouter方法中，首先获取DBRouter注解中的key值，并通过getAttrValue方法获取该值对应的参数值。接着，通过扰动函数计算出该key值对应的数据库和表的索引，将其设置到ThreadLocal中。最后，执行目标方法，无论是否抛出异常，都会执行finally中的代码，将ThreadLocal中的值清除。 需要注意的是，DBRouterJoinPoint类使用了@Autowired注解注入了一个DBRouterConfig类，这个类在前面我们已经讲过，是用来存储从配置文件中读取的数据库配置信息以及数据库和表的数量。 Day10:声明式事务领取活动领域开发目前的问题： 如果一个场景需要在同一个事务下，连续操作不同的DAO操作，那么就会涉及到在 DAO 上使用注解 @DBRouter(key = “uId”) 反复切换路由的操作。虽然都是一个数据源，但这样切换后，事务就没法处理了。 解决 这里选择了一个较低的成本的解决方案，就是把数据源的切换放在事务处理前，而事务操作也通过编程式编码进行处理。具体可以参考 db-router-spring-boot-starter 源码 梳理流程本次开发主要使用模板模式进行开发，其中抽象类BaseActivityPartake作为一个模板抽象类，在ActivityPartakeImpl进行开发实现，ActivityPartakeSupport是数据库支撑类的开发 个人认为还存在的问题： 如果在领取活动信息的时候出现错误，那么不会进行回滚，库存白白减1 但是按照小傅哥说法，宁愿减去也不能发生超支的错误，之后会进行改进 其他问题 编程式事务处理 编程式事务处理是指在编程时，通过代码实现事务的提交、回滚等操作。 在进行编程式的事务管理时，只需要将需要事务处理的方法，通过参数 TransactionCallback 传递给TransactionTemplate.execute () 方法，就可以实现事务的处理。 相对于声明式事务，编程式事务使用 TransactionTemplate 或者直接使用底层的PlatformTransactionManager 实现事务。对于编程式事务 Spring 比较推荐使用TransactionTemplate 来对事务进行管理 12345678910111213141516171819202122232425262728@Override protected Result grabActivity(PartakeReq partake, ActivityBillVO bill) { try { dbRouter.doRouter(partake.getuId()); // 切换数据源在事务处理之前 return transactionTemplate.execute(status -&gt; { try { // 扣减个人已参与次数 int updateCount = userTakeActivityRepository.subtractionLeftCount(bill.getActivityId(), bill.getActivityName(), bill.getTakeCount(), bill.getUserTakeLeftCount(), partake.getuId(), partake.getPartakeDate()); if (0 == updateCount) { status.setRollbackOnly(); logger.error(&quot;领取活动，扣减个人已参与次数失败 activityId：{} uId：{}&quot;, partake.getActivityId(), partake.getuId()); return Result.buildResult(Constants.ResponseCode.NO_UPDATE); } // 插入领取活动信息 Long takeId = idGeneratorMap.get(Constants.Ids.SnowFlake).nextId(); userTakeActivityRepository.takeActivity(bill.getActivityId(), bill.getActivityName(), bill.getTakeCount(), bill.getUserTakeLeftCount(), partake.getuId(), partake.getPartakeDate(), takeId); } catch (DuplicateKeyException e) { status.setRollbackOnly(); logger.error(&quot;领取活动，唯一索引冲突 activityId：{} uId：{}&quot;, partake.getActivityId(), partake.getuId(), e); return Result.buildResult(Constants.ResponseCode.INDEX_DUP); } return Result.buildSuccessResult(); }); } finally { dbRouter.clear(); } } 编程式事务与声明式事务处理的区别 编程式： 1234567891011Connection conn = dataSource.getConnection();try { conn.setAutoCommit(false); // 执行一些数据库操作 conn.commit();} catch (SQLException ex) { conn.rollback();} finally { conn.setAutoCommit(true); conn.close();} 声明式 12345@Service@Transactionalpublic void createUser(User user) { // 实现业务} 在编程式事务中，我们需要手动开启、提交、回滚事务;而在声明式事务中，我们只需要在方法上添加@Transactiona注解即可。这样就可以将操作与事务规则进行解耦，使得代码更加简洁易懂。 声明式事务和编程式事务各有优缺点。 声明式事务的 优点是:代码简洁，易于维护，不侵入业务逻辑，使得代码更加清晰，可以通过注解或配置文件来实现，使用方便。 缺点是:不够灵活，无法满足一些特殊需求，不利于调试，出现问题难以定位。 编程式事务的 优点是: 灵活性高，可以满足各种特殊需求，便于调试，出现问题容易定位。 缺点是:代码复杂，维护困难，侵入业务逻辑，使得代码不够清晰。 因此，在选择使用哪种事务管理方式时，需要根据具体情况进行选择这样看下来，其实在一些小项目里面，可能使用声明式事务会是更好的选择。在这个例子中不能使用声明式事务是因为: 如果一个场景需要在同一个事务下，连续操作不同的DAO操作，那么就会涉及到在 DAO 上使用注解 @DBRouter(key =”uld”)反复切换路由的操作。虽然都是一个数据源，但这样切换后，事务就没法处理了。 看一个例子: 我要插入两个uid，分别为uid=1和uid=2，在一般情况下，用声明式事务可以解决问题: insert两次然后commit即可: 但在这种分库分表的情况下，我现在插入一个uld=1，这条记录放在db01，uid=2的记录放在db02，在这个过程中会发生数据源的切换，切换了数据源，但是还没有提交commit，那么数据就会丢失。 总结：在分库分表的情况下，建议使用编程式事务。因为声明式事务是通过注解或配置文件来实现的，无法动态地确定开启哪个数据库实例的事务。而在分库分表时，需要动态地确定开启哪个数据库实例的事务，因此需要使用编程式事务。此外，编程式事务可以更好地控制事务的边界，保证数据的一致性。 在应用层编排抽奖过程开发过程 分别在两个分库的表 lottery_01.user_take_activity、lottery_02.user_take_activity 中添加 state【活动单使用状态 0未使用、1已使用】 状态字段，这个状态字段用于写入中奖信息到 user_strategy_export_000~003 表中时候，两个表可以做一个幂等性的事务。同时还需要加入 strategy_id 策略ID字段，用于处理领取了活动单但执行抽奖失败时，可以继续获取到此抽奖单继续执行抽奖，而不需要重新领取活动。其实领取活动就像是一种活动镜像信息，可以在控制幂等反复使用 所谓的幂等性，是分布式环境下的一个常见问题，一般是指我们在进行多次操作时，所得到的结果是一样的，即多次运算结果是一致的。 也就是说，用户对于同一操作，无论是发起一次请求还是多次请求，最终的执行结果是一致的，不会因为多次点击而产生副作用。 在 lottery-application 模块下新增 process 包用于流程编排，其实它也是 service 服务包是对领域功能的封装，很薄的一层。那么定义成 process 是想大家对流程编排有个概念，一般这一层的处理可以使用可视化的流程编排工具通过拖拽的方式，处理这部分代码的逻辑。 学习本章记得更新分支下的最新SQL语句，另外本章节还连带引入了需要MQ、Worker的场景，后续开发到这些功能的时候，会继续完善 完整流程 抽奖整个活动过程的流程编排，主要包括：对活动的领取、对抽奖的操作、对中奖结果的存放，以及如何处理发奖，对于发奖流程我们设计为MQ触发，后续再补全这部分内容。 对于每一个流程节点编排的内容，都是在领域层开发完成的，而应用层只是做最为简单的且很薄的一层。其实这块也很符合目前很多低代码的使用场景，通过界面可视化控制流程编排，生成代码 算法流程 本章出现BUG的几个位置 字段在实体类和数据库表中添加之后在查询中忘记查、在resultMap中忘记加入映射 查询是否有领取但未执行的时候没有加入@DBRouter，导致无法扫描到其他表 Day11：规则引擎量化人群参与活动 增加规则引擎开发需要的相关的配置类表：rule_tree、rule_tree_node、rule_tree_node_line rule_tree 决策树基本信息 rule_tree_node 决策树各节点信息 rule_tree_node_line 决策树树枝信息 运用组合模式搭建规则引擎领域服务，包括：logic 逻辑过滤器、engine 引擎执行器 修改 lottery-infrastructure 基础层中仓储实现类更为合适的的注解为 @Repository 包括： ActivityRepository、RuleRepository、StrategyRepository、UserTakeActivityRepository 梳理流程 Filter主要是用来进行规则过滤，也就是根据当前的matter获取到下一个节点 Engine主要是作为规则引擎，也就是根据过滤条件等来获取到最终的节点信息 门面接口封装和对象转换以 DDD 设计的结构框架，在接口层和应用层需要做防污处理，也就是说不能直接把应用层、领域层的对象直接暴露处理，因为暴露出去可能会随着业务发展的过程中不断的添加各类字段，从而破坏领域结构。那么就需要增加一层对象转换，也就有了 vo2dto、dto2vo 的操作。但这些转换的字段又基本都是重复的，在保证性能的情况下，一些高并发场景就只会选择手动编写 get、set，但其实也有很多其他的方式，转换性能也不差，这里列举一下。 本章节总体而言完成了三个工作： 完成application应用层拼接量化规则操作，返回可以抽奖的活动id 在接口层添加对象转换，完成防污处理 提供rpc接口，分别实现按照id抽奖以及按照量化人群决策进行抽奖两种模式 Day12搭建MQ消息组件Kafka服务环境使用MQ消息组件的原因： 当用户发起抽奖，如果我们一条链路进行执行的话就会造成卡顿的现象，因此需要异步调用。先告诉用户中奖了，之后再进行别的操作 windows配置kafka首先在官网下载稳定版本的kafka并且进行解压，在解压后的目录下使用终端进行打开 启动zookeeper： 1bin/windows/zookeeper-server-start.bat config/zookeeper.properties 关闭zookeeper： 1bin/windows/zookeeper-server-stop.bat config/zookeeper.properties 启动kafka： 1bin/windows/kafka-server-start.bat config/server.properties 关闭kafka： 1bin/windows/kafka-server-stop.bat config/server.properties 创建主题： 1bin/windows/kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic Hello-Kafka 查看主题： 1bin/windows/kafka-topics.bat --list --zookeeper localhost:2181 发送消息： 1bin/windows/kafka-console-producer.bat --broker-list localhost:9092 --topic Hello-Kafka 接收消息： 1bin/windows/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic Hello-Kafka --from-beginning 使用MQ解耦抽奖发货流程大体流程如下： 在ActivityProcessImpl中的doDrawProcess方法中调用kafkaProducer.sendLotteryInvoice(invoiceVO);发送MQ，触发发奖流程 在LotteryInvoiceListener中进行监听消费，主要完成以下操作 判断消息是否存在 处理MQ消息（转换对象，获取发送奖品工厂执行发奖，打印日志，消息消费完成） Day13：xxl-job完成活动状态扫描引入过程 下载：2.3.0 打开：使用 IDEA 打开下载的 xxl-job 导表：把 xxl-job 中的 doc\\db\\tables_xxl_job.sql 导入到自己的数据库中 启动：xxl-job-admin 是用于管理分布式任务调度的后台，一切配置完后，启动 xxl-job-admin 另外你需要配置 application.properties 修改数据库链接参数和日志文件夹 案例：xxl-job-executor-samples 是一组job任务案例，运行后可以在分布式任务调度后台管理任务，配置、启动、关闭 核心：xxl-job-core 执行启动 启动前检查好 application.properties 中的端口号 确保数据库表已经初始化完成，并修改 application.properties 中数据库链接信息 修改 logback.xml 日志打印目录，否则日志找不到会报错 像启动 SpringBoot 程序一样，启动这个 xxl-job 任务调度后台，如果你是部署到云服务器，则需要打包构架部署 访问页面 地址：http://localhost:7397/xxl-job-admin 我修改端口为7397了，你按照自己的端口就可以 账号：admin 密码：123456 Day14：扫描库表补偿发货单MQ消息 我们的任务流程，完成的就是整个抽奖活动中，关于中奖结果落库后，进行MQ后。出现问题时，进行补偿消息发送处理的部分。 在MQ消息补偿的过程中，会把发送失败的消息和迟迟没有发送的消息，都进行补偿，已保障全流程的可靠性。 目前流程启动流程 启动 zk、kafka，总怕你忘记，如果你已经云服务器了，可以先部署上去。 启动 xxl-job 启动 lottery 使用debug模式，方便验证 修改库表中，user_strategy_export_001~004 中任意一个表的 MQ 状态为 2 表示发送 MQ 失败 Day15：安装宝塔linux 在官网上获得centos的命令行在虚拟机中运行即可 外网面板地址: https://101.35.210.50:28478/a612fca3 内网面板地址: https://10.0.4.11:28478/a612fca3 username: p7mm5wky password: c587d4e6 遇到的问题： 最初在自己的虚拟机上面进行安装，发现无法获取连接 原因： 购买云服务器进行配置安装 本章内容： 在云服务器搭建 Redis 服务，这样可以更加方便的使用 在抽奖系统中引入 Redis 模块，优化用户参与抽奖活动。因为只要有大量的用户参与抽奖，那么这个就属于秒杀场景。所以需要使用 Redis 分布式锁的方式来处理集中化库存扣减的问题，否则在 TPS 达到1k-2k，就会把数据库拖垮。 在设计秒杀流程时，优化锁的颗粒度力度，不要把锁直接放到活动编号上，这样在极端临界情况下会出现秒杀解锁失败，导致库存有剩余但不能下单的情况。所以需要增加锁的颗粒度，以滑动库存剩余编号的方式进行加锁，例如 100001_1、100001_2、100001_3，以此类推，具体看代码实现。 增加缓存扣减库存后，发送 MQ 消息进行异步更新数据库中活动库存，做最终数据一致性处理。这一部分如果你的系统并发体量较大，还需要把 MQ 的数据不要直接对库更新，而是更新到缓存中，再由任务最阶段同步，以此减少对数据库表的操作 滑块库存锁设计 如图所示，即使是使用 Redis 分布式锁，我们也不希望把锁的颗粒度放的太粗，否则还是会出现活动有库存但不能秒杀，提示“活动过于火爆” 那么我们就需要按照活动编号把库存锁的颗粒度缩小，实际操作也并不复杂，只是把活动ID+库存扣减后的值一起作为分布式锁的Key，这样就缩小了锁的颗粒度。 抽奖系统总体流程开发","link":"/2023/06/20/Lottery/"},{"title":"关于 Servlet 的学习","text":"学习目标： 理解并掌握 Servlet 的继承关系 了解 Servlet 的生命周期 了解 HTTP 协议与 Session 会话 1. 设置编码​ tomcat8之前，设置编码： 1234567891011get请求方式： //get方式目前不需要设置编码（基于tomcat8） //如果是get请求发送的中文数据，转码稍微有点麻烦（tomcat8之前） String fname = request.getParameter(&quot;fname&quot;); //1.将字符串打散成字节数组 byte[] bytes = fname.getBytes(&quot;ISO-8859-1&quot;); //2.将字节数组按照设定的编码重新组装成字符串 fname = new String(bytes,&quot;UTF-8&quot;);post请求方式： request.setCharacterEncoding(&quot;UTF-8&quot;); ​ tomcat8开始，设置编码，只需要针对post方式 1request.setCharacterEncoding(&quot;UTF-8&quot;); ​ 注意： 需要注意的是，设置编码(post)这一句代码必须在所有的获取参数动作之前 2.Servlet的继承关系 - 重点查看的是服务方法（service()） 继承关系javax.servlet.Servlet接口 javax.servlet.GenericServlet抽象类 javax.servlet.http.HttpServlet抽象子类 相关方法javax.servlet.Servlet接口: void init(config) - 初始化方法 void service(request,response) - 服务方法 void destory() - 销毁方法 javax.servlet.GenericServlet抽象类：void service(request,response) - 仍然是抽象的 javax.servlet.http.HttpServlet 抽象子类：void service(request,response) - 不是抽象的 String method = req.getMethod(); 获取请求的方式 各种if判断，根据请求方式不同，决定去调用不同的do方法 1234567if (method.equals(&quot;GET&quot;)) { this.doGet(req,resp);} else if (method.equals(&quot;HEAD&quot;)) { this.doHead(req, resp);} else if (method.equals(&quot;POST&quot;)) { this.doPost(req, resp);} else if (method.equals(&quot;PUT&quot;)) { 在HttpServlet这个抽象类中，do方法都差不多: 123456789protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String protocol = req.getProtocol(); String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;); if (protocol.endsWith(&quot;1.1&quot;)) { resp.sendError(405, msg); } else { resp.sendError(400, msg); }} 3.小结 继承关系： HttpServlet -&gt; GenericServlet -&gt; Servlet Servlet中的核心方法： init() , service() , destroy() 服务方法： ​ 当有请求过来时，service方法会自动响应（其实是tomcat容器调用的）​ 在HttpServlet中我们会去分析请求的方式：到底是get、post、head还是delete等等​ 然后再决定调用的是哪个do开头的方法​ 那么在HttpServlet中这些do方法默认都是405的实现风格-要我们子类去实现对应的方法，否则默认会报405错误 因此，我们在新建Servlet时，我们才会去考虑请求方法，从而决定重写哪个do方法 4.Servlet的生命周期1） 生命周期：从出生到死亡的过程就是生命周期。对应Servlet中的三个方法：init(),service(),destroy()2） 默认情况下： 第一次接收请求时，这个Servlet会进行实例化(调用构造方法)、初始化(调用init())、然后服务(调用service()) 从第二次请求开始，每一次都是服务 当容器关闭时，其中的所有的servlet实例会被销毁，调用销毁方法3） 通过案例我们发现： ​ Servlet实例tomcat只会创建一个，所有的请求都是这个实例去响应。 ​ 第一次请求时，tomcat才会去实例化，初始化，然后再服务。这样的好处是什么？ 提高系统的启动速度 。 这样的缺点是什么？ 第一次请求时，耗时较长。 ​ 因此得出结论： 如果需要提高系统的启动速度，当前默认情况就是这样。如果需要提高响应速度，我们应该设置Servlet的初始化时机。4）Servlet的初始化时机： ​ 默认是第一次接收请求时，实例化，初始化​ 可以通过来设置servlet启动的先后顺序,数字越小，启动越靠前，最小值05） Servlet在容器中是：单例的、线程不安全的 单例：所有的请求都是同一个实例去响应 不安全：一个线程需要根据这个实例中的某个成员变量值去做逻辑判断。但是在中间某个时机，另一个线程改变了这个成员变量的值，从而导致第一个线程的执行路径发生了变化 ​ （线程不安全就是说在一个线程操作的过程中，另一个线程将共享域中的数据做了修改，导致访问结果发生错误的过程；举例来说，一个人去上厕所发现里面有纸，然后他就往里走，这时候有一个人把纸拿走了） 我们已经知道了servlet是线程不安全的，给我们的启发是： 尽量的不要在servlet中定义成员变量。如果不得不定义成员变量，那么不要去：①不要去修改成员变量的值 ②不要去根据成员变量的值做一些逻辑判断 5.HTTP协议1） Http 称之为 超文本传输协议 2） Http是无状态的 3） Http请求响应包含两个部分：请求和响应 请求请求包含三个部分： 1.请求行 ； 2.请求消息头 ； 3.请求主体 请求行 作用：展示当前请求的最基本信息 POST /dynamic/target.jsp HTTP/1.1 包含三个信息： 1. 请求的方式 ； 2.请求的URL ； 3.请求的协议（一般都是HTTP1.1） 请求消息头 包含了很多客户端需要告诉服务器的信息，比如：我的浏览器型号、版本、我能接收的内容的类型、我给你发的内容的类型、内容的长度等等 作用：通过具体的参数对本次请求进行详细的说明 格式：键值对，键和值之间使用冒号隔开 相对比较重要的请求消息头： 请求体 作用：作为请求的主体，发送数据给服务器。具体来说其实就是POST请求方式下的请求参数。 三种情况： get方式，没有请求体，但是有一个queryString post方式，有请求体，form data json格式，有请求体，request payload 格式： from data 含义：当前请求体是一个表单提交的请求参数。 查看源码后，发现格式如下： username=tom&amp;password=123456 每一组请求参数是一个键值对 键和值中间是等号 键值对之间是&amp;号 Request Payload 含义：整个请求体以某种特定格式来组织数据，例如JSON格式。 响应响应也包含三本： 1. 响应行 ； 2.响应头 ； 3.响应体 响应行包含三个信息：1.协议 2.响应状态码(200) 3.响应状态(ok) 响应头：包含了服务器的信息；服务器发送给浏览器的信息（内容的媒体类型、编码、内容长度等） 响应体：响应的实际内容（比如请求add.html页面时，响应的内容就是&lt;form….） ①响应状态行 HTTP/1.1 200 OK HTTP协议版本 响应状态码 响应状态的说明文字 ②响应消息头 响应体的说明书。 服务器端对浏览器端设置数据，例如：服务器端返回Cookie信息。 名称 功能 Content-Type 响应体的内容类型 Content-Length 响应体的内容长度 Set-Cookie 服务器返回新的Cookie信息给浏览器 location 在重定向的情况下，告诉浏览器访问下一个资源的地址 ③响应体 服务器返回的数据主体，有可能是各种数据类型。 HTML页面 图片 视频 以下载形式返回的文件 CSS文件 JavaScript文件 ④响应状态码 作用：以编码的形式告诉浏览器当前请求处理的结果 状态码 含义 200 服务器成功处理了当前请求，成功返回响应 302 重定向 400 [SpringMVC特定环境]请求参数问题 403 没有权限 404 找不到目标资源 405 请求方式和服务器端对应的处理方式不一致 406 [SpringMVC特定环境]请求扩展名和实际返回的响应体类型不一致 50X 服务器端内部错误，通常都是服务器端抛异常了 404产生的具体原因： 访问地址写错了，确实是没有这个资源 访问了WEB-INF目录下的资源 Web应用启动的时候，控制台已经抛出异常，导致整个Web应用不可用，访问任何资源都是404 服务器端缓存 6.Session会话1） Http是无状态的 HTTP 无状态 ：服务器无法判断这两次请求是同一个客户端发过来的，还是不同的客户端发过来的 无状态带来的现实问题：第一次请求是添加商品到购物车，第二次请求是结账；如果这两次请求服务器无法区分是同一个用户的，那么就会导致混乱 通过会话跟踪技术来解决无状态的问题。 2） 会话跟踪技术 客户端第一次发请求给服务器，服务器获取session，获取不到，则创建新的，然后响应给客户端 下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到了，那么服务器就判断这一次请求和上次某次请求是同一个客户端，从而能够区分开客户端 常用的API： 123456789request.getSession() -&gt; 获取当前的会话，没有则创建一个新的会话request.getSession(true) -&gt; 效果和不带参数相同request.getSession(false) -&gt; 获取当前会话，没有则返回null，不会创建新的session.getId() -&gt; 获取sessionIDsession.isNew() -&gt; 判断当前session是否是新的session.getMaxInactiveInterval() -&gt; session的非激活间隔时长，默认1800秒session.setMaxInactiveInterval()session.invalidate() -&gt; 强制性让会话立即失效.... 3） session保存作用域 session保存作用域是和具体的某一个session对应的 常用的API： 123void session.setAttribute(k,v)Object session.getAttribute(k)void removeAttribute(k) 7.服务器内部转发以及客户端重定向1） 服务器内部转发 : request.getRequestDispatcher(“…”).forward(request,response); 一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的 地址栏没有变化 2） 客户端重定向： response.sendRedirect(“….”); 两次请求响应的过程。客户端肯定知道请求URL有变化 地址栏有变化 8.DispatcherServlet首先我们构建的代码结构如图 如果这样构建servlet的话，结构过于复杂，因此对其进行优化 如果这样构建servlet，如果还存在与FruitServlet并列的Servlet的话也会产生较为复杂的系统，因此采用一个中央处理器，即DispatcherServlet","link":"/2022/12/25/Servlet/"},{"title":"复习前端知识 HTML&amp;CSS&amp;JavaScript","text":"学习目标： 掌握 HTML 基础知识与常用标签 掌握常用的 CSS 修饰页面的方法 掌握 JavaScript 实现页面功能 HTML12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788891)html语言是解释型语言，不是编译型浏览器是容错的2)html页面中由一对标签组成：&lt;html&gt;&lt;/html&gt;&lt;html&gt; 称之为 开始标签&lt;/html&gt;称之为 结束标签3)title 表示网页的标题4)可以在meta标签中设置编码方式5)&lt;br/&gt;表示换行 。br标签是一个单标签。单标签：开始标签和结束标签是同一个，斜杠放在单词后面6)p 表示段落标签7)img 标签图片标签 src属性表示图片文件的路径 width和height表示图片的大小 alt表示图片的提示8)路径的问题： 1. 相对路径 2. 绝对路径9)h1~h6 : 标题标签10)列表标签:- ol 有序列表 start 表示从*开始，type 显示的类型：A a I i 1(deafult)- ul 无序列表 type disc(default) , circle , square11) u 下划线 b 粗体 i 斜体12) 上标 sup 下标 sub13) HTML中的实体： 小于号 &amp;lt; 大于等于号 &amp;ge; 版权 &amp;copy;14) span 不换行的块标记，可以对这一块进行特殊的修饰处理15) a 表示超链接 href 链接的地址 target: _self 在本窗口打开 _blank 在一个新窗口打开 _parent 在父窗口打开 _top 在顶层窗口打开16) div 层17) 表格 table 行 tr 列 td 表头列 th table中有如下属性（虽然已经淘汰，但是最好了解一下） - border：表格边框的粗细 - width:表格的宽度 - cellspacing：单元格间距 - cellpadding：单元格填充 tr中有一个属性： align -&gt; center , left , right rowspan : 行合并 colspan : 列合并18) 表单 form action:可以实现点击跳转的功能 method:post、get、put、delete 19) input type=&quot;text&quot; 表示文本框 ， 其中 name属性必须要指定，否则这个文本框的数据将来是不会发送给服务器的 input type=&quot;password&quot; 表示密码框 input type=&quot;radio&quot; 表示单选按钮。需要注意的是，name属性值保持一致，这样才会有互斥的效果;可以通过checked属性设置默认选中的项 input type=&quot;checkbox&quot; 表示复选框。name属性值建议保持一致，这样将来我们服务器端获取值的时候获取的是一个数组;可以通过checked属性设置默认选中的项 select 表示下拉列表。每一个选项是option，其中value属性是发送给服务器的值, selected表示默认选中的项 textarea 表示多行文本框（或者称之为文本域）,它的value值就是开始结束标签之间的内容 input type=&quot;submit&quot; 表示提交按钮 input type=&quot;reset&quot; 表示重置按钮 input type=&quot;button&quot; 表示普通按钮 frameset 表示页面框架 ， 这个标签已经淘汰，了解，不需要掌握frame表示框架中的具体页面引用总结：1.HTML是解释型的文本标记语言，不区分大小写2.html,head,title,meta,body,br,p,hr,div,table,form,u,i,b,sup,sub,&amp;nbsp;,span,ul,ol,li,tr,td,th,h1-h6,a,input,select,textarea,img2-1. html , head , title , meta , body , br , ul , ol , h1-h6 , a , img , &amp;nbsp;, p , div , span2-2. table tr , th , td 2-3. form(action='' , method='post') input type='text,pasword,radio,checkbox,submit,button,reset&quot; &lt;select&gt; , &lt;textarea&gt; CSS123456789101112131415161718192021222324252627282930&lt;style type=&quot;text/css&quot;&gt;/* 被style标签包围的范围是CSS环境，可以写CSS代码 *//* 标签样式表 */p{color:red;}/* 类样式 */.f20{font-size:20px;}&lt;/style&gt;&lt;!-- 引用外部的CSS样式表文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/demo01.css&quot;&gt;IE浏览器：实际尺寸 = widthchrome浏览器：实际尺寸= width+左右borderwidth+paddingCSS盒子模型：1.border 边框2.margin 间距3.padding 填充position: absolute -- 绝对定位 , 需要配合使用 left , top relative -- 相对定位 , 一般会和 float , margin , padding .... 一起使用float JavaScript12Javascript : 客户端的一个脚本语言js是一门弱类型的语言 , 变量的数据类型由后面赋的值的类型决定","link":"/2022/12/22/HTML/"},{"title":"MySQL 易忘知识复习","text":"学习目标： 对 MySQL 容易忘的知识的再回顾 基础知识： DUAL: 伪表 12SELECT 1+1,3 * 2FROM DUAL; #dual:伪表 AS:全称：alias(别名)，可以省略 12SELECT employee_id emp_id,last_name AS lnameFROM employees; DISTINCT:去除重复项 12SELECT DISTINCT department_idFROM employees; IFNULL(value,c):解决空值影响，如果不为空，那么就取value值，否则为常数c 12SELECT employee_id, salary &quot;月工资&quot;, salary * (1 + IFNULL(commission_pct,0)) * 12 &quot;年工资&quot;FROM employees; 运算符： 算数运算符 在SQL中，+ 没有连接的作用，就表示加法运算。此时会将字符串转换为数值（隐式转换） 12SELECT 100 + '1' # 在Java中，结果为：1001。FROM DUAL 在SQL中，字符在加法中表示 0 12SELECT 100 + 'a' # 此时将a看为0来进行运算FROM DUAL; 运算中NULL的情况 123SELECT 100 + NULL # null参与运算则结果为null100 DIV 0 # 分母如果为0，结果为NULLFROM DUAL; 比较运算符 = &lt;=&gt; &lt;&gt; != &lt; &lt;= &gt; &gt;= 注意：&lt;=&gt;:安全等于.记忆技巧：为null而生，有null时结果不为null 12SELECT NULL &lt;=&gt; NULL, 1 &lt;=&gt; NULLFROM DUAL; #1 0 特殊运算符 IS NULL \\ IS NOT NULL \\ ISNULL LEAST \\ GREATEST BETWEEN 条件下界 AND 条件上界（包含边界） IN (set) \\ NOT IN(set) LIKE:模糊查询 12345678SELECT last_nameFROM employeesWHERE last_name LIKE '%a%';#包含a的名字# 查询第二个字符为_且第3个字符为'a'的员工信息SELECT last_nameFROM employeesWHERE last_name LIKE '_\\_a%'; REGEXP \\ RLIKE : 正则表达式 ^ 表示以什么为开头 $ 表示以什么为结束 逻辑运算符： OR || AND &amp;&amp; NOT ! XOR（异或） 位运算符： &amp; | ^ ~ &gt;&gt; &lt;&lt; ^ 异或 ~ 取反 排序： 使用ORDER BY对查询到的数据进行排序操作 12345#升序操作：ASC(ascend)#降序操作：DESC(descend)SELECT employee_id,last_name,salaryFROM employeesORDER BY salary DESC; 注意： 可以利用列的别名进行排序 可以进行二级排序，按照声明的顺序进行排序 1234#练习：显示员工信息，按照department_id的降序排列，salary的升序排列SELECT employee_id,salary,department_idFROM employeesORDER BY department_id DESC,salary ASC; 别名只能在ORDER BY 中进行使用，不能在WHERE中进行使用原因：执行顺序是—&gt;先执行WHERE再进行别名操作，最后进行ORDER BY 分页： MySQL使用 limit 来实现数据的分页 123456#需求：每页显示pageSize条记录，此时显示第pageNo页：#公式：LIMIT (pageNo-1) * pageSize,pageSize;# 每页显示20条记录，此时显示第3页SELECT employee_id,last_nameFROM employeesLIMIT 40,20; 声明顺序： 123# 声明顺序如下： WHERE ... ORDER BY ...LIMIT # LIMIT的格式： 严格来说：LIMIT 位置偏移量,条目数# 结构&quot;LIMIT 0,条目数&quot; 等价于 &quot;LIMIT 条目数&quot; 其他特殊操作 如果表里有107条数据，我们只想要显示第 32、33 条数据怎么办呢？ 1234SELECT employee_id,last_nameFROM employees#limit 31,2;LIMIT 2 OFFSET 31; 需要查询员工最高工资怎么办呢？ 12345#查询员工表中工资最高的员工的信息SELECT employee_id,last_name,salaryFROM employeesORDER BY salary DESCLIMIT 0,1; 注意事项： LIMIT 可以使用在MySQL、PGSQL、MariaDB、SQLite 等数据库中使用，表示分页。 不能使用在SQL Server、DB2、Oracle！ 多表查询： 多表查询操作可以在WHERE中进行 123SELECT emp.employee_id,dept.department_name,emp.department_idFROM employees emp,departments deptWHERE emp.`department_id` = dept.department_id; 多表查询的分类： 等值连接 vs 非等值连接 1234#非等值连接的例子SELECT e.last_name,e.salary,j.grade_levelFROM employees e, job_grades jWHERE e.salary BETWEEN j.`lowest_sal` AND j.`highest_sal`; 自连接 vs 非自连接 12345#自连接的例子：#练习：查询员工id,员工姓名及其管理者的id和姓名SELECT emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_nameFROM employees emp ,employees mgrWHERE emp.`manager_id` = mgr.`employee_id`; 内连接 vs 外连接 内连接：合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 1234# 两个表不匹配的就被消去了SELECT employee_id,department_nameFROM employees e,departments dWHERE e.`department_id` = d.department_id; 外连接：合并具有同一列的两个以上的表的行, 结果集中除了包含一个表与另一个表匹配的行之外，还查询到了左表或右表中不匹配的行。 外连接的分类：左外连接、右外连接、满外连接 左外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左表中不满足条件的行，这种连接称为左外连接。 123SELECT last_name,department_nameFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`; 右外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回右表中不满足条件的行，这种连接称为右外连接。 123SELECT last_name,department_nameFROM employees e RIGHT OUTER JOIN departments dON e.`department_id` = d.`department_id`; 满外连接： 1234#满外连接：mysql不支持FULL OUTER JOINSELECT last_name,department_nameFROM employees e FULL OUTER JOIN departments dON e.`department_id` = d.`department_id`; UNION 和 UNION ALL的使用 UNION：会执行去重操作 UNION ALL：不会执行去重操作 结论：如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。 SQL99语法中关于连接的新特性 12345678910111213141516171819202122232425# 10.SQL99语法的新特性1：自然连接SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.`department_id` = d.`department_id`AND e.`manager_id` = d.`manager_id`;SELECT employee_id,last_name,department_nameFROM employees e NATURAL JOIN departments d;#11. SQL99语法的新特性2:USINGSELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.department_id = d.department_id;SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dUSING (department_id);#拓展：SELECT last_name,job_title,department_name FROM employees INNER JOIN departments INNER JOIN jobs ON employees.department_id = departments.department_id AND employees.job_id = jobs.job_id; 单行函数： 包括数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数等，见w3school或者尚硅谷第七章PPT 聚合函数: 包括求最大值最小值、平均值、计算总数 ​ GROUP BY： 1234#结论1：SELECT中出现的非组函数的字段必须声明在GROUP BY 中。# 反之，GROUP BY中声明的字段可以不出现在SELECT中。#结论2：GROUP BY 声明在FROM后面、WHERE后面，ORDER BY 前面、LIMIT前面#结论3：MySQL中GROUP BY中使用WITH ROLLUP:计算整体的平均 ​ HAVING的使用 (作用：用来配合GROUP BY过滤数据的) 1234SELECT department_id,MAX(salary)FROM employeesGROUP BY department_idHAVING MAX(salary) &gt; 10000; HAVING和WHERE对比 结论：当过滤条件中有聚合函数时，则此过滤条件必须声明在HAVING中。当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE中或HAVING中都可以。但是，建议大家声明在WHERE中。 从适用范围上来讲，HAVING的适用范围更广。 如果过滤条件中没有聚合函数：这种情况下，WHERE的执行效率要高于HAVING 123456789101112131415161718192021222324252627#4. SQL底层执行原理#4.1 SELECT 语句的完整结构/*#sql92语法：SELECT ....,....,....(存在聚合函数)FROM ...,....,....WHERE 多表的连接条件 AND 不包含聚合函数的过滤条件GROUP BY ...,....HAVING 包含聚合函数的过滤条件ORDER BY ....,...(ASC / DESC )LIMIT ...,....#sql99语法：SELECT ....,....,....(存在聚合函数)FROM ... (LEFT / RIGHT)JOIN ....ON 多表的连接条件 (LEFT / RIGHT)JOIN ... ON ....WHERE 不包含聚合函数的过滤条件GROUP BY ...,....HAVING 包含聚合函数的过滤条件ORDER BY ....,...(ASC / DESC )LIMIT ...,....*/#4.2 SQL语句的执行过程：#FROM ...,...-&gt; ON -&gt; (LEFT/RIGNT JOIN) -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; DISTINCT -&gt; # ORDER BY -&gt; LIMIT 子查询： 子查询的引入 1234567SELECT last_name,salaryFROM employeesWHERE salary &gt; ( SELECT salary FROM employees WHERE last_name = 'Abel'); 子查询（内查询）在主查询之前一次执行完成。 子查询的结果被主查询（外查询）使用 。 注意事项 子查询要包含在括号内 将子查询放在比较条件的右侧 单行操作符对应单行子查询，多行操作符对应多行子查询 子查询的分类 单行子查询和多行子查询 单行子查询： 123456SELECT employee_id, last_name, CASE department_id WHEN (SELECT department_id FROM departments WHERE location_id = 1800) THEN 'Canada' ELSE 'USA' END &quot;location&quot;FROM employees; 多行子查询： ​ 多行子查询的操作符： IN ANY ALL SOME(同ANY) 123456SELECT employee_id, last_name, department_id,salaryFROM employeesWHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id); 1234567891011# ANY / ALL:#题目：返回其它job_id中比job_id为‘IT_PROG’部门某个员工工资低的员工的员工号、#姓名、job_id 以及salarySELECT employee_id,last_name,job_id,salaryFROM employeesWHERE job_id &lt;&gt; 'IT_PROG'AND salary &lt; ANY ( SELECT salary FROM employees WHERE job_id = 'IT_PROG' ); 12345678910#题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资低的员工的员工号、#姓名、job_id 以及salarySELECT employee_id,last_name,job_id,salaryFROM employeesWHERE job_id &lt;&gt; 'IT_PROG'AND salary &lt; ALL ( SELECT salary FROM employees WHERE job_id = 'IT_PROG' ); 结论：在SELECT中，除了GROUP BY 和 LIMIT之外，其他位置都可以声明子查询！ 12345678910/* SELECT ....,....,....(存在聚合函数) FROM ... (LEFT / RIGHT)JOIN ....ON 多表的连接条件 (LEFT / RIGHT)JOIN ... ON .... WHERE 不包含聚合函数的过滤条件 GROUP BY ...,.... HAVING 包含聚合函数的过滤条件 ORDER BY ....,...(ASC / DESC ) LIMIT ...,.... */ 数据处理之增删改 将查询结果插入到新建的表中 12345INSERT INTO emp1(id,NAME,salary,hire_date)#查询语句SELECT employee_id,last_name,salary,hire_date # 查询的字段一定要与添加到的表的字段一一对应FROM employeesWHERE department_id IN (70,60); 说明：emp1表中要添加数据的字段的长度不能低于employees表中查询的字段的长度。如果emp1表中要添加数据的字段的长度低于employees表中查询的字段的长度的话，就有添加不成功的风险。 更新数据（或者修改数据） 1UPDATE .... SET .... WHERE ... 可以实现批量修改数据；可以同时修改一条数据的多个字段 删除数据 1DELETE FROM .... WHERE.... 注意： DML操作默认情况下，执行完以后都会自动提交数据。如果希望执行完以后不自动提交数据，则需要使用 1SET autocommit = FALSE. SQL8新特性：计算列 12345CREATE TABLE test1( a INT, b INT, c INT GENERATED ALWAYS AS (a + b) VIRTUAL #字段c即为计算列); 数据类型： 有关数据类型的介绍包括： 整数类型 浮点类型 定点数类型 位类型 日期与时间类型 文本字符串类型 ENUM枚举类类型 SET类型 二进制字符串类型 JSON类型 空间类型 约束：","link":"/2022/11/20/SQL/"},{"title":"JavaWeb的复习","text":"学习目标： 复习 JavaWeb 相关知识 掌握前端重点知识内容 初步了解 JQuery 前言： 在这篇文章之中，主要描述自己认为的重要的知识点和易忘的知识点，可能有些片面或者不足，请多多指教。 HTML&amp;CSS标签： 标签的格式：&lt;标签名&gt;封装的数据&lt;/标签名&gt; 标签拥有自己的属性 基本属性：color=”red” 事件属性：onclick=”alert(‘Hello!’);” 标签的注意事项 标签不能交叉嵌套 标签必须要正确关闭 标签属性必须有值，属性值必须加引号 注释不能嵌套 常用的标签介绍：w3school 表格： 跨行跨列表格的创建 1234&lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;&lt;!--跨两列--&gt; &lt;td rowspan=&quot;2&quot;&gt;&lt;/td&gt;&lt;!--跨两行--&gt;&lt;/tr&gt; 表单： 123456789101112131415161718192021222324252627282930313233343536&lt;!--form 标签就是表单input type=text 是文件输入框 value 设置默认显示内容input type=password 是密码输入框 value 设置默认显示内容input type=radio 是单选框 name 属性可以对其进行分组 checked=&quot;checked&quot;表示默认选中input type=checkbox 是复选框 checked=&quot;checked&quot;表示默认选中input type=reset 是重置按钮 value 属性修改按钮上的文本input type=submit 是提交按钮 value 属性修改按钮上的文本input type=button 是按钮 value 属性修改按钮上的文本input type=file 是文件上传域input type=hidden 是隐藏域 当我们要发送某些信息，而这些信息，不需要用户参与，就可以使用隐藏域（提交的时候同时发送给服务器）select 标签是下拉列表框option 标签是下拉列表框中的选项 selected=&quot;selected&quot;设置默认选中textarea 表示多行文本输入框 （起始标签和结束标签中的内容是默认值）rows 属性设置可以显示几行的高度cols 属性设置每行可以显示几个字符宽度--&gt;&lt;!--一些表单提交的细节问题form 标签是表单标签action 属性设置提交的服务器地址method 属性设置提交的方式 GET(默认值)或 POST表单提交的时候，数据没有发送给服务器的三种情况：1、表单项没有 name 属性值2、单选、复选（下拉列表中的 option 标签）都需要添加 value 属性，以便发送给服务器3、表单项不在提交的 form 标签中GET 请求的特点是：1、浏览器地址栏中的地址是：action 属性[+?+请求参数]请求参数的格式是：name=value&amp;name=value2、不安全3、它有数据长度的限制POST 请求的特点是：1、浏览器地址栏中只有 action 属性值2、相对于 GET 请求要安全3、理论上没有数据长度的限制--&gt; CSS： CSS选择器分为以下几种： 标签名选择器，格式 123标签名{ 属性：值;} id 选择器 123#id 属性值{ 属性：值;} class选择器 123.class 属性值{ 属性：值;} 组合选择器 123选择器 1，选择器 2，选择器 n{ 属性：值;} JavaScriptJavaScript书写的两种方式： 在head标签或者body标签中，使用script标签来书写JavaScript代码即可 123&lt;script type=&quot;text/javascript&quot;&gt; &lt;!-- script 内容 --&gt;&lt;/script&gt; 书写单独的js文件，然后对js文件进行引入即可 1&lt;script type=&quot;text/javascript&quot; src=&quot;1.js&quot;&gt;&lt;/script&gt; 变量： 格式 12var i;var i = 10; 关系比较： ==：表示等于，做的是简单的字面值的比较 ===：表示全等于，除了比较简单的字面值，也会比较两个变量的类型 逻辑运算： &amp;&amp;、||、！ 运算法则 &amp;&amp; 且运算。有两种情况： 第一种：当表达式全为真的时候。返回最后一个表达式的值。 第二种：当表达式中，有一个为假的时候。返回第一个为假的表达式的值 || 或运算 第一种情况：当表达式全为假时，返回最后一个表达式的值 第二种情况：只要有一个表达式为真。就会把回第一个为真的表达式的值 &amp;&amp; 与运算 和 ||或运算有短路。短路就是说，当这个&amp;&amp;或||运算有结果了之后 。后面的表达式不再执行 数组： 格式 12var 数组名 = []; // 空数组var 数组名 = [1 , ’abc’ , true]; // 定义数组同时赋值元素 函数： 格式 方式一 123function 函数名(形参列表){ 函数体} 方式二 123var 函数名 = function(形参列表) { 函数体 } 在 JavaScript 语言中，如何定义带有返回值的函数？ 只需要在函数体内直接使用 return 语句返回值即可！ 注：在 Java 中函数允许重载。但是在 JS 中函数的重载会直接覆盖掉上一次的定义 隐形参数： 就是在 function 函数中不需要定义，但却可以直接用来获取所有参数的变量。我们管它叫隐形参数。 隐形参数特别像 java 基础的可变长参数一样。public void fun( Object … args ); 可变长参数其他是一个数组。那么 js 中的隐形参数也跟 java 的可变长参数一样，操作类似数组。 1234567function fun(a) { alert( arguments.length );//可看参数个数 alert( arguments[0] ); alert( arguments[1] ); alert( arguments[2] );}fun(1,&quot;haha&quot;,true); 自定义对象： 方式一： 定义的方式： 123var 变量名 = new Object(); // 对象实例（空对象）变量名.属性名 = 值; // 定义一个属性变量名.函数名 = function(){} // 定义一个函数 对象的访问： 1变量名.属性 / 函数名(); 举例： 123456var obj = new Object();obj.name = &quot;华仔&quot;;obj.age = 18;obj.fun = function () {alert(&quot;姓名：&quot; + this.name + &quot; , 年龄：&quot; + this.age);} 方式二： 定义的方式： 12345var 变量名 = { // 空对象 属性名：值, // 定义一个属性 属性名：值, // 定义一个属性 函数名：function(){} // 定义一个函数} 对象的访问： 1变量名.属性 / 函数名(); 举例说明： 1234567var obj = { name:&quot;国哥&quot;, age:18, fun : function () { alert(&quot;姓名：&quot; + this.name + &quot; , 年龄：&quot; + this.age); }}; ​ 事件： 事件是电脑输入设备与页面进行交互的响应。我们称之为事件。 常用的事件： onload 加载完成事件：页面加载完成之后，常用于做页面 js 代码初始化操作 onclick 单击事件：常用于按钮的点击响应操作。 onblur 失去焦点事件：常用用于输入框失去焦点后验证其输入内容是否合法。 onchange 内容发生改变事件：常用于下拉列表和输入框内容发生改变后操作 onsubmit 表单提交事件：常用于表单提交前，验证所有表单项是否合法。 事件的注册 就是告诉浏览器，当事件响应后要执行哪些操作代码，叫事件注册或事件绑定。 分为静态注册和动态注册两种： 静态注册事件：通过 html 标签的事件属性直接赋于事件响应后的代码，这种方式我们叫静态注册。 动态注册事件：是指先通过 js 代码得到标签的 dom 对象，然后再通过 dom 对象.事件名 = function(){} 这种形式赋于事件响应后的代码，叫动态注册。 动态注册基本步骤： 获取标签对象 标签对象.事件名 = fucntion(){} 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 静态注册失去焦点事件 function onblurFun() { // console 是控制台对象，是由 JavaScript 语言提供，专门用来向浏览器的控制器打印输出， 用于测试使用 // log() 是打印的方法 console.log(&quot;静态注册失去焦点事件&quot;); } // 动态注册 onblur 事件 window.onload = function () { //1 获取标签对象 var passwordObj = document.getElementById(&quot;password&quot;); // alert(passwordObj); //2 通过标签对象.事件名 = function(){}; passwordObj.onblur = function () { console.log(&quot;动态注册失去焦点事件&quot;); } }&lt;/script&gt;&lt;/head&gt; DOM模型： DOM 全称是 Document Object Model 文档对象模型 大白话，就是把文档中的标签，属性，文本，转换成为对象来管理。 Document 对象的理解： 第一点：Document它管理了所有的 HTML 文档内容。 第二点：document 它是一种树结构的文档。有层级关系。 第三点：它让我们把所有的标签都对象化 第四点：我们可以通过 document 访问所有的标签对象。 Document对象中的方法 **document.getElementById(elementId)**——通过标签的 id 属性查找标签 dom 对象，elementId 是标签的 id 属性值 **document.getElementsByName(elementName)**——通过标签的 name 属性查找标签 dom 对象，elementName 标签的 name 属性值 **document.getElementsByTagName(tagname)**——通过标签名查找标签 dom 对象。tagname 是标签名 **document.createElement( tagName)**——通过给定的标签名，创建一个标签对象。tagName 是要创建的标签名 ​ 注： document 对象的三个查询方法，如果有 id 属性，优先使用 getElementById 方法来进行查询 如果没有 id 属性，则优先使用 getElementsByName 方法来进行查询 如果 id 属性和 name 属性都没有最后再按标签名查 getElementsByTagName 以上三个方法，一定要在页面加载完成之后执行，才能查询到标签对象。 节点 childNodes 属性，获取当前节点的所有子节点 firstChild 属性，获取当前节点的第一个子节点 lastChild 属性，获取当前节点的最后一个子节点 parentNode 属性，获取当前节点的父节点 nextSibling 属性，获取当前节点的下一个节点 previousSibling 属性，获取当前节点的上一个节点 className 用于获取或设置标签的 class 属性值 innerHTML 属性，表示获取/设置起始标签和结束标签中的内容 innerText 属性，表示获取/设置起始标签和结束标签中的文本 JQuery 使用方式： 12345678910111213141516&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // window.onload = function () { // var btnObj = document.getElementById(&quot;btnId&quot;); // // alert(btnObj);//[object HTMLButtonElement] ====&gt;&gt;&gt; dom 对象 // btnObj.onclick = function () { // alert(&quot;js 原生的单击事件&quot;); // } // } $(function () { // 表示页面加载完成 之后，相当 window.onload = function () {} var $btnObj = $(&quot;#btnId&quot;); // 表示按 id 查询标签对象 $btnObj.click(function () { // 绑定单击事件 alert(&quot;jQuery 的单击事件&quot;); }); });&lt;/script&gt; 注意：使用JQuery必须要引入JQuery库 JQuery核心函数 $ 是JQuery的核心函数，可以完成JQuery的很多功能 调用方式 $()，相当于 window.onload = function(){} 传入参数为 [ HTML 字符串 ] 时：会为我们创建这个 html 标签对象 传入参数为 [ 选择器字符串 ] 时： ​ $(“#id 属性值”)：id 选择器，根据 id 查询标签对象 ​ $(“标签名”)：标签名选择器，根据指定的标签名查询标签对象 ​ $(“.class 属性值”); 类型选择器，可以根据 class 属性查询标签对象 传入参数为 [ DOM 对象 ] 时：会把这个 dom 对象转换为 jQuery 对象 JQuery对象和DOM对象的区别 jQuery 对象本质上是 dom 对象的数组 + jQuery 提供的一系列功能函数。 JQuery对象和DOM对象的相互转换","link":"/2022/11/20/JavaWeb-review/"},{"title":"A review of generics and list","text":"学习目标： 对集合相关易错知识进行复习 复习泛型相关知识 List:remove():There are two methods to remove an element from a list. remove by index –&gt; remove(int index) remove by content –&gt; remove(Object o) List deletes elements by moving the element after the target one index position, setting the last element to null and size-1; So it’s best to delete from large to small. Some mistakes:Error1: 12345for(int i = 0, len = list.size(); i &lt; len; i++){ if(list.get(i) == 1) { list.remove(i); } } 123Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: Index: 3, Size: 3 at java.util.ArrayList.RangeCheck(Unknown Source) at java.util.ArrayList.get(Unknown Source) The array is out of bounds. After deleting the element and not changing the corresponding index, it will not be found when iterating through the last one. So throw this exception. Error2: 1234567Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ int i = iterator.next(); if(i == 1){ list.remove(i); //错误,ConcurrentModificationException异常。 } } The modCount value of the list object is modified. The modCount value of the iterator is not modified, so it throw out this exception. The right method to remove an element from list:Method1: 1234567for(int i = 0, len = list.size(); i &lt; len; i++){ if(list.get(i) == 1){ list.remove(i); len--; i--; } } Method2: 1234567Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ int i = iterator.next(); if(i == 1){ iterator.remove(); //正确 } } Method3: 1234567int size = list.size();for(int i = size - 1; i &gt;= 0; i--){ String item = list.get(i); if(target.equals(item)){ list.remove(item); }} Method4: 123456CopyOnWriteArrayList&lt;String&gt; cowList = new CopyOnWriteArrayList&lt;String&gt;(list);for (String item : cowList) { if (item.equals(target)) { cowList.remove(item); }} Solved the list concurrency problem. Generics:Some details about generics 12345678910111213/** * 泛型的使用 * 1.jdk 5.0新增的特性 * * 2.在集合中使用泛型： * 总结： * ① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。 * ② 在实例化集合类时，可以指明具体的泛型类型 * ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。 * 比如：add(E e) ---&gt;实例化以后：add(Integer e) * ④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换 * ⑤ 如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。 */ Some notes of generics 123456789101112131. 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;2. 泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass&lt;E&gt;(){}3. 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。4. 泛型不同的引用不能相互赋值。 &gt;尽管在编译时ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。5. 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用。6. 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。7. jdk1.7，泛型的简化操作：ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;();8. 泛型的指定中不能使用基本数据类型，可以使用包装类替换。9. 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。10. 异常类不能是泛型的11. 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。 Extend of generics 123456789父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：&gt; 子类不保留父类的泛型：按需实现 &gt; 没有类型 擦除 &gt; 具体类型&gt; 子类保留父类的泛型：泛型子类 &gt; 全部保留 &gt; 部分保留结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型 The embodiment of generics in terms of inheritance Although class A is the parent of class B，but the relationship between G and G is not parent and child, they are paratactic. For example: 123List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); list1 = list 2; //Error Additional: If class A is parent of class B，A is parent of B. The use of wildcards wildcards: ? If class A is parent of class B, the relationship between G and G is not parent and child, their parent is: G&lt;?&gt; For example: 123456789public void test3(){ List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = null; List&lt;?&gt; list = null; list = list1; list = list2;} The use of conditional wildcards ? extends A: G&lt;? extends A&gt; can be parent of G and G, class B is child of class A ​ ? super A:​ G&lt;? super A&gt; can be parent of G and G , class B is parent of class A 12345678910111213141516List&lt;? extends Person&gt; list1 = null;List&lt;? super Person&gt; list2 = null;List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;();;List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;();;List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;();;//可以这么认为：? extends A 代表 ?为A的一个子类，也可以将extends类比于&lt;=;list1 = list3;list1 = list4;// list1 = list5; //error//可以这么认为：? super A 代表 ?为A的一个父类，也可以将super类比于&gt;=;// list2 = list3;//errorlist2 = list4;list2 = list4;","link":"/2022/11/19/GenericsAndList/"},{"title":"Leetcode","text":"力扣刷题记录 Chapter1-EasyQuestion1: Two Sum题目描述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 可以按任意顺序返回答案。 分析：看到题目第一眼思考就是采用暴力破解的方法，将数组里的全部元素都进行遍历，寻找是否有符合的数字。 解法一：暴力求解 12345678910111213class Solution { public int[] twoSum(int[] nums, int target) { int n = nums.length; for (int i = 0; i &lt; n; ++i) { for (int j = i + 1; j &lt; n; ++j) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } return new int[0]; }} 暴力求解时间复杂度为O(N2) 暴力求解空间复杂度为O(1) 解法二：利用哈希表 12345678910111213141516171819202122class Solution { public int[] twoSum(int[] nums, int target) { //Perhaps the best one of all I have seen. //First create the result set. int[] res = new int[2]; //Judge the set. if(nums == null || nums.length == 0){ return res; } Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i = 0; i &lt; nums.length; i++) { int temp = target - nums[i]; if(map.containsKey(temp)) { res[1] = map.get(temp); res[0] = i; } //Insert into map map.put(nums[i],i); } return res; }} 利用哈希表得到的性能优于暴力求解 时间复杂度为O(N) 空间复杂度为O(N) Question2:Palindrome题目要求：给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 分析：最简单的就是转换为一个字符串之后进行一一对比；进一步的思路是，将倒过来的数字求出来，然后进行对比。 解法一： 12345678910111213class Solution { public boolean isPalindrome(int x) { String s = Integer.toString(x); char arr[] = s.toCharArray(); boolean flag = true;//判断是不是回文数 for (int i = 0; i &lt; arr.length / 2; i++) { if (arr[i] != arr[arr.length - 1 - i]) { flag = false; } } return flag; }} 解法二：将数字进行反转之后比较与原有数字是否相同 1234567891011121314151617class Solution { public boolean isPalindrome(int x) { if(x &lt; 0 ||(x % 10 == 0 &amp;&amp; x != 0) ) { return false; } if(x == 0) { return true; } int reverse = 0; int temp = x; while(x &gt; 0) { reverse = reverse * 10 + x % 10; x = x / 10; } return temp == reverse || temp == reverse / 10; }} 解法三：对解法二的拓展（官方解答）相当于只做一半的反转，然后进行比较 1234567891011121314151617181920212223class Solution { public boolean isPalindrome(int x) { // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) { return false; } int revertedNumber = 0; while (x &gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber / 10; }} Question3:Roman numerals to integers题目要求： 分析：本题目只要读明白题目是不难的。首先，我们要通过一种方式 ，将罗马数字和整数之间有一个对应（评论区有一个枚举法，就是将所有可能的情况全部进行一一对应，然后在进行判断），对应之后，我们判断this的罗马数字和下一位的比较，如果this&gt;this+1,那么就说明正常加即可，但是this&lt;this_1的时候，就需要进行相减。别忘记判断越界 解答： 123456789101112131415161718192021222324252627282930313233343536373839404142public int romanToInt(String s) { //本题目是为了将罗马数字转化为普通的数字 //我们要进行两个判断，首先判断他是谁，然后判断他与下一位的比较，判断正负 //1.将罗马数字与数字做对应 //{'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000 int length = s.length(); int[] nums = new int[length]; for (int i = 0; i &lt; length; i++) { switch (s.charAt(i)){ case 'I': nums[i] = 1; break; case 'V': nums[i] = 5; break; case 'X': nums[i] = 10; break; case 'L': nums[i] = 50; break; case 'C': nums[i] = 100; break; case 'D': nums[i] = 500; break; case 'M': nums[i] = 1000; break; } } int res = 0; for(int i = 0; i &lt; nums.length; i++) { if((i &lt; nums.length - 1) &amp;&amp; nums[i] &lt; nums[i+1]){ res -= nums[i]; } else { res += nums[i]; } } return res; } Question4:The longest identical prefix题目描述： 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。 分析：本题我是采用数据结构老师韩顺平的方法，先写出查找第一个字母是否相同，然后进行推断可以得到一个循环来进行判断。 解答： 1234567891011121314151617181920212223242526272829303132333435class Solution { public String longestCommonPrefix(String[] strs) { //先创建一个数组，把长度添加到数组 int len = strs.length; int[] lenSet = new int[len]; int minLen = 200; for (int i = 0; i &lt; len; i++) { lenSet[i] = strs[i].length(); if (strs[i].length() &lt; minLen) { minLen = strs[i].length(); } } StringBuffer res = new StringBuffer(); //把第一步的做法进行循环即可 for (int j = 0; j &lt; minLen; j++) { //我先把第一个字符串的第一个字母取出来 char fir = strs[0].charAt(j); boolean flag = true; for (int i = 0; i &lt; strs.length; i++) { if (strs[i].charAt(j) != fir) { flag = false; break; } } if (flag) { res.append(fir); } else { break; } } String resStr = res.toString(); return resStr; }} 上述个人答案属于纵向对比，时间复杂度为O(mn),空间复杂度为O(1) LeetCode官方还有下述几种算法： 横向扫描：拿最长字串去做对比，对比之后更新最长字串 分治算法：yysy，没看懂，以后再来补吧 二分算法：取mid，判断其前缀是否相同来进行判断 Question5:Valid Brackets题目描述： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 分析： 题目的意思是，在s这个只含有括号的字符串中，只能含有三种情 况，”()” “{}” “[]”，不可以进行嵌套，也就是不可以存在”([)]”，本人做法未考虑这种嵌套。 解答： 解法一： 12345678public boolean isValid(String s) { int length = s.length() / 2; for (int i = 0; i &lt; length; i++) { s = s.replace(&quot;()&quot;, &quot;&quot;).replace(&quot;{}&quot;, &quot;&quot;).replace(&quot;[]&quot;, &quot;&quot;); } return s.length() == 0;} 这种解法只考虑了代码的简洁程度，并没有考虑算法的复杂度。 解法二：使用栈空间进行求解 12345678910111213141516171819Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;(); char ch; for (int i = 0; i &lt; s.length(); i++) { ch = s.charAt(i); //碰到左括号，就把相应的右括号入栈 if (ch == '(') { deque.push(')'); }else if (ch == '{') { deque.push('}'); }else if (ch == '[') { deque.push(']'); } else if (deque.isEmpty() || deque.peek() != ch) { return false; }else {//如果是右括号判断是否和栈顶元素匹配 deque.pop(); } } //最后判断栈中元素是否匹配 return deque.isEmpty(); 123456789101112131415161718192021222324252627class Solution { public boolean isValid(String s) { int n = s.length(); if (n % 2 == 1) { return false; } Map&lt;Character, Character&gt; pairs = new HashMap&lt;Character, Character&gt;() {{ put(')', '('); put(']', '['); put('}', '{'); }}; Deque&lt;Character&gt; stack = new LinkedList&lt;Character&gt;(); for (int i = 0; i &lt; n; i++) { char ch = s.charAt(i); if (pairs.containsKey(ch)) { if (stack.isEmpty() || stack.peek() != pairs.get(ch)) { return false; } stack.pop(); } else { stack.push(ch); } } return stack.isEmpty(); }} 利用栈的特性后进先出，将所有的左括号压入栈内，当遇到一个有括号的时候，判断栈顶的括号是否和它匹配，如果匹配就继续，不匹配的话就return false 本题属于遇到的第一个数据结构题目，对于复习数据结构方面的知识还是很有好处的 Question6:Merge two LinkedLists题目描述： 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的 解答： 1234567891011121314151617181920212223public ListNode mergeTwoLists(ListNode list1, ListNode list2) { //先创建一个新链表的头节点 ListNode newNode = new ListNode(0); ListNode cur = newNode; while (list1 != null &amp;&amp; list2 != null) { if (list1.val &lt; list2.val) { cur.next = list1; cur = cur.next; list1 = list1.next; } else { cur.next = list2; cur = cur.next; list2 = list2.next; } } //当一个链表为空的时候，就把非空的接在后面就行了 if (list1 == null) { cur.next = list2; } else if(list2 == null){ cur.next = list1; } return newNode.next; } 本题比较简单，没有什么很难的点，但是要注意一下链表的定义。 Question7:Remove duplicate numbers题目描述： 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 测试代码： 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) { assert nums[i] == expectedNums[i];} 分析：刚开始想把所有的重复的都通过冒泡挪到最后面，但是对于很多情况不适用。看了评论，学会了双指针与单指针的方法。其实大体就是向后判断，后面的要是没有重复，就把它加到前面判断完的后面就行。 解答： 解法一：双指针 123456789101112131415161718public int removeDuplicates(int[] nums) { //利用双指针 if(nums == null || nums.length == 1) { return nums.length; } //创建双指针 int i = 0, j = 1; while( j &lt; nums.length) { if(nums[i] == nums[j]) { j++; } else { i++; nums[i] = nums[j]; j++; } } return i+1; } 解法二：单指针判断 123456789public int removeDuplicates(int[] nums) { int index = 0; for(int i = 1; i &lt; nums.length; i++) { if(nums[i] != nums[i-1]){ nums[++index] = nums[i]; } } return index+1;} Question8:Remove specified value题目描述： 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 分析： 这道题目和上一个类似，都是要取出元素，也可以用指针来做。本人的做法是，构造一个指针指向最末尾的元素，如果前面出现了与指定数字相同的元素，就将这个位置的元素与最后的元素进行交换，交换之后，还要再继续进行这个位置的遍历。 题解： 解法一： 12345678910111213141516public int removeElement(int[] nums, int val) { //采用指针 int count = nums.length; int last = nums.length - 1; for(int i = 0; i &lt;= last; i++) { if(nums[i] == val) { int temp = nums[i]; nums[i] = nums[last]; nums[last] = temp; last--; i--; count--; } } return count; } 解答二： 123456789public int removeElement(int[] nums, int val) { int k = 0; for(int i = 0; i &lt; nums.length; i++) { if(nums[i] != val) { nums[k++] = nums[i]; } } return k; } Question9:Search target number题目描述： 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 分析： 本题就一个二分遍历就完事了 解答： 解法一：直接遍历 12345678910111213141516public int searchInsert(int[] nums, int target) { if(nums.length ==0 || nums == null) { return 0; } if(target &gt; nums[nums.length - 1]) { return nums.length; } int index = 0; for(int i =0; i &lt; nums.length; i++) { if(nums[i] == target || nums[i] &gt; target) { index = i; break; } } return index; } 解法二：二分法查找 12345678910111213public int searchInsert(int[] nums, int target) { int len = nums.length; int l=0,r=len-1; while(l&lt;=r){ int mid=l+(r-l)/2; if(nums[mid]&lt;target){ l=mid+1; } else { r=mid-1; } } return l; } Question10:Last word count题目描述： 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。 单词是指仅由字母组成、不包含任何空格字符的最大子字符串。 题解： 123456789101112public int lengthOfLastWord(String s) { String str = s.trim(); int count = 0; for (int i = str.length() - 1; i &gt;= 0; i--) { if (str.charAt(i) != ' ') { count++; } else { break; } } return count;} Question11:Plus one题目描述： 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 分析： 错误原因是考虑不全面，个人思考的是先将这个数组转换为整数，再将整数加1，然后返回加1之后的数组，没有考虑到整数型溢出的问题。 其实本题思路很简单，从后往前遍历，如果遇到一位不是9，那么直接加一，然后返回即可；如果全是9，那么将所有的i置为0，把首位置为1即可。 题解： 12345678910for (int i = digits.length - 1; i &gt;= 0; i--) { if (digits[i] != 9) { digits[i]++; return digits; } digits[i] = 0; } int[] res = new int[digits.length+1]; res[0] = 1; return res; Question12:Binary addition题目描述： 给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。 分析： 本题做法分为三步： 先将二者的长度置为相同，通过对较短的字符串进行补0来实现 设置一个进位数，通过判断当前的值来看是否发生了进位 将判断的结果加入到字符串中，最终对字符串进行反转即可 题解： 123456789101112131415161718public String addBinary(String a, String b) { StringBuffer ans = new StringBuffer(); int n = Math.max(a.length(), b.length()), carry = 0; for (int i = 0; i &lt; n; ++i) { carry += i &lt; a.length() ? (a.charAt(a.length() - 1 - i) - '0') : 0; carry += i &lt; b.length() ? (b.charAt(b.length() - 1 - i) - '0') : 0; ans.append((char) (carry % 2 + '0')); carry /= 2; } if (carry &gt; 0) { ans.append('1'); } ans.reverse(); return ans.toString(); } Question13:Integer multiples of the square root题目描述： 给定一个非负整数 x ，计算并返回 x 的算术平方根 。 由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 。 分析： 本题很容易就能想到，你可以找一个数，它的平方小于等于这个给定的数，并且+1之后又大于了这个给定的数，这样就找到了这个数。 题解： 方法一：袖珍计算器法 注意： 由于计算机无法存储浮点数的精确值，而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。因此在得到结果的整数部分 ans 后，我们应当找出ans 与ans+1 中哪一个是真正的答案。 123456789class Solution { public int mySqrt(int x) { if (x == 0) { return 0; } int ans = (int) Math.exp(0.5 * Math.log(x)); return (long) (ans + 1) * (ans + 1) &lt;= x ? ans + 1 : ans; }} 方法二：二分法 123456789101112131415161718class Solution { public int mySqrt(int x) { if(x==1) { return 1; } int max = x; int min = 0; while(max - min &gt; 1) { int mid = (max + min) / 2; if(x/mid &lt; mid) { max = mid; } else { min = mid; } } return min; }} 方法三：牛顿迭代 牛顿迭代 Question14:Climb stairs题目描述： 一个人爬楼梯，只能爬一个台阶或者两个，问有几种上楼的方法。 分析： 刚开始我认为这是一道迭代的题目，相当于斐波那契数列，但是发现，如果按照迭代来做，超出了时间限制，因此需要用动态规划的思想来看这个题目。 题解： 方法一： 12345678910111213141516public int climbStairs(int n) { if (n == 1) { return 1; } if (n == 2) { return 2; } int i1 = 1; int i2 = 2; for(int i = 3; i &lt;= n; i++) { int temp = i1+i2; i1 = i2; i2 = temp; } return i2; } 方法二：矩阵计算法 1234567891011121314151617181920212223242526272829public class Solution { public int climbStairs(int n) { int[][] q = {{1, 1}, {1, 0}}; int[][] res = pow(q, n); return res[0][0]; } public int[][] pow(int[][] a, int n) { int[][] ret = {{1, 0}, {0, 1}}; while (n &gt; 0) { if ((n &amp; 1) == 1) { ret = multiply(ret, a); } n &gt;&gt;= 1; a = multiply(a, a); } return ret; } public int[][] multiply(int[][] a, int[][] b) { int[][] c = new int[2][2]; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; } } return c; }} 方法三：利用微分方程的思想 1234567public class Solution { public int climbStairs(int n) { double sqrt5 = Math.sqrt(5); double fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1); return (int) Math.round(fibn / sqrt5); }} Question15:删除排序链表中的重复数据题目描述： 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 题解： 个人解法： 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode deleteDuplicates(ListNode head) { //先设置一个指针 if(head == null) { return null; } ListNode cur = head; while(cur.next != null) { if(cur.next.val == cur.val) { cur.next = cur.next.next; } else{ cur = cur.next; } } return head; }} 递归法： 如果当前的val和下一个节点的val相等的话，就让当前指针指向下一个节点；不等的话，就处理下一个节点 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode deleteDuplicates(ListNode head) { //先设置一个指针 if(head == null || head.next == null) { return head; } if(head.val == head.next.val) { head = deleteDuplicates(head.next); } else { head.next = deleteDuplicates(head.next); } return head; }} Question16:合并两个有序数组题目描述： 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 题解： 方法一：使用最简单的方式，就是把nums2中的所有的数字加到nums1中的空白处，然后对整个数组进行排序 123456public void merge(int[] nums1, int m, int[] nums2, int n) { for (int i = 0; i &lt; n; i++) { nums1[m+i] = nums2[i]; } Arrays.sort(nums1); } 方法二：利用双指针（逆向的就不用考虑后面的移位问题了） 123456789101112class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int p = m-- + n-- - 1; while(m&gt;=0 &amp;&amp; n&gt;=0) { nums1[p--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--]; } while(n &gt;= 0) { nums1[p--] = nums2[n--]; } }} Question17:二叉树的中序遍历题目描述： 实现二叉树的中序遍历 分析： 这是数据结构课上的一个很简单的例子，一定要把数组创建在方法外！ 题解： 方法一：使用递归的方法 123456789101112class Solution { List&lt;Integer&gt; res= new LinkedList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { // TreeNode cur = root; if(root != null) { inorderTraversal(root.left); res.add(root.val); inorderTraversal(root.right); } return res; }} 方法二：使用栈 主要思想就是先将当前节点压入栈内，然后遍历左边的节点并且压入栈，左侧的节点遍历完了就把栈中的数据按照顺序输出，在输出的同时还要判断这个节点有无右节点，有的话就输出。 12345678910111213141516171819class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; list= new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) { if (cur != null) { stack.push(cur); cur = cur.left; } else { cur = stack.pop(); list.add(cur.val); cur = cur.right; } } return list; }} 方法三：Morris 中序遍历详解 Question18:判断两个二叉树是否完全相同题目描述： 判断两个二叉树是否完全相同（包括结构和数据） 题解： 方法一：使用递归来解决很容易的 12345678910public boolean isSameTree(TreeNode p, TreeNode q) { if(p == null &amp;&amp; q == null) { return true; } if(p != null &amp;&amp; q != null &amp;&amp; p.val == q.val) { return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); } else { return false; } } 方法二：广度优先算法 12345678910111213141516171819202122public boolean isSameTree(TreeNode p, TreeNode q) { // 广度优先 Queue&lt;TreeNode&gt; tmpQueue = new LinkedList&lt;TreeNode&gt;(); tmpQueue.offer(p); tmpQueue.offer(q); while(!tmpQueue.isEmpty()){ p = tmpQueue.poll(); q = tmpQueue.poll(); if(p == null &amp;&amp; q == null){ continue; } if((p == null || q == null) || p.val != q.val){ return false; } tmpQueue.offer(p.left); tmpQueue.offer(q.left); tmpQueue.offer(p.right); tmpQueue.offer(q.right); } return true; } 补充：offer()表示向队列里面添加元素，并且返回true，如果队列满了就返回false Question19:判断二叉树是否为对称二叉树题目描述： 给你一个二叉树的根节点 root ， 检查它是否轴对称。 举个例子： 题解：二叉树的定义 123456789101112131415/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ 方法一：使用递归来求 1234567891011121314151617181920class Solution { public boolean isSymmetric(TreeNode root) { if(root == null) { return true; } return isEqual(root.left,root.right); } public boolean isEqual(TreeNode node1, TreeNode node2) { if(node1 == null &amp;&amp; node2 == null) { return true; } if(node1 == null || node2 == null || node1.val != node2.val) { return false; } return isEqual(node1.left,node2.right) &amp;&amp; isEqual(node1.right,node2.left); }} 方法二：使用迭代来做 12345678910111213141516171819202122232425262728class Solution { public boolean isSymmetric(TreeNode root) { //使用迭代法来求 if(root == null) { return true; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root.left); queue.offer(root.right); while(!queue.isEmpty()) { TreeNode node1 = queue.poll(); TreeNode node2 = queue.poll(); if(node1 == null &amp;&amp; node2 == null) { continue; } if(node1 == null || node2 == null || node1.val != node2.val) { return false; } queue.offer(node1.left); queue.offer(node2.right); queue.offer(node1.right); queue.offer(node2.left); } return true; } } Question20:求二叉树的最大深度题目描述： 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 题解： 解法一：递归 123public int maxDepth(TreeNode root) { return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right))+1; } 解法二：BFS(广度优先就是先把这一层判断之后再判断下一层) 123456789101112131415161718public int maxDepth(TreeNode root) { if (root == null) { return 0; } int level = 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while (!queue.isEmpty()) { int size = queue.size(); level++; for (int i = 0; i &lt; size; i++) { TreeNode node = queue.remove(); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } } return level; } 解法三：DFS(深度优先，就是先把这一个分支判断之后再判断其他分支，实时更新最大深度) 12345678910111213141516171819class Solution { int maxLevel = 0; public int maxDepth(TreeNode root) { if (root == null) { return 0; } dfs(root, 1); return maxLevel; } public void dfs(TreeNode root, int level) { if (root == null) return; if (level &gt; maxLevel) maxLevel = level; dfs(root.left, level + 1); dfs(root.right, level + 1); }} Question21:路径总和问题题目描述： 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点 注意，如果给定的二叉树为空并且targetNum=0，结果依旧是false 题解： 这是一个简单的递归的题目，我们采取逆向思维 先找叶子节点，如果此时判断的节点为叶子节点，那就看看目标值-叶子结点的值是否等于前面路径上的值之和 如果不是叶子节点，进行递归，将目标值减去当前节点的值 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if(root == null) { return false; } if(root.left == null &amp;&amp; root.right == null) { return targetSum-root.val == 0; } return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val); }} Question22:杨辉三角题目描述： 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 题解： 本题不难，就是求出一个杨辉三角形即可，个人的难点就是使用List集合的时候不够熟练，平时都是用数组来做。 1234567891011121314151617181920class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; numRows; i++) { List&lt;Integer&gt; mid = new ArrayList&lt;Integer&gt;(); for (int j = 0; j &lt;= i; j++) { if (j==0 || j==i) { mid.add(1); } else { //先获取上一行的值 List&lt;Integer&gt; up = res.get(i-1); mid.add(up.get(j-1) + up.get(j)); } } res.add(mid); } return res; }} Question23:杨辉三角Ⅱ题目描述： 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 题解： 本题和上一道题区别就在于一个返回的是全部集合，一个是返回指定行的集合。 方法一：创建出杨辉三角，然后取指定的那一行 1234567891011121314151617181920class Solution { public List&lt;Integer&gt; getRow(int rowIndex) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int i = 0; i &lt;= rowIndex; i++) { List&lt;Integer&gt; mid = new ArrayList&lt;Integer&gt;(); for (int j = 0; j &lt;= i; j++) { if (j==0 || j==i) { mid.add(1); } else { //先获取上一行的值 List&lt;Integer&gt; up = res.get(i-1); mid.add(up.get(j-1) + up.get(j)); } } res.add(mid); } return res.get(rowIndex); }} 方法二：利用杨辉三角形同行之间的关系来求 1234567891011121314/** * 获取杨辉三角的指定行 * 直接使用组合公式C(n,i) = n!/(i!*(n-i)!) * 则第(i+1)项是第i项的倍数=(n-i)/(i+1); */public List&lt;Integer&gt; getRow(int rowIndex) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(rowIndex + 1); long cur = 1; for (int i = 0; i &lt;= rowIndex; i++) { res.add((int) cur); cur = cur * (rowIndex-i)/(i+1); } return res; } 复杂度更低，优先记这个 Question24:计算最大收益题目描述： 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 题解：线性规划 12345678910111213141516class Solution { public int maxProfit(int[] prices) { int maxProfit = 0; int minPrice = Integer.MAX_VALUE; for (int i = 0; i &lt; prices.length; i++) { if (prices[i] &lt; minPrice) { minPrice = prices[i]; } if (prices[i] - minPrice &gt; maxProfit) { maxProfit = prices[i] - minPrice; } } return maxProfit; }} 分析：本题最简单的思路是，采用两次循环，来求出最大的利润，这样的作法时间复杂度太高，会超出时间范围，因此在这里不做赘述。 Question25：判断回文数题目描述： 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。 字母和数字都属于字母数字字符。 给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。 题解： 方法一： 最简单的办法就是去除所有标点和空格之后，再进行判断，注意要将所有的字符串都转换为小写的 1234567891011121314class Solution { public boolean isPalindrome(String s) { String str1 = s.replaceAll(&quot;[^0-9a-zA-Z]&quot;,&quot;&quot;); String str = str1.toLowerCase(); boolean flag = true; for(int i = 0; i &lt; str.length()/2; i++) { if(str.charAt(i) != str.charAt(str.length() - i - 1)){ flag = false; break; } } return flag; }} 方法二： 将字符串反转之后判断和源字符串是否相同 1234567891011121314class Solution { public boolean isPalindrome(String s) { StringBuffer sgood = new StringBuffer(); int length = s.length(); for (int i = 0; i &lt; length; i++) { char ch = s.charAt(i); if (Character.isLetterOrDigit(ch)) { sgood.append(Character.toLowerCase(ch)); } } StringBuffer sgood_rev = new StringBuffer(sgood).reverse(); return sgood.toString().equals(sgood_rev.toString()); }} 方法三：双指针（性能最优） 12345678910111213141516171819202122class Solution { public boolean isPalindrome(String s) { int n = s.length(); int left = 0, right = n - 1; while (left &lt; right) { while (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) { ++left; } while (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) { --right; } if (left &lt; right) { if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) { return false; } ++left; --right; } } return true; }} Question26:只出现一次的数字题目描述： 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 题解分析： 使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。 使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。 使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。 题解： 12345678910111213141516public int singleNumber(int[] nums) { //先将数组进行排序，然后加一个减一个，减去之后，如果返回的值不是0就说明找到了 Arrays.sort(nums); int res = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (i % 2 == 0) { res += nums[i]; } else { res -= nums[i]; if (res != 0) { return nums[i-1]; } } } return 0; } 方法二：位运算，最后剩下的就是最终结果、 123456789class Solution { public int singleNumber(int[] nums) { int single = 0; for (int num : nums) { single ^= num; } return single; }} Question27:判断链表中是否含有环形题目描述： 给你一个链表的头节点 head ，判断链表中是否有环。如果链表中存在环 ，则返回 true 。 否则，返回 false 。 分析： 这道题是为了判断在链表中是否含有环，可以分为下面两种思路： 利用Set中的元素不能重复这个原则，将节点加入到set中，如果返回为false，代表有环。 使用一个快指针，一个慢指针，如果有环的话，那终会有一个时刻二者相遇。 题解： 方法一： 12345678910111213public class Solution { public boolean hasCycle(ListNode head) { //首先用哈希集合的方法来做（由于哈希集不能有重复） Set&lt;ListNode&gt; set = new HashSet&lt;ListNode&gt;(); while (head != null) { if (!set.add(head)) { return true; } head = head.next; } return false; }} 方法二： 123456789101112131415161718public class Solution { public boolean hasCycle(ListNode head) { //使用第二种方法，即龟兔赛跑 if (head == null || head.next == null) { return false; } ListNode fast = head.next; ListNode slow = head; while (fast != slow) { if (fast == null || fast.next == null) { return false; } slow = slow.next; fast = fast.next.next; } return true; }} Question28:二叉树的前序遍历题目描述： 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 题解： 123456789101112131415List&lt;Integer&gt; preOrder = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) { if(root == null) { return preOrder; } preOrder.add(root.val); if(root.left != null) { preorderTraversal(root.left); } if(root.right != null) { preorderTraversal(root.right); } return preOrder; } 上面是自己做出来的解法，迭代和Mirrors解法看leetcode官方解答 Question29:实现二叉树的后序遍历题目描述: 实现二叉树的后序遍历 题解： 1234567891011121314151617181920class Solution { List&lt;Integer&gt; postOrder = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) { if(root == null) { return postOrder; } if(root.left != null) { postorderTraversal(root.left); } if(root.right != null) { postorderTraversal(root.right); } postOrder.add(root.val); return postOrder; }} Question30:获取两个链表相交的节点题目描述： 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 题解： 方法一：个人做法 1234567891011121314151617public ListNode getIntersectionNode(ListNode headA, ListNode headB) { //个人思路：先将一个链表的所有节点加入到一个Set集合之中， //再判断另一个链表中的点是否在这个集合之中即可 Set&lt;ListNode&gt; set = new HashSet&lt;&gt;(); while (headA != null) { set.add(headA); headA = headA.next; } //现在有了链表A的节点集合，判断B while (set.add(headB)) { if(headB.next == null) { return null; } headB = headB.next; } return headB; } 方法二： 首先判断两个链表是否为空，若为空，直接返回null，否则进行下一步 将一个指针指向链表A的头部，另一个指针指向链表B的头部 将两个链表向后移，如果A指针走到了最后，那么就把他再次指向链表B；同理，如果B指针指向了最后，就把它再次指向链表A；如此做来，如果有交点，那么在进行过程中总会相遇的 12345678910111213public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode pA = headA, pB = headB; while (pA != pB) { pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA; }} Question31:Excel表列名称题目描述： 题解： 这个题目坏就坏在他是从1开始的，要是从0开始就能构成26进制数，就很简单了 1234567891011121314151617181920212223class Solution { public String convertToTitle(int columnNumber) { // //记录字母的个数 // int num = 0; // for(int i = 1; i &lt; 7; i++) { // if(Math.pow(26,i)/25-26/25 &gt;= columnNumber) { // num = i-1; // break; // } // } StringBuffer sb = new StringBuffer(); //在ASCII中A对应65 while(columnNumber &gt; 0) { int mod = (columnNumber-1) % 26; char ins = (char) (mod + 65); sb.append(ins); columnNumber = (columnNumber-1) / 26; } sb.reverse(); String res = sb.toString(); return res; }} Question32:寻找数组中出现次数多的数字题目描述： 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 题解 ： 方法一： 使用最简单的方法，将数组进行排序，将排序后的数组进行判断，当前项是否等于n/2项后的那一项，如果等于就返回。 123456789101112131415class Solution { public int majorityElement(int[] nums) { //寻找数组中出现一半以上的元素 //第一种，最简单的方法 Arrays.sort(nums); int res = 0; for (int i= 0; i &lt; nums.length; i++) { if (nums[i] == nums[(nums.length+i) / 2]){ res = nums[i]; break; } } return res; }} 将上面的方法进行进一步的简化可得： 123456class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length/2]; }} 由于算法题，不建议使用已有的api，因此使用下列解答 方法二：概率化 使用概率的思想，由于寻找的数字出现的概率很大，因此我们随机抽取一个数来判断这个数是不是我们要找的数字 12345678910111213141516171819202122232425262728class Solution { private int randRange(Random rand, int min, int max) { return rand.nextInt(max - min) + min; } private int countOccurences(int[] nums, int num) { int count = 0; for (int i = 0; i &lt; nums.length; i++) { if (nums[i] == num) { count++; } } return count; } public int majorityElement(int[] nums) { Random rand = new Random(); int majorityCount = nums.length / 2; while (true) { int candidate = nums[randRange(rand, 0, nums.length)]; if (countOccurences(nums, candidate) &gt; majorityCount) { return candidate; } } }} 方法三：使用Map 12345678910111213141516171819202122232425262728class Solution { //获取数组的map集合，也就是数字-&gt;出现次数 private Map&lt;Integer,Integer&gt; getMap(int[] nums){ Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { if (!map.containsKey(nums[i])) { map.put(nums[i],1); } else { map.put(nums[i],map.get(nums[i])+1); } } return map; } public int majorityElement(int[] nums) { Map&lt;Integer, Integer&gt; map = getMap(nums); Map.Entry&lt;Integer, Integer&gt; majorityEntry = null; int res = 0; for(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet()) { if (entry.getValue() &gt; nums.length / 2) { res = entry.getKey(); break; } } return res; }} 运行结果还不如第一种方法 Question33:寻找Excel的序列号题目描述： 题解： 方法一：也就是Q31的逆过程 12345678910class Solution { public int titleToNumber(String columnTitle) { int num = columnTitle.length(); int res = 0; for (int i = 0; i &lt; num; i++) { res += (int) (columnTitle.charAt(i) - 64) * Math.pow(26,num-1-i); } return res; }} Question34:寻找1的个数题目描述： 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此,在上面的示例 3 中，输入表示有符号整数 -3。 题解： 方法一： 思路：我们可以直接循环检查给定整数 n的二进制位的每一位是否为 1。 具体代码中，当检查第 i 位时，我们可以让 n 与 2^i 进行与运算，当且仅当 n 的第 i 位为 1 时，运算结果不为 0。 123456789101112public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int count = 0; for(int i = 0; i &lt; 32; i++) { if((n &amp; (1 &lt;&lt; i)) != 0) { count++; } } return count; }} 方法二： 思路：将n与(n-1)进行运算时，会把n中的最小位置上的 1 置为 0。举例如：6 = (110) , 5 = (101).对二者进行与运算之后成为(100)，也就是把6中的第二个1置为了0。在没有变成 0 之前的计算次数就是1的个数。 1234567891011public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int res = 0; while(n != 0) { n &amp;= (n-1); res++; } return res; }} 不用一个一个判断，运算速度更快。 Question35:判断一个数是不是快乐数题目描述： 编写一个算法来判断一个数 n 是不是快乐数。 快乐数定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 题解： 方法一： 使用一个较大的循环次数来判断他是不是快乐数 12345678910111213141516class Solution { public boolean isHappy(int n) { for (int i = 0; i &lt; 100; i++) { int ans = 0; while (n &gt; 0) { ans += (n%10) * (n%10); n /= 10; } n = ans; if (n == 1) { return true; } } return false; }} 方法二： 对一个数字进行题目描述的过程，最终会有三种结果出现： 最终会得到 11。 最终会进入循环。 值会越来越大，最后接近无穷大 因此这里我们先采取哈希集合来存放出现过的数字，如果重复出现了，就代表它不是一个快乐数 1234567891011121314151617181920class Solution { private int getNext(int n) { int totalSum = 0; while (n &gt; 0) { int d = n % 10; n = n / 10; totalSum += d * d; } return totalSum; } public boolean isHappy(int n) { Set&lt;Integer&gt; seen = new HashSet&lt;&gt;(); while (n != 1 &amp;&amp; !seen.contains(n)) { seen.add(n); n = getNext(n); } return n == 1; }} 方法三： 之前使用过的快慢指针法（判断是否存在环形的时候使用过） 12345678910111213141516171819202122class Solution { public int getNext(int n) { int totalSum = 0; while (n &gt; 0) { int d = n % 10; n = n / 10; totalSum += d * d; } return totalSum; } public boolean isHappy(int n) { int slowRunner = n; int fastRunner = getNext(n); while (fastRunner != 1 &amp;&amp; slowRunner != fastRunner) { slowRunner = getNext(slowRunner); fastRunner = getNext(getNext(fastRunner)); } return fastRunner == 1; }} Question36:判断两个字符串是不是同构字符串题目描述： 给定两个字符串 s 和 t ，判断它们是否是同构的。 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。 例如add和egg就是同构字符串 题解： 方法一： 创建一个HashMap，存放s的第i个字符 - t的第i个字符 加入的时候进行判断，如果map的key中存在当前字符，那么value也会存在当前字符 再判断前一个位置是不是也是这一对 123456789101112131415161718192021222324class Solution { public boolean isIsomorphic(String s, String t) { if (s.length() != t.length()) { return false; } HashMap&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); //构建s-t的hashmap，再进行判断 for (int i = 0; i &lt; s.length(); i++) { if (!map.containsKey(s.charAt(i))){ if (map.containsValue(t.charAt(i))) { return false; } map.put(s.charAt(i),t.charAt(i)); } else { if (map.get(s.charAt(i)) != t.charAt(i)) { return false; } } } return true; }} Question37:对链表进行反转题目描述： 根据给定链表的头节点，对链表进行反转 题解： 方法一：迭代 创建一个新的反转链表 对原有的链表从头到尾进行遍历，对当前取出的节点加入到新的反转链表最前面，即可实现反转 12345678910111213141516171819class Solution { public ListNode reverseList(ListNode head) { if (head == null) { return null; } //创建一个新的链表，然后遍历链表，将每一次遍历到的节点 //加入到新链表的头部 ListNode reverseNode = new ListNode(-1); ListNode cur = head;//这是辅助节点，用来遍历链表 ListNode next = null;//表示下一个节点 while (cur != null) { next = cur.next; cur.next = reverseNode.next; reverseNode.next = cur; cur = next; } return reverseNode.next; }} 方法二：递归 12345678910111213141516171819202122232425262728293031323334353637383940/** * 以链表1-&gt;2-&gt;3-&gt;4-&gt;5举例 * @param head * @return */ public ListNode reverseList(ListNode head) { if (head == null || head.next == null) { /* 直到当前节点的下一个节点为空时返回当前节点 由于5没有下一个节点了，所以此处返回节点5 */ return head; } //递归传入下一个节点，目的是为了到达最后一个节点 ListNode newHead = reverseList(head.next); /* 第一轮出栈，head为5，head.next为空，返回5 第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4， 把当前节点的子节点的子节点指向当前节点 此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null 此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5 返回节点5 第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3， 此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null 此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5 返回节点5 第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2， 此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2.next=null 此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5 返回节点5 第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1， 此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null 此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5 返回节点5 出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1 */ head.next.next = head; head.next = null; return newHead; } Question38:判断数组是否存在重复元素题目描述： 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 题解： 方法一： 将所有的元素进行排序，然后看相邻的元素是否相等，相等就返回true，否则返回false 123456789101112class Solution { public boolean containsDuplicate(int[] nums) { Arrays.sort(nums); int n = nums.length; for (int i = 0; i &lt; n - 1; i++) { if (nums[i] == nums[i + 1]) { return true; } } return false; }} 方法二： 将元素加入到HashSet之中，然后遍历数组，如果set中已有就返回true，反之则为false 12345678910111213141516public boolean containsDuplicate(int[] nums) { if (nums.length == 0 || nums.length == 1) { return false; } //先创建一个set HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { if (set.contains(nums[i])) { return true; } set.add(nums[i]); } return false; } Question39:判断存在重复元素Ⅱ题目描述： 给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &lt;= k 。如果存在，返回 true ；否则，返回 false 。 题解： 方法一： 创建一个HashMap，构建nums[i] &lt;-&gt; i 的一个map 当有重复数字出现的时候，来判断一下，二者之间的距离是否小于等于k 如果不是，那么就用现在的这个这个下标代替之前的键值对 123456789101112131415161718class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { if (nums.length == 0 || nums.length == 1 || k == 0) { return false; } //先创建一个HashMap HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { if (map.containsKey(nums[i])) { if (Math.abs(map.get(nums[i])-i) &lt;= k) { return true; } } map.put(nums[i],i); } return false; }} 方法二：使用滑动窗口 考虑数组nums 中的每个长度不超过 k + 1 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过 k。如果存在一个滑动窗口，其中有重复元素，则返回true；如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可。 123456789101112131415class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int length = nums.length; for (int i = 0; i &lt; length; i++) { if (i &gt; k) { set.remove(nums[i - k - 1]); } if (!set.add(nums[i])) { return true; } } return false; }} Question40:使用队列完成栈题目描述： 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 题解： 方法一：双队列 大致思路： 创建两个队列，queue1是栈，queue2是辅助队列 在添加元素的时候，先将元素加入到queue2队列之中，再把queue1中的元素按照顺序加入到queue2中，这个时候queue2就实现了后入先出 再将queue1和queue2交换即可 其余操作均对queue1进行即可 123456789101112131415161718192021222324252627282930Queue&lt;Integer&gt; queue1; Queue&lt;Integer&gt; queue2; public MyStack() { queue1 = new LinkedList&lt;Integer&gt;(); queue2 = new LinkedList&lt;Integer&gt;(); } public void push(int x) { //采用双队列 queue2.offer(x); while(!queue1.isEmpty()){ queue2.offer(queue1.poll()); } Queue&lt;Integer&gt; temp = queue1; queue1 = queue2; queue2 = temp; } public int pop() { return queue1.poll(); } public int top() { return queue1.peek(); } public boolean empty() { return queue1.isEmpty(); } 方法二：单队列 大致思路： 创建一个队列 在添加元素的时候，先将现有元素的个数n获取到，然后将元素加入到队列中，再将前n个元素依次加到队列的尾部即可 其余操作均对queue执行即可 1234567891011121314151617181920212223242526//使用单队列完成 Queue&lt;Integer&gt; queue; public MyStack() { queue = new LinkedList&lt;Integer&gt;(); } public void push(int x) { int size = queue.size(); queue.offer(x); for(int i = 0; i &lt; size; i++) { queue.offer(queue.poll()); } } public int pop() { return queue.poll(); } public int top() { return queue.peek(); } public boolean empty() { return queue.isEmpty(); } Question41:使用栈实现队列题目描述： 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 题解： 注意这个题目和上一个题目的区别，上个题目是对输入操作进行处理，这个是对输出进行处理 1234567891011121314151617181920212223242526272829303132333435363738class MyQueue { //使用栈实现队列，也就是后入先出转换为先入先出 //使用双栈的方式 private Stack&lt;Integer&gt; stack1; private Stack&lt;Integer&gt; stack2; public MyQueue() { stack1 = new Stack&lt;&gt;(); stack2 = new Stack&lt;&gt;(); } public void push(int x) { stack1.push(x); } public int pop() { if(stack2.isEmpty()) { while(!stack1.isEmpty()) { stack2.push(stack1.pop()); } } return stack2.pop(); } public int peek() { if(stack2.isEmpty()) { while(!stack1.isEmpty()) { stack2.push(stack1.pop()); } } return stack2.peek(); } public boolean empty() { return stack1.isEmpty() &amp;&amp; stack2.isEmpty(); }} Question42:实现二叉树的反转题目描述： 题解： 方法一：递归 这里要注意一下，使用递归的时候，一般采用设置一个新函数，然后调用这个函数即可 12345678910111213141516171819202122232425class Solution { public TreeNode invertTree(TreeNode root) { //递归实现 if(root == null) return root; inverse(root); return root; } public void inverse(TreeNode node) { if(node == null) { return; } TreeNode temp = node.left; node.left = node.right; node.right = temp; inverse(node.left); inverse(node.right); }} Question43:给数组元素划分区间题目描述： 给定一个 无重复元素 的 有序 整数数组 nums 。 返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。 列表中的每个区间范围 [a,b] 应该按如下格式输出： “a-&gt;b” ，如果 a != b“a” ，如果 a == b 举例： 题解： 设置双指针，如果值相等，输出一个数字，否则输出指定形式 12345678910111213141516171819202122class Solution { public List&lt;String&gt; summaryRanges(int[] nums) { List&lt;String&gt; ret = new ArrayList&lt;String&gt;(); int i = 0; int n = nums.length; while (i &lt; n) { int low = i; i++; while (i &lt; n &amp;&amp; nums[i] == nums[i - 1] + 1) { i++; } int high = i - 1; StringBuffer temp = new StringBuffer(Integer.toString(nums[low])); if (low &lt; high) { temp.append(&quot;-&gt;&quot;); temp.append(Integer.toString(nums[high])); } ret.add(temp.toString()); } return ret; }} Question44:判断一个数是不是2的幂次题目描述： 输入一个数，判断这个数是不是2的幂次 题解： 首先要注意，负数和0都不是2的幂次 方法一： 12345class Solution { public boolean isPowerOfTwo(int n) { return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0; }} 根据二进制数可以知道，如果一个数为2的幂次，那么这个数的二进制一定只有一个1，因此将n和(n-1)做与运算所得结果一定是0. 方法二： 12345class Solution { public boolean isPowerOfTwo(int n) { return n &gt; 0 &amp;&amp; (n &amp; -n) == n; }} 在计算机系统之中，负数是根据补码来保存的，因此通过n和-n的与运算也可以判断这个数是不是2的幂次。 方法三：个人做法 123456789101112131415class Solution { public boolean isPowerOfTwo(int n) { if(n==0 || n &lt; 0) { return false; } while(n &gt; 1) { if(n % 2 == 1){ return false; } n /= 2; } return true; }} Question45:设计Goal解析器题目描述： 请你设计一个可以解释字符串 command 的 Goal 解析器 。command 由 “G”、”()” 和/或 “(al)” 按某种顺序组成。Goal 解析器会将 “G” 解释为字符串 “G”、”()” 解释为字符串 “o” ，”(al)” 解释为字符串 “al” 。然后，按原顺序将经解释得到的字符串连接成一个字符串。 给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。 题解： 方法一： 采用判断子字符串的方法，分别讨论出现三种情况下的结果。 12345678910111213141516171819class Solution { public String interpret(String command) { StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; command.length(); i++) { if (command.substring(i,i+1).equals(&quot;G&quot;)){ sb.append(&quot;G&quot;); } else if (command.substring(i,i+2).equals(&quot;()&quot;)){ sb.append(&quot;o&quot;); i++; } else { sb.append(&quot;al&quot;); i+=3; } } String res = sb.toString(); return res; }} 方法二： 代码简洁，但是时间复杂度和空间复杂度都不好 1return command.replace(&quot;()&quot;,&quot;o&quot;).replace(&quot;(al)&quot;,&quot;al&quot;) Question46:判断回文链表题目描述： 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 题解： 方法一： 要实现O(n)的时间复杂度和O(1)的空间复杂度，就需要反转后半部分来做 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution { public boolean isPalindrome(ListNode head) { //要实现O(n)的时间复杂度和O(1)的空间复杂度，就需要反转后半部分来做 if(head == null || head.next == null) { return true; } ListNode fast = head; ListNode slow = head; //利用快慢指针，来找到中间节点 while(fast.next != null &amp;&amp; fast.next.next != null) { fast = fast.next.next; slow = slow.next; } //反转后半部分链表 slow = reverse(slow.next); while(slow != null) { if(head.val != slow.val) { return false; } head = head.next; slow = slow.next; } return true; } /** 反转的方法（迭代法） */ private ListNode reverse(ListNode head) { ListNode pre = null; ListNode next = null; while(head != null) { next = head.next; head.next = pre; pre = head; head = next; } return pre; } /** 反转的方式（递归） */ private ListNode reverse1(ListNode head){ // 递归到最后一个节点，返回新的新的头结点 if (head.next == null) { return head; } ListNode newHead = reverse(head.next); head.next.next = head; head.next = null; return newHead; } } 注意反转的操作 Question47:有效的字母异位词题目描述： 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 题解： 方法一：个人做法 把两个字符串中的字符出现的次数放入到两个map之中，然后比较这两个map是否相同即可。 1234567891011121314151617181920212223public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } //使用两个map来保存两个字符串分别出现的次数 Map&lt;Character,Integer&gt; map1 = new HashMap&lt;&gt;(); Map&lt;Character,Integer&gt; map2 = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { if (!map1.containsKey(s.charAt(i))) { map1.put(s.charAt(i), 1); } else{ map1.put(s.charAt(i),map1.get(s.charAt(i))+1); } if (!map2.containsKey(t.charAt(i))) { map2.put(t.charAt(i), 1); } else{ map2.put(t.charAt(i),map2.get(t.charAt(i))+1); } } return map1.equals(map2); } 方法二： 将两个字符串进行排序，比较排序之后的字符串是否相同即可 123456789101112class Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } char[] str1 = s.toCharArray(); char[] str2 = t.toCharArray(); Arrays.sort(str1); Arrays.sort(str2); return Arrays.equals(str1, str2); }} 方法三：哈希表 从另一个角度考虑，t 是 s 的异位词等价于两个字符串中字符出现的种类和次数均相等。由于字符串只包含 26 个小写字母，因此我们可以维护一个长度为 26 的频次数组table，先遍历记录字符串 s 中字符出现的频次，然后遍历字符串 t，减去table 中对应的频次，如果出现table[i]&lt;0，则说明 t 包含一个不在 s 中的额外字符，返回false 。 123456789101112131415161718class Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } int[] table = new int[26]; for (int i = 0; i &lt; s.length(); i++) { table[s.charAt(i) - 'a']++; } for (int i = 0; i &lt; t.length(); i++) { table[t.charAt(i) - 'a']--; if (table[t.charAt(i) - 'a'] &lt; 0) { return false; } } return true; }} Question48:各位相加题目描述： 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。 举个例子： 123456输入: num = 38输出: 2 解释: 各位相加的过程为：38 --&gt; 3 + 8 --&gt; 1111 --&gt; 1 + 1 --&gt; 2由于 2 是一位数，所以返回 2。 题解： 方法一： 思路最简单的方法，就是利用迭代，一直对数字进行处理，直到数字为个位数 12345678910111213class Solution { public int addDigits(int num) { while (num &gt;= 10) { int sum = 0; while (num &gt; 0) { sum += num % 10; num /= 10; } num = sum; } return num; }} 方法二： 利用数根的思想 12345class Solution { public int addDigits(int num) { return (num - 1) % 9 + 1; }} Question49:丑数题目描述： 丑数 就是只包含质因数 2、3 和 5 的正整数。 给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。 题解： 1234567891011121314class Solution { public boolean isUgly(int n) { if(n &lt;= 0) { return false; } int[] factors = {2,3,5}; for(int factor : factors) { while(n % factor == 0) { n /= factor; } } return n==1; }} Question50:丢失的数字题目描述： 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 题解： 方法一： 将数组进行排序 遍历排序后的数组，看nums[i] 和 i是否相等 如果不相等，就代表i缺失 如果遍历的结果发现都相等，那么缺失的就是最后一个数字，返回n即可 123456789101112class Solution { public int missingNumber(int[] nums) { Arrays.sort(nums); int n = nums.length; for (int i = 0; i &lt; n; i++) { if (nums[i] != i) { return i; } } return n; }} 方法二：哈希表 1234567891011121314151617class Solution { public int missingNumber(int[] nums) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int n = nums.length; for (int i = 0; i &lt; n; i++) { set.add(nums[i]); } int missing = -1; for (int i = 0; i &lt;= n; i++) { if (!set.contains(i)) { missing = i; break; } } return missing; }} 方法三：位运算 12345678910111213class Solution { public int missingNumber(int[] nums) { int xor = 0; int n = nums.length; for (int i = 0; i &lt; n; i++) { xor ^= nums[i]; } for (int i = 0; i &lt;= n; i++) { xor ^= i; } return xor; }} 方法四：数学计算 1234567891011class Solution { public int missingNumber(int[] nums) { int n = nums.length; int total = n * (n + 1) / 2; int arrSum = 0; for (int i = 0; i &lt; n; i++) { arrSum += nums[i]; } return total - arrSum; }} Question51:统计一致字符串的数目题目描述： 给你一个由不同字符组成的字符串 allowed 和一个字符串数组 words 。如果一个字符串的每一个字符都在 allowed 中，就称这个字符串是 一致字符串 。 请你返回 words 数组中 一致字符串的数目。 举例子： 题解： 方法一： 个人做法： 对allowed字符串进行遍历，取出每一个字符放到一个Set集合之中 然后对word进行遍历，只要有一个字符不在allowed之中，就返回false 否则，执行count++ 1234567891011121314151617181920212223class Solution { public int countConsistentStrings(String allowed, String[] words) { //先将allowed中的每一个字符都取出放入一个set集合之中 HashSet&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; allowed.length(); i++) { set.add(allowed.charAt(i)); } int count = 0; for (int i = 0; i &lt; words.length; i++) { boolean flag = true; for (int j = 0; j &lt; words[i].length(); j++) { if (!set.contains(words[i].charAt(j))){ flag = false; break; } } if (flag) { count++; } } return count; } Question52:第一个错误版本题目描述： 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 题解： 题目思路很简单，就是利用二分查找法就可以了，不断循环为right赋值即可 注意：二分法要采用left + (right-left)/2的方式，不然就超界限了 123456789101112131415161718192021/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl { public int firstBadVersion(int n) { //简单的二分查找算法 int left = 1; int right = n; int res = 0; while(left &lt;= right) { int mid = left + (right - left) / 2; if(isBadVersion(mid)) { res = mid; right = mid - 1; }else{ left = mid + 1; } } return res; }} Question53:移动零题目描述： 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 题解： 方法一：遍历 个人思路很简单 首先先遍历数组，在遇到0的时候停下来 找0后面的第一个不是0的数据 将这两个数据做交换即可 123456789101112131415161718class Solution { public void moveZeroes(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { if (nums[i] == 0) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[j] != 0) { nums[i] = nums[j]; nums[j] = 0; break; } } } if (nums[i] == 0) { break; } } }} 方法二：二次遍历 比刚刚的算法要好的 12345678910111213141516171819class Solution { public void moveZeroes(int[] nums) { if(nums==null) { return; } //第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j] int j = 0; for(int i=0;i&lt;nums.length;++i) { if(nums[i]!=0) { nums[j++] = nums[i]; } } //非0元素统计完了，剩下的都是0了 //所以第二次遍历把末尾的元素都赋为0即可 for(int i=j;i&lt;nums.length;++i) { nums[i] = 0; } }} Question54:单词规律题目描述： 给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。 举例： 题解： 方法一： 个人解法： 首先将整个字符串分割成一个一个的单词 创建一个hashmap，里面存储character-string键值对 有两种情况会出现false 一是不含key，但是含有value；一种是不匹配 1234567891011121314151617181920212223class Solution { public boolean wordPattern(String pattern, String s) { //个人思路是利用HashMap来进行判断 String[] strings = s.split(&quot; &quot;); if (pattern.length() != strings.length) { return false; } HashMap&lt;Character, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; pattern.length(); i++) { if (!map.containsKey(pattern.charAt(i))) { if (map.containsValue(strings[i])) { return false; } } else if(map.containsKey(pattern.charAt(i))) { if (!map.get(pattern.charAt(i)).equals(strings[i])) { return false; } } map.put(pattern.charAt(i),strings[i]); } return true; }} 方法二：双表 思路是创建两个hashmap来判断对应关系 降低了时间复杂度，运行性能更好 1234567891011121314151617181920212223242526272829class Solution { public boolean wordPattern(String pattern, String str) { Map&lt;String, Character&gt; str2ch = new HashMap&lt;String, Character&gt;(); Map&lt;Character, String&gt; ch2str = new HashMap&lt;Character, String&gt;(); int m = str.length(); int i = 0; for (int p = 0; p &lt; pattern.length(); ++p) { char ch = pattern.charAt(p); if (i &gt;= m) { return false; } int j = i; while (j &lt; m &amp;&amp; str.charAt(j) != ' ') { j++; } String tmp = str.substring(i, j); if (str2ch.containsKey(tmp) &amp;&amp; str2ch.get(tmp) != ch) { return false; } if (ch2str.containsKey(ch) &amp;&amp; !tmp.equals(ch2str.get(ch))) { return false; } str2ch.put(tmp, ch); ch2str.put(ch, tmp); i = j + 1; } return i &gt;= m; }} Question55:Nim游戏题目描述： 题解： 分析：这个题目涉及到数学问题，如果场上只有四个的话，那么你拿多少个对方都会赢；如果大于四个的话，你就可以拿走n个，使得场上始终是4的倍数，这样的话你就总是会赢。 12345class Solution { public boolean canWinNim(int n) { return n % 4 != 0; }} Question56:区域和检索–数组不可变题目描述： 给定一个整数数组 nums，处理以下类型的多个查询: 计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;= right实现 NumArray 类： NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + … + nums[right] ) 题解： 方法一：前缀法 避免了每一次都要循环计算的笨蛋方法 123456789101112131415161718192021222324252627282930class NumArray { private int[] sums; public NumArray(int[] nums) { sums = new int[nums.length]; if(nums.length == 0) { return; } sums[0] = nums[0]; for(int i = 1; i &lt; nums.length; i++) { sums[i] = sums[i-1] + nums[i]; } } public int sumRange(int left, int right) { if(left == 0) { return sums[right]; }else { return sums[right] - sums[left-1]; } }}/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ Question57:判断数字是否为3的幂次题目描述： 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。 题解： 方法一： 整体思路就是最简单的判断，一直取模，结果为0的话就一直除以3 12345678class Solution { public boolean isPowerOfThree(int n) { while (n != 0 &amp;&amp; n % 3 == 0) { n /= 3; } return n == 1; }} 方法二： 奇技淫巧：用整数范围内的最大整数对这个数取模，如果结果为0，就代表这个数为3的幂次。 12345class Solution { public boolean isPowerOfThree(int n) { return n &gt; 0 &amp;&amp; 1162261467 % n == 0; }} Question58:比特位计数题目描述： 给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。 题解： 方法一： 直接计算其中的每一个数字的1的位数，然后进行返回 123456789101112131415161718192021class Solution { private int[] nums; public int[] countBits(int n) { nums = new int[n+1]; for (int i = 0; i &lt;= n; i++) { nums[i] = countOnes(i); } return nums; } public int countOnes(int x) { int count = 0; while (x &gt; 0) { x &amp;= x-1; count++; } return count; }} 方法二：最高有效位 举个例子就是，如果当前要判断的数字是7，7的二进制为111，他比(7-4)=3的二进制11只多了一个1，所以3的1的个数+1就是7的二进制中的1的个数。 12345678910111213class Solution { public int[] countBits(int n) { int[] bits = new int[n + 1]; int highBit = 0; for (int i = 1; i &lt;= n; i++) { if ((i &amp; (i - 1)) == 0) { highBit = i; } bits[i] = bits[i - highBit] + 1; } return bits; }} 方法三：最低有效位 123456789class Solution { public int[] countBits(int n) { int[] bits = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1); } return bits; }} 方法四：最低设置位 123456789class Solution { public int[] countBits(int n) { int[] bits = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { bits[i] = bits[i &amp; (i - 1)] + 1; } return bits; }} Question59:判断数字是否为4的幂次题目描述： 判断一个数字是不是4的幂次。 题解： 方法一：迭代法 1234567891011121314class Solution { public boolean isPowerOfFour(int n) { while(n&gt;1) { if(n % 4 != 0) { return false; } n /= 4; } if(n == 1) { return true; } return false; }} 方法二：数学法 一个数如果是4的幂次，那么n%3的值为1；并且一定是2的幂次 如果一个数是2的幂次而不是4的幂次，那么n%3的值为2，因此根据上述的两个条件就可以判断这个数是否为4的幂次 123456class Solution {public: bool isPowerOfFour(int n) { return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0 &amp;&amp; n % 3 == 1; }}; Question60:反转字符串题目描述： 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 举例： 题解： 方法一：单指针 个人做法 123456789class Solution { public void reverseString(char[] s) { int n = s.length; for(int i = 0; i &lt; n/2; i++) { char temp = s[i]; s[i] = s[n-1-i]; s[n-1-i] = temp; } } 方法二：双指针 12345678910class Solution { public void reverseString(char[] s) { int n = s.length; for (int left = 0, right = n - 1; left &lt; right; ++left, --right) { char tmp = s[left]; s[left] = s[right]; s[right] = tmp; } }} 没啥可说的，很简单的题目 Question61:判断字符串的两半是否相似题目描述： 给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。 两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。 如果 a 和 b 相似，返回 true ；否则，返回 false 。 题解： 方法一： 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public boolean halvesAreAlike(String s) { int left = 0; int right = s.length() - 1; int count = 0; while(left &lt; right) { if(s.charAt(left) == 'a' || s.charAt(left) == 'e' || s.charAt(left) == 'i' || s.charAt(left) == 'o' || s.charAt(left) == 'u' || s.charAt(left) == 'A' || s.charAt(left) == 'E' || s.charAt(left) == 'I' || s.charAt(left) == 'O' || s.charAt(left) == 'U' ){ count++; } if(s.charAt(right) == 'a' || s.charAt(right) == 'e' || s.charAt(right) == 'i' || s.charAt(right) == 'o' || s.charAt(right) == 'u' || s.charAt(right) == 'A' || s.charAt(right) == 'E' || s.charAt(right) == 'I' || s.charAt(right) == 'O' || s.charAt(right) == 'U' ){ count--; } left++; right--; } if(count == 0) { return true; } return false; }} 这样写代码的可读性容易，但是运行性能也很差 方法二：官方解答 12345678910111213141516171819class Solution { public boolean halvesAreAlike(String s) { String a = s.substring(0, s.length() / 2); String b = s.substring(s.length() / 2); String h = &quot;aeiouAEIOU&quot;; int sum1 = 0, sum2 = 0; for (int i = 0; i &lt; a.length(); i++) { if (h.indexOf(a.charAt(i)) &gt;= 0) { sum1++; } } for (int i = 0; i &lt; b.length(); i++) { if (h.indexOf(b.charAt(i)) &gt;= 0) { sum2++; } } return sum1 == sum2; }} 代码易理解并且运行性能好于第一种方法 方法三： 12345678910111213141516171819202122class Solution { public boolean halvesAreAlike(String s) { int left = 0; int right = s.length() - 1; int count = 0; String h = &quot;aeiouAEIOU&quot;; while(left &lt; right) { if(h.indexOf(s.charAt(left)) &gt;= 0){ count++; } if(h.indexOf(s.charAt(right)) &gt;= 0){ count--; } left++; right--; } if(count == 0) { return true; } return false; }} 借鉴官方答案之后修改的方法一，运行性能最优 Question62:反转字符串中的元音字母题目描述： 给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。 元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现。 题解： 方法一： 123456789101112131415161718192021222324252627class Solution { public String reverseVowels(String s) { int left = 0; int right = s.length() - 1; char temp; String h = &quot;aeiouAEIOU&quot;; char[] str = s.toCharArray(); while(left &lt; right) { if(h.indexOf(s.charAt(left)) &gt;= 0 &amp;&amp; h.indexOf(s.charAt(right)) &gt;= 0) { temp = str[left]; str[left] = str[right]; str[right] = temp; left++; right--; }else if(h.indexOf(s.charAt(left)) &gt;= 0) { right--; }else if(h.indexOf(s.charAt(right)) &gt;= 0) { left++; }else { left++; right--; } } return new String(str); }} Question63:求两个数组的交集题目描述： 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 题解： 方法一： 12345678910111213141516171819202122232425262728293031class Solution { public int[] intersection(int[] nums1, int[] nums2) { Set&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;(); for (int num : nums1) { set1.add(num); } for (int num : nums2) { set2.add(num); } return getIntersection(set1, set2); } public int[] getIntersection(Set&lt;Integer&gt; set1, Set&lt;Integer&gt; set2) { if (set1.size() &gt; set2.size()) { return getIntersection(set2, set1); } Set&lt;Integer&gt; intersectionSet = new HashSet&lt;Integer&gt;(); for (int num : set1) { if (set2.contains(num)) { intersectionSet.add(num); } } int[] intersection = new int[intersectionSet.size()]; int index = 0; for (int num : intersectionSet) { intersection[index++] = num; } return intersection; }} 性能一般 方法二： 对数组进行排序之后再进行判断 1234567891011121314151617181920212223242526class Solution { public int[] intersection(int[] nums1, int[] nums2) { Arrays.sort(nums1); Arrays.sort(nums2); int length1 = nums1.length, length2 = nums2.length; int[] intersection = new int[length1 + length2]; int index = 0, index1 = 0, index2 = 0; while (index1 &lt; length1 &amp;&amp; index2 &lt; length2) { int num1 = nums1[index1], num2 = nums2[index2]; if (num1 == num2) { // 保证加入元素的唯一性 if (index == 0 || num1 != intersection[index - 1]) { intersection[index++] = num1; } index1++; index2++; } else if (num1 &lt; num2) { index1++; } else { index2++; } } return Arrays.copyOfRange(intersection, 0, index); }} Question64:将有序数组转化为二叉平衡树题目描述： 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高度平衡二叉树是一棵满足每个节点的左右两个子树的高度差的绝对值不超过 1 的二叉树。 题解： 方法一： 12345678910111213141516class Solution { public TreeNode sortedArrayToBST(int[] nums) { return nums == null ? null : buildTree(nums,0,nums.length-1); } private TreeNode buildTree(int[] nums, int left, int right) { if(left &gt; right) { return null; } int mid = left + (right - left) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = buildTree(nums,left,mid-1); root.right = buildTree(nums,mid+1,right); return root; }} Question65:判断二叉树是否为平衡二叉树题目描述： 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 题解： 方法一：由上到下递归判断 思路：就是从根节点开始向下递归判断当前节点的左子树和右子树是否满足平衡树的条件 1234567891011121314151617class Solution { public boolean isBalanced(TreeNode root) { if (root == null) { return true; } else { return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); } } public int height(TreeNode root) { if (root == null) { return 0; } else { return Math.max(height(root.left), height(root.right)) + 1; } }} 方法二：从下到上的判断 123456789101112131415161718class Solution { public boolean isBalanced(TreeNode root) { return height(root) &gt;= 0; } public int height(TreeNode root) { if (root == null) { return 0; } int leftHeight = height(root.left); int rightHeight = height(root.right); if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) { return -1; } else { return Math.max(leftHeight, rightHeight) + 1; } }} 如果子树为不平衡的，那么整个树也一定是不平衡的 空间复杂度不变的情况下，将时间复杂度减少了。从O(n*n)–&gt;O(n) Question66:求二叉树的最小深度题目描述： 求一个二叉树的最小深度 题解： 方法一： 和之前求最大深度一样（Q20），只不过把max改成min即可 123456789101112131415161718 /** 执行用时：12 ms, 在所有 Java 提交中击败了10.41%的用户内存消耗：61.5 MB, 在所有 Java 提交中击败了17.58%的用户 */class Solution { public int minDepth(TreeNode root) { if(root == null) { return 0; } if(root.left != null &amp;&amp; root.right == null) { return 1 + minDepth(root.left); } if(root.left == null &amp;&amp; root.right != null) { return 1 + minDepth(root.right); } return 1+Math.min(minDepth(root.left),minDepth(root.right)); }} 方法二：深度优先算法 12345678910111213141516171819202122232425/**执行用时：6 ms, 在所有 Java 提交中击败了67.72%的用户内存消耗：61 MB, 在所有 Java 提交中击败了56.08%的用户 */ class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } if (root.left == null &amp;&amp; root.right == null) { return 1; } int min_depth = Integer.MAX_VALUE; if (root.left != null) { min_depth = Math.min(minDepth(root.left), min_depth); } if (root.right != null) { min_depth = Math.min(minDepth(root.right), min_depth); } return min_depth + 1; }} 方法三：广度优先算法 思想就是，我们在找到一个叶子结点的时候，就把这个节点的深度返回，这样就保证了最先搜索到的叶子结点的深度最小。 12345678910111213141516171819202122232425262728293031323334353637383940/** 执行用时：1 ms, 在所有 Java 提交中击败了92.98%的用户内存消耗：60.3 MB, 在所有 Java 提交中击败了89.46%的用户*/class Solution { class QueueNode { TreeNode node; int depth; public QueueNode(TreeNode node, int depth) { this.node = node; this.depth = depth; } } public int minDepth(TreeNode root) { if (root == null) { return 0; } Queue&lt;QueueNode&gt; queue = new LinkedList&lt;QueueNode&gt;(); queue.offer(new QueueNode(root, 1)); while (!queue.isEmpty()) { QueueNode nodeDepth = queue.poll(); TreeNode node = nodeDepth.node; int depth = nodeDepth.depth; if (node.left == null &amp;&amp; node.right == null) { return depth; } if (node.left != null) { queue.offer(new QueueNode(node.left, depth + 1)); } if (node.right != null) { queue.offer(new QueueNode(node.right, depth + 1)); } } return 0; }} Question67:二叉树的所有路径题目描述： 题解： 方法一：深度优先算法 123456789101112131415161718192021222324252627/**执行用时：8 ms, 在所有 Java 提交中击败了32.05%的用户内存消耗：41.9 MB, 在所有 Java 提交中击败了23.43%的用户*/public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (root == null) { return res; } addList(root,&quot;&quot;,res); return res; } public void addList(TreeNode root, String str, List&lt;String&gt; list) { if (root == null) { return; } str += root.val; //遍历到叶子节点的时候 if (root.left == null &amp;&amp; root.right == null) { list.add(str); } else { str += &quot;-&gt;&quot;; addList(root.left, str , list); addList(root.right, str , list); } } 方法二：广度优先算法 123456789101112131415161718192021222324252627282930313233class Solution { public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; paths = new ArrayList&lt;String&gt;(); if (root == null) { return paths; } Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;TreeNode&gt;(); Queue&lt;String&gt; pathQueue = new LinkedList&lt;String&gt;(); nodeQueue.offer(root); pathQueue.offer(Integer.toString(root.val)); while (!nodeQueue.isEmpty()) { TreeNode node = nodeQueue.poll(); String path = pathQueue.poll(); if (node.left == null &amp;&amp; node.right == null) { paths.add(path); } else { if (node.left != null) { nodeQueue.offer(node.left); pathQueue.offer(new StringBuffer(path).append(&quot;-&gt;&quot;).append(node.left.val).toString()); } if (node.right != null) { nodeQueue.offer(node.right); pathQueue.offer(new StringBuffer(path).append(&quot;-&gt;&quot;).append(node.right.val).toString()); } } } return paths; }} Question68:两个数组的交集题目描述： 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 题解： 一共有三种方法放在一起介绍了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 使用集合来实现 * 执行用时：10 ms, 在所有 Java 提交中击败了5.09%的用户 * 内存消耗：41.3 MB, 在所有 Java 提交中击败了85.25%的用户 */ public int[] intersect_1(int[] nums1, int[] nums2) { List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); for (int num1 : nums1) { list1.add(num1); } List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); for (int num2 : nums2) { if (list1.contains(num2)) { list2.add(num2); list1.remove(Integer.valueOf(num2)); } } int[] res = new int[list2.size()]; int i = 0; for (int value : list2) { res[i++] = value; } return res; } /** * 使用map实现 * 执行用时：3 ms, 在所有 Java 提交中击败了40.89%的用户 * 内存消耗：41.7 MB, 在所有 Java 提交中击败了32.18%的用户 */ public int[] intersect_2(int[] nums1, int[] nums2) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //将nums1的元素放入到map之中 for (int value : nums1) { if (map.containsKey(value)) { map.put(value, map.get(value)+1); } else { map.put(value,1); } } //逐个取出nums2之中的元素，来判断是否位于map中，如果位于map之中， // 那么就将他加到list之中，并且要将这个值的次数减一 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int value : nums2) { if (map.containsKey(value)) { list.add(value); map.put(value,map.get(value)-1); } } int[] res = new int[list.size()]; int i = 0; for (int value : list) { res[i++] = value; } return res; } /** * 使用预排序的方法 * 执行用时：2 ms, 在所有 Java 提交中击败了95.48%的用户 * 内存消耗：41.5 MB, 在所有 Java 提交中击败了55.10%的用户 */ public int[] intersect_3(int[] nums1, int[] nums2) { //首先对两个数组进行排序 Arrays.sort(nums1); Arrays.sort(nums2); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0, j = 0;i &lt; nums1.length &amp;&amp; j &lt; nums2.length;) { if (nums1[i] &gt; nums2[j]) { j++; } else if (nums1[i] &lt; nums2[j]) { i++; } else { list.add(nums1[i]); i++; j++; } } int[] res = new int[list.size()]; int i = 0; for (int value : list) { res[i++] = value; } return res; } Question69:判断一个数字是否为完全平方数题目描述： 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。 进阶：不要 使用任何内置的库函数，如 sqrt 。 题解： 方法一： 利用二分法 12345678910111213141516171819202122232425class Solution { public boolean isPerfectSquare(int num) { if(num == 1) { return true; } int low = 0; int high = num; while (low &lt;= high) { int mid = low + (high - low) / 2; //num == mid * mid 越界了 int t = num / mid; if (t == mid) { if(num % mid == 0) { return true; } low = mid + 1; } else if (t &gt; mid) { low = mid + 1; } else { high = mid - 1; } } return false; }} Question70:猜数字的大小题目描述： 猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick &lt; num 1：我选出的数字比你猜的数字大 pick &gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。 题解： 方法一：二分法 12345678910111213141516171819202122232425262728293031/** * Forward declaration of guess API. * @param num your guess * @return -1 if num is higher than the picked number * 1 if num is lower than the picked number * otherwise return 0 * int guess(int num); *//**执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户内存消耗：37.9 MB, 在所有 Java 提交中击败了97.94%的用户 */public class Solution extends GuessGame { public int guessNumber(int n) { int left = 0; int right = n; while (left &lt;= right) { int mid = left + (right - left) / 2; int guess = guess(mid); if (guess == 0){ return mid; } else if (guess == 1) { left = mid + 1; } else { right = mid - 1; } } return 0; }} Question71:卡车上的最大单元数题目描述： 请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] = [numberOfBoxes, numberOfUnitsPerBox] ： numberOfBoxes 是类型 i 的箱子的数量。 numberOfUnitsPerBox 是类型 i 每个箱子可以装载的单元数量。 整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。 返回卡车可以装载 单元 的 最大 总数。 题解： 分析： 先理解题目的意思：就是说要往卡车上装箱子，卡车可以容纳的箱子数量是一定的，但是每个箱子可以装的东西数目不一样，如何可以往卡车中装入最多的东西 思路就是把能装最多东西的箱子放上去，以此类推。 方法一： 12345678910111213141516171819202122232425262728293031323334/**执行用时：22 ms, 在所有 Java 提交中击败了15.88%的用户内存消耗：41.6 MB, 在所有 Java 提交中击败了81.10%的用户*/class Solution { public int maximumUnits(int[][] boxTypes, int truckSize) { int res = 0; while (truckSize &gt; 0) { int maxBox = 0;//寻找最大储货量 int numBox = 0;//存放出货量最大的箱子的数目 int index = 0; for (int i = 0; i &lt; boxTypes.length; i++) { if (boxTypes[i][1] &gt; maxBox) { index = i; numBox = boxTypes[i][0]; maxBox = boxTypes[i][1]; } } if (maxBox == 0) { break; } if (truckSize &gt; numBox) { res += (numBox * maxBox); truckSize -= numBox; boxTypes[index][1] = 0; } else { res += truckSize * maxBox; break; } } return res; }} 贪心算法： 123456789101112131415161718class Solution { public int maximumUnits(int[][] boxTypes, int truckSize) { Arrays.sort(boxTypes, (a, b) -&gt; b[1] - a[1]); int res = 0; for (int[] boxType : boxTypes) { int numberOfBoxes = boxType[0]; int numberOfUnitsPerBox = boxType[1]; if (numberOfBoxes &lt; truckSize) { res += numberOfBoxes * numberOfUnitsPerBox; truckSize -= numberOfBoxes; } else { res += truckSize * numberOfUnitsPerBox; break; } } return res; }} Question72:找到最高海拔题目描述： 有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。自行车手从海拔为 0 的点 0 开始骑行。 给你一个长度为 n 的整数数组 gain ，其中 gain[i] 是点 i 和点 i + 1 的净海拔高度差（0 &lt;= i &lt; n）。请你返回最高点的海拔 。 就是说在骑行过程中，自行车手有可能在上坡也有可能在下坡，找到他途径的最高的地方的海拔。 题解： 方法一： 创建一个数组，将所有途经的海拔都放进去 对数组进行排序，取出最大的数字 123456789public int largestAltitude(int[] gain) { int[] res = new int[gain.length + 1]; res[0] = 0; for(int i = 1; i &lt;= gain.length; i++) { res[i] = res[i-1] + gain[i-1]; } Arrays.sort(res); return res[gain.length]; } 复杂度过高，不予考虑 方法二： 对方法一的优化，不再创建数组来求 12345678910111213141516class Solution { /** 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：39.2 MB, 在所有 Java 提交中击败了45.39%的用户 */ public int largestAltitude(int[] gain) { int ans = 0, h = 0; for(int i = 0; i &lt; gain.length; i++) { h += gain[i]; ans = Math.max(ans,h); } return ans; }} Question73:找到所有数组中消失的数字题目描述： 给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。 题解： 个人思路当然是暴力法进行求解，不出所料会超时 官方解答： 首先，先取出现在的这个数字，减去1得到这个数字对应的下标 对这个下标对应的数字进行加n的操作 然后再遍历这个数组，其中数字小于n的就代表没有被操作过 这个下标+1即为未出现的数字 1234567891011121314151617181920212223/*执行用时：3 ms, 在所有 Java 提交中击败了99.63%的用户内存消耗：49.3 MB, 在所有 Java 提交中击败了66.35%的用户*/class Solution { public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int n = nums.length; //首先，先将出现的数字所对应的下标的数字加上n //为了防止当前数字已经实现了+n操作，下标溢出，因此进行取模操作 for(int num : nums) { int index = (num - 1) % n; nums[index] += n; } //将所有小于n的数字的下标+1加入到结果集之中即可 for(int i = 0; i &lt; n; i++) { if(nums[i] &lt;= n) { res.add(i+1); } } return res; }} Question74:汉明距离题目描述： 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。 给你两个整数 x 和 y，计算并返回它们之间的汉明距离。 题解： 方法一： 12345678910111213141516171819202122class Solution { /** 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：38.9 MB, 在所有 Java 提交中击败了5.15%的用户 */ public int hammingDistance(int x, int y) { //个人思路：可以先求两个数字&amp;之后的1的个数， //再求两个数字|之后的1的个数，用后者减去前者即可 int res1 = x &amp; y; int res2 = x | y; int count1 = 0; int count2 = 0; while(res1 != 0) { res1 &amp;= res1-1; count1++; } while(res2 != 0) { res2 &amp;= res2-1; count2++; } return count2 - count1; }} 方法二：内置函数法 12345class Solution { public int hammingDistance(int x, int y) { return Integer.bitCount(x ^ y); }} 方法三：改进的方法一 123456789101112131415/**执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户内存消耗：38.4 MB, 在所有 Java 提交中击败了49.04%的用户*/class Solution { public int hammingDistance(int x, int y) { int s = x ^ y, res = 0; while(s!=0) { s &amp;= s-1; res++; } return res; }} Charpter2-MidiumQuestion1:两数相加题目描述： 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 举例： 题解： 本题中等题目里面较容易地吧，就将两数相加来判断是否产生进位，产生进位的话就把进位的数字也加到下一次相加之中，最后判断是否产生进位，从而再创建一个新节点。最后返回头节点即可。 思路： 首先先判断当前节点是否为空，空则赋值为0 将当前两个链表对应的节点以及上一个链表节点的进位相加 如果最后一个节点也有进位产生，则再创建一个值为1的节点 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode head = null; ListNode tail = null; int carry = 0; while (l1 != null || l2 != null) { int num1 = l1 != null ? l1.val : 0; int num2 = l2 != null ? l2.val : 0; int sum = num1 + num2 + carry; if (head == null) { head = tail = new ListNode(sum % 10); } else { tail.next = new ListNode(sum % 10); tail = tail.next; } carry = sum / 10; if (l1 != null) { l1 = l1.next; } if (l2 != null) { l2 = l2.next; } } if (carry == 1) { tail.next = new ListNode(1); } return head; }} 分析：这种题一定不要转换为整数，然后相加之后在转换为链表。因为这样的题目一般long型都不够用的。 Question2:找无重复字母的最长子串题目描述： 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 题解： 方法一： 个人认为最简单的就是，采用双指针，不断更新长度即可。 先用一个set集合来存储已经出现的字符，并且大小作为最后的返回。 左指针不动，将右指针向右移，遇到重复的数字停下来，然后比较得到子串长度和现有的最长的做对比。 将左指针右移，并且将最左边的字符从set集合中取出。 12345678910111213141516171819class Solution { public int lengthOfLongestSubstring(String s) { Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int start = 0; int end = 0; int max = 0; while (end&lt;s.length()){ if (!set.contains(s.charAt(end))) { set.add(s.charAt(end)); end++; } else{ set.remove(s.charAt(start)); start++; } max = Math.max(set.size(),max); } return max; }} 方法二：（暂时还未理解） 1234567891011121314151617181920212223class Solution { public int lengthOfLongestSubstring(String s) { // 哈希集合，记录每个字符是否出现过 Set&lt;Character&gt; occ = new HashSet&lt;Character&gt;(); int n = s.length(); // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 int rk = -1, ans = 0; for (int i = 0; i &lt; n; ++i) { if (i != 0) { // 左指针向右移动一格，移除一个字符 occ.remove(s.charAt(i - 1)); } while (rk + 1 &lt; n &amp;&amp; !occ.contains(s.charAt(rk + 1))) { // 不断地移动右指针 occ.add(s.charAt(rk + 1)); ++rk; } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = Math.max(ans, rk - i + 1); } return ans; }} Question3:全局倒置与局部倒置题目描述： 给你一个长度为 n 的整数数组 nums，表示由范围 [0, n - 1] 内所有整数组成的一个排列。 全局倒置的数目等于满足下述条件不同下标对 (i, j) 的数目： 0 &lt;= i &lt; j &lt; n nums[i] &gt; nums[j] 局部倒置的数目等于满足下述条件的下标 i 的数目： 0 &lt;= i &lt; n - 1 nums[i] &gt; nums[i + 1] 当数组 nums 中全局倒置的数量等于局部倒置的数量时，返回 true；否则，返回 false 。 题解： 本题采用暴力解决的话会超出时间限制，哪怕只判断这个数组是否有非局部倒置 方法一： 1234567891011121314151617181920class Solution { /** 执行用时：1 ms, 在所有 Java 提交中击败了99.46%的用户 内存消耗：50.4 MB, 在所有 Java 提交中击败了79.89%的用户 */ public boolean isIdealPermutation(int[] nums) { int n = nums.length; int min = nums[n-1]; for (int i = n - 3; i &gt;= 0; i--) { if (nums[i] &gt; min) { return false; } min = Math.min(min,nums[i+1]); } return true; }} 方法二： 通过找规律可以发现，当前值要和下标相差小于等于1，不然一定会存在非局部倒置 12345678910class Solution { public boolean isIdealPermutation(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { if (Math.abs(nums[i] - i) &gt; 1) { return false; } } return true; }} Question4:匹配子序列的单词数题目描述： 给定字符串 s 和字符串数组 words, 返回 words[i] 中是s的子序列的单词个数 。 字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。 例如， “ace” 是 “abcde” 的子序列，但是“aec”就不是“abcde”的子序列 题解： 方法一： 创建一个List数组，里面存储26个数组，分别表示字符串s中每个字母在字符串中的位置 利用二分法来寻找字母在字母在字符串中的位置，如果这个字母不存在，或者它的位置比上一个字母的位置下标小，那么就会去掉这个。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/**执行用时：169 ms, 在所有 Java 提交中击败了20.79%的用户内存消耗：48.9 MB, 在所有 Java 提交中击败了45.95%的用户 */class Solution { public int numMatchingSubseq(String s, String[] words) { List&lt;Integer&gt;[] pos = new List[26]; for (int i = 0; i &lt; 26; ++i) { pos[i] = new ArrayList&lt;Integer&gt;(); } for (int i = 0; i &lt; s.length(); ++i) { pos[s.charAt(i) - 'a'].add(i); } int res = words.length; for (String w : words) { if (w.length() &gt; s.length()) { --res; continue; } int p = -1; for (int i = 0; i &lt; w.length(); ++i) { char c = w.charAt(i); if (pos[c - 'a'].isEmpty() || pos[c - 'a'].get(pos[c - 'a'].size() - 1) &lt;= p) { --res; break; } p = binarySearch(pos[c - 'a'], p); } } return res; } public int binarySearch(List&lt;Integer&gt; list, int target) { int left = 0, right = list.size() - 1; while (left &lt; right) { int mid = left + (right - left) / 2; if (list.get(mid) &gt; target) { right = mid; } else { left = mid + 1; } } return list.get(left); }} 方法二： ​ 在上述方法基础上进行优化，因为方法一中是每一个单词分别和字符串 s 进行匹配，这样对于每一次匹配都需要从头开始遍历字符串 s，这增加了额外的时间开销。所以我们考虑将字符串数组 words 中的全部字符串和字符串 s 同时进行匹配——同样对于每一个需要匹配的字符串我们用一个指针来指向它需要匹配的字符，那么在遍历字符串 s 的过程中，对于当前遍历到的字符如果有可以匹配的字符串，那么将对应的字符串指针往后移动一单位即可。那么当字符串 s 遍历结束时，字符串数组中全部字符串的匹配情况也就全部知道了。 123456789101112131415161718192021222324252627class Solution { public int numMatchingSubseq(String s, String[] words) { Queue&lt;int[]&gt;[] p = new Queue[26]; for (int i = 0; i &lt; 26; ++i) { p[i] = new ArrayDeque&lt;int[]&gt;(); } for (int i = 0; i &lt; words.length; ++i) { p[words[i].charAt(0) - 'a'].offer(new int[]{i, 0}); } int res = 0; for (int i = 0; i &lt; s.length(); ++i) { char c = s.charAt(i); int len = p[c - 'a'].size(); while (len &gt; 0) { int[] t = p[c - 'a'].poll(); if (t[1] == words[t[0]].length() - 1) { ++res; } else { ++t[1]; p[words[t[0]].charAt(t[1]) - 'a'].offer(t); } --len; } } return res; }} Question5:香槟塔题目描述： 我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。 从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上） 例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。 题解： 错误解答： 自己的想法是，我把这一层倒满之后，剩下的所有的去倒入下一层，所以我只需要考虑每一层的各个杯子所占的比重就可以了 错误原因：不是说这一层全满之后才会流向下一层，中间的杯子肯定先满，然后流向下一层，所以不能计算权重来求解 12345678910111213141516171819202122232425262728class Solution { public double champagneTower(int poured, int query_row, int query_glass) { //首先，如果上面的香槟没有满的话是不会继续向下流的 if((query_row+1)*query_row/2 &gt;= poured) { return 0.0; } int res = poured - (query_row+1)*query_row/2; double ans = curWeight(query_row,query_glass) * res; if(ans &gt; 1) { return 1.0; } return ans; } //写一个方法返回当前杯子的权重 public double curWeight(int row, int col) { double[][] weight = new double[row+1][row+1]; for (int i = 0; i &lt;= row; i++) { weight[i][0] = weight[i][i] = Math.pow(0.5,i); } for (int i = 2; i &lt;= row; i++){ for (int j = 1; j &lt; row; j++) { weight[i][j] = (weight[i-1][j-1]+weight[i-1][j])/2; } } return weight[row][col]; }} 正确解答： 实时更新每一层 123456789101112131415class Solution { public double champagneTower(int poured, int query_row, int query_glass) { double count[] = new double[]{(double)poured}; for(int i = 1; i &lt;= query_row; i++) { double arr[] = new double[i+1]; arr[0] = Math.max(0,count[0]-1)/2; arr[i] = Math.max(0,count[i-1]-1)/2; for(int j = 1; j &lt; i; j++) { arr[j] = (Math.max(0,count[j-1]-1) + Math.max(0,count[j]-1))/2; } count = arr; } return Math.min(1,count[query_glass]); }} Question6:分汤题目描述： 有 A 和 B 两种类型的汤。一开始每种类型的汤各有 n 毫升。有四种分配操作： 提供 100ml 的汤A 和 0ml 的汤B 。 提供 75ml 的汤A 和 25ml 的汤B 。 提供 50ml 的汤A 和 50ml 的汤B 。 提供 25ml 的汤A 和 75ml 的汤B 。 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。 注意不存在先分配 100 ml 汤B 的操作。 需要返回的值： 汤A 先分配完的概率 + 汤A和汤B 同时分配完的概率 / 2。返回值在正确答案 10-5 的范围内将被认为是正确的。 题解： 个人没什么思路，感觉要用递归来做，其实这个问题不是一个递归问题 由于分配的汤都是25的倍数，因此首先先除以25然后来进行后续的判断 当n&gt;179*25的时候，基本上都是A先分完，此时，让结果等于1即可 方法一： 12345678910111213141516171819class Solution { public double soupServings(int n) { n = (int) Math.ceil((double) n / 25); if (n &gt;= 179) { return 1.0; } double[][] dp = new double[n + 1][n + 1]; dp[0][0] = 0.5; for (int i = 1; i &lt;= n; i++) { dp[0][i] = 1.0; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { dp[i][j] = (dp[Math.max(0, i - 4)][j] + dp[Math.max(0, i - 3)][Math.max(0, j - 1)] + dp[Math.max(0, i - 2)][Math.max(0, j - 2)] + dp[Math.max(0, i - 1)][Math.max(0, j - 3)]) / 4.0; } } return dp[n][n]; }} 方法一的思想是动态规划，也就是自底向上，逐步进行求解 方法二： 由于方法一自底向上的方法，有着很多的资源浪费，因此，我们可以采取自顶向下的记忆化搜索方式来进行求解 123456789101112131415161718192021222324252627282930/**执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户内存消耗：38.4 MB, 在所有 Java 提交中击败了88.99%的用户*/class Solution { private double[][] memo; public double soupServings(int n) { n = (int) Math.ceil((double) n / 25); if (n &gt;= 179) { return 1.0; } memo = new double[n + 1][n + 1]; return dfs(n, n); } public double dfs(int a, int b) { if (a &lt;= 0 &amp;&amp; b &lt;= 0) { return 0.5; } else if (a &lt;= 0) { return 1; } else if (b &lt;= 0) { return 0; } if (memo[a][b] == 0) { memo[a][b] = 0.25 * (dfs(a - 4, b) + dfs(a - 3, b - 1) + dfs(a - 2, b - 2) + dfs(a - 1, b - 3)); } return memo[a][b]; }} Question7:最长回文子串题目描述： 给定一个字符串s，求字符串中的最长回文子串。 题解： 个人解法：（超时） 最简单的思路：遍历 123456789101112131415161718192021class Solution { public String longestPalindrome(String s) { int res = 0; String resStr = &quot;&quot;; for (int i = 0; i &lt; s.length(); i++) { for (int j = s.length(); j &gt;= i; j--) { String str1 = s.substring(i,j); StringBuilder sb1 = new StringBuilder(str1); StringBuilder sb2 = sb1.reverse(); if (str1.equals(String.valueOf(sb2))) { if (str1.length() &gt; res) { res = str1.length(); resStr = str1; } break; } } } return resStr; }} 超出时间限制啦！得想别的优化算法 方法一： 整体思路：动态规划 首先先判断长度小于等于2的字符串的回文子串情况 然后将长度从2开始递增，如果当前字符串首i尾j一致，那么它的情况就和i+1到j-1的子串的回文情况一致 最后记录最长字串和起始位置即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/**执行用时：115 ms, 在所有 Java 提交中击败了41.14%的用户内存消耗：44.5 MB, 在所有 Java 提交中击败了19.71%的用户 */public class Solution { public String longestPalindrome(String s) { int len = s.length(); if (len &lt; 2) { return s; } int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i..j] 是否是回文串 boolean[][] dp = new boolean[len][len]; // 初始化：所有长度为 1 的子串都是回文串 for (int i = 0; i &lt; len; i++) { dp[i][i] = true; } char[] charArray = s.toCharArray(); // 递推开始 // 先枚举子串长度 for (int L = 2; L &lt;= len; L++) { // 枚举左边界，左边界的上限设置可以宽松一些 for (int i = 0; i &lt; len; i++) { // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得 int j = L + i - 1; // 如果右边界越界，就可以退出当前循环 if (j &gt;= len) { break; } if (charArray[i] != charArray[j]) { dp[i][j] = false; } else { if (j - i &lt; 3) { dp[i][j] = true; } else { dp[i][j] = dp[i + 1][j - 1]; } } // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置 if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) { maxLen = j - i + 1; begin = i; } } } return s.substring(begin, begin + maxLen); }} 方法二：中心扩散算法 基于方法一的优化，我们可以找一个最小字串，让他从中心向两边扩散 1234567891011121314151617181920212223242526272829303132/**执行用时：16 ms, 在所有 Java 提交中击败了86.20%的用户内存消耗：41.5 MB, 在所有 Java 提交中击败了68.28%的用户 */public class Solution { public String longestPalindrome(String s) { if(s.length() &lt; 2) { return s; } int start = 0, end = 0; for(int i = 0; i &lt; s.length(); i++) { //分别代表奇数子串和偶数字串 int len1 = maxLength(s, i, i); int len2 = maxLength(s, i, i+1); int len = Math.max(len1,len2); if(len &gt; end-start) { end = i+len/2; start = i-(len-1)/2; } } return s.substring(start,end+1); } public int maxLength(String s, int left, int right){ while(left &gt;=0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) { --left; ++right; } return right - left - 1; }} 方法三：Manacher算法 暂未理解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { /** 执行用时：15 ms, 在所有 Java 提交中击败了88.65%的用户 内存消耗：41.6 MB, 在所有 Java 提交中击败了62.46%的用户 */ public String longestPalindrome(String s) { int start = 0, end = -1; StringBuffer t = new StringBuffer(&quot;#&quot;); for (int i = 0; i &lt; s.length(); ++i) { t.append(s.charAt(i)); t.append('#'); } t.append('#'); s = t.toString(); List&lt;Integer&gt; arm_len = new ArrayList&lt;Integer&gt;(); int right = -1, j = -1; for (int i = 0; i &lt; s.length(); ++i) { int cur_arm_len; if (right &gt;= i) { int i_sym = j * 2 - i; int min_arm_len = Math.min(arm_len.get(i_sym), right - i); cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len); } else { cur_arm_len = expand(s, i, i); } arm_len.add(cur_arm_len); if (i + cur_arm_len &gt; right) { j = i; right = i + cur_arm_len; } if (cur_arm_len * 2 + 1 &gt; end - start) { start = i - cur_arm_len; end = i + cur_arm_len; } } StringBuffer ans = new StringBuffer(); for (int i = start; i &lt;= end; ++i) { if (s.charAt(i) != '#') { ans.append(s.charAt(i)); } } return ans.toString(); } public int expand(String s, int left, int right) { while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) { --left; ++right; } return (right - left - 2) / 2; }} Question8:区间子数组的个数题目描述： 给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。 题解： 1234567891011121314151617181920212223class Solution { /** 执行用时：3 ms, 在所有 Java 提交中击败了90.06%的用户 内存消耗：49.1 MB, 在所有 Java 提交中击败了28.62%的用户 */ public int numSubarrayBoundedMax(int[] nums, int left, int right) { return subarrayBoundedMax(nums,right) - subarrayBoundedMax(nums,left-1); } private int subarrayBoundedMax(int[] num, int MAX) { int res = 0; int resBounded = 0; for(int i = 0; i &lt; num.length; i++) { if(num[i] &lt;= MAX) { resBounded++; res+=resBounded; } else { resBounded = 0; } } return res; }} Question9:情感丰富的单词题目描述： 有时候人们会用重复写一些字母来表示额外的感受，比如 “hello” -&gt; “heeellooo”, “hi” -&gt; “hiii”。我们将相邻字母都相同的一串字符定义为相同字母组，例如：”h”, “eee”, “ll”, “ooo”。 对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 c ），然后往其中添加相同的字母 c 使其长度达到 3 或以上。 例如，以 “hello” 为例，我们可以对字母组 “o” 扩张得到 “hellooo”，但是无法以同样的方法得到 “helloo” 因为字母组 “oo” 长度小于 3。此外，我们可以进行另一种扩张 “ll” -&gt; “lllll” 以获得 “helllllooo”。如果 S = “helllllooo”，那么查询词 “hello” 是可扩张的，因为可以对它执行这两种扩张操作使得 query = “hello” -&gt; “hellooo” -&gt; “helllllooo” = S。 输入一组查询单词，输出其中可扩张的单词数量。 题意解析： 就是说，首先给定一个字符串数组words，然后给定一个字符串s，然后逐一判断words中的字符串是否可以通过扩展变成s；返回可以变成s的字符串的个数。 扩展规则：扩展之后这个字母的次数必须大于等于3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { /** 执行用时：1 ms, 在所有 Java 提交中击败了97.85%的用户 内存消耗：39.4 MB, 在所有 Java 提交中击败了98.39%的用户 */ public int expressiveWords(String s, String[] words) { int res = 0; for(String word : words) { if(isExpressiveWord(word,s)) { res++; } } return res; } /** * 先写一个函数用来判断是否为这类字符串 * @param s 扩展前的字符串 * @param t 扩展后的字符串 * @return 如果t是s扩展后的字符串，返回true */ private boolean isExpressiveWord(String s, String t) { int i = 0, j = 0;//创建两个指针，分别用来遍历s和t while (i &lt; s.length() &amp;&amp; j &lt; t.length()) { if (s.charAt(i) != t.charAt(j)) { return false; } int cnti = 0, cntj = 0; char ch = s.charAt(i); while (i &lt; s.length() &amp;&amp; s.charAt(i) == ch) { ++i; ++cnti; } while (j &lt; t.length() &amp;&amp; t.charAt(j) == ch) { ++j; ++cntj; } if (cntj &lt; cnti) { return false; } if (cnti != cntj &amp;&amp; cntj &lt; 3) { return false; } } return i==s.length() &amp;&amp; j==t.length(); }} Question10:寻找盛水最多的容器题目描述： 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 题解： 方法一： 思路是创建一个双指针 一个指针指向最左边，一个指针指向最右边 哪边的高度比较低，就把哪边的向中心移动，以求获取最大的高度，从而获得最大的容积 12345678910111213141516171819class Solution { /** 执行用时：4 ms, 在所有 Java 提交中击败了59.85%的用户 内存消耗：51.2 MB, 在所有 Java 提交中击败了89.00%的用户 */ public int maxArea(int[] height) { int res = 0; int left = 0; int right = height.length-1; while(left &lt; right) { res = Math.max(res,(right-left)*Math.min(height[left],height[right])); if(height[left] &lt; height[right]){ left++; } else { right--; } } return res; }} Question11:三数之和题目描述： 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 题解： 首先，本题第一反应还是使用循环来做暴力求解，这样的话所有的数字都要遍历三遍，复杂度为O(N3)，复杂度较高，影响性能。 想要降低复杂度到O(N2)，需要使用双指针；先将数组进行排序，然后一个指针指向头部，一个指针指向尾部，对中间的数字进行遍历，相关注释加到代码里 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { /** 执行用时：20 ms, 在所有 Java 提交中击败了76.56%的用户 内存消耗：45.8 MB, 在所有 Java 提交中击败了31.97%的用户 */ public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { //创建最终的返回集合 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //先对数组进行排序 Arrays.sort(nums); int n = nums.length; for (int first = 0; first &lt; n; first++) { //保证下一个数字和上一个数字不一样 if (first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) { continue; } int third = n - 1; int target = -nums[first]; for (int second = first+1; second &lt; n; second++) { //保证数字和上一个不一样 if (second &gt; first+1 &amp;&amp; nums[second] == nums[second-1]){ continue; } //如果二者加和大于了目标值，就需要将最后一个数字向左移动 while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) { third--; } //当两个指针重合，就不需要再继续了，直接break if (second == third) { break; } //满足要求的添加到数组之中 if (nums[second] + nums[third] == target) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[first]); list.add(nums[second]); list.add(nums[third]); res.add(list); } } } return res; }} Question12:电话号码中的字母组合题目描述： 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 题解： 分析一下，对于这道题，我们肯定是想要先看有几个数字，如果是两个数字，比如23，那么就利用双层循环就可以获取到所有的值。如果是三个数字234，那么就使用三层循环获取所有的排列组合。 但是在写的时候就会发现，根据数字的个数写几层循环代码上不可实现。 因此本题我们需要用回溯算法 回溯算法 回溯算法其实说白了就是平时所说的试试看的想法，先试试，可以的话就返回，不可以的话就回来再试。第一次接触应该是在数据结构课上的八皇后问题。先将一个皇后放在这个位置，然后放下一个皇后，直到下一个皇后没法放的时候，进行回溯，来改变上一个皇后的位置；如果还是无解，就再向上回溯，直到第一个皇后。其思想类似于枚举法，就是将所有的情况都做枚举。 使用回溯法解决问题的过程，实际上是建立一棵“状态树”的过程。例如，在解决列举集合{1,2,3}所有子集的问题中，对于每个元素，都有两种状态，取还是舍，所以构建的状态树为： 回溯算法的求解过程实质上是先序遍历“状态树”的过程。树中每一个叶子结点，都有可能是问题的答案。图 1 中的状态树是满二叉树，得到的叶子结点全部都是问题的解。 123456789101112131415161718192021222324252627282930313233343536373839class Solution { /** 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：39.9 MB, 在所有 Java 提交中击败了72.58%的用户 */ public List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; combinations = new ArrayList&lt;&gt;(); if (digits.length() == 0) { return combinations; } Map&lt;Character,String&gt; map = new HashMap&lt;&gt;(); map.put('2',&quot;abc&quot;); map.put('3',&quot;def&quot;); map.put('4',&quot;ghi&quot;); map.put('5',&quot;jkl&quot;); map.put('6',&quot;mno&quot;); map.put('7',&quot;pqrs&quot;); map.put('8',&quot;tuv&quot;); map.put('9',&quot;wxyz&quot;); //回溯算法 backTrack(combinations,new StringBuffer(),0,digits,map); return combinations; } public void backTrack(List&lt;String&gt; combinations, StringBuffer combination, int index, String digits, Map&lt;Character, String&gt; map){ if (index == digits.length()) { combinations.add(combination.toString()); } else { char str = digits.charAt(index); String letters = map.get(str); int len = letters.length(); for (int i = 0; i &lt; len; i++) { combination.append(letters.charAt(i)); backTrack(combinations,combination,index+1,digits,map); combination.deleteCharAt(index); } } }} Question13:删除链表中倒数第N个节点题目描述： 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 题解： 方法一：普通方法 先找到链表中节点的个数 然后进行遍历，到正数第sum-n的地方进行操作即可 12345678910111213141516171819202122232425262728293031323334class Solution { /** 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：40.1 MB, 在所有 Java 提交中击败了5.11%的用户 */ public ListNode removeNthFromEnd(ListNode head, int n) { //删除链表中的倒数第n个节点 //先统计一共有几个节点 int sum = 0; ListNode cur = head; while (cur != null) { sum++; cur = cur.next; } //如果n大于个数，就return null if (n &gt; sum || sum==1) { return null; } //如果第一个节点是要删除的节点 if(sum == n) { return head.next; } ListNode temp = head; int count = 0; while (temp != null) { count++; if (count == sum-n) { temp.next = temp.next.next; break; } temp = temp.next; } return head; }} 方法二：使用栈 将所有的链表节点加入到栈中 将栈中的数据取出n-1个 返回栈顶元素，也就是要删除节点的前一个节点 进行删除操作即可 12345678910111213141516public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0, head); Deque&lt;ListNode&gt; stack = new LinkedList&lt;ListNode&gt;(); ListNode cur = dummy; while (cur != null) { stack.push(cur); cur = cur.next; } for (int i = 0; i &lt; n; i++) { stack.pop(); } ListNode prev = stack.peek(); prev.next = prev.next.next; ListNode ans = dummy.next; return ans;} 方法三：双指针 我们也可以在不预处理出链表的长度，以及使用常数空间的前提下解决本题。 由于我们需要找到倒数第 n 个节点，因此我们可以使用两个指针first 和 second 同时对链表进行遍历，并且first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。 具体地，初始时 first 和 second 均指向头节点。我们首先使用 first 对链表进行遍历，遍历的次数为 n。此时，first 和 second 之间间隔了 n-1 个节点，即 first 比 second 超前了 n 个节点。 在这之后，我们同时使用 first 和 second 对链表进行遍历。当 first 遍历到链表的末尾（即 first 为空指针）时，second 恰好指向倒数第 n 个节点。 根据方法一和方法二，如果我们能够得到的是倒数第 n 个节点的前驱节点而不是倒数第 n 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 second 指向哑节点，其余的操作步骤不变。这样一来，当 first 遍历到链表的末尾时，second 的下一个节点就是我们需要删除的节点。 1234567891011121314151617class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0, head); ListNode first = head; ListNode second = dummy; for (int i = 0; i &lt; n; ++i) { first = first.next; } while (first != null) { first = first.next; second = second.next; } second.next = second.next.next; ListNode ans = dummy.next; return ans; }} Question14:括号的生成题目描述： 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 注意不可以产生交叉的括号 题解： 方法一：暴力求解 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public List&lt;String&gt; generateParenthesis(int n) { //方法一：暴力法求解 /** 整体思路就是，将所有的可能的情况列举出来，然后再进行判断是否可行 执行用时：2 ms, 在所有 Java 提交中击败了25.13%的用户 内存消耗：41.6 MB, 在所有 Java 提交中击败了34.94%的用户 */ List&lt;String&gt; res = new ArrayList&lt;&gt;(); generateAll(new char[2*n],0,res); return res; } //生成最后返回的序列 public void generateAll(char[] current, int pos, List&lt;String&gt; result){ //在遍历到最后的位置的时候进行判断并添加到结果集 if(pos == current.length) { if(isValid(current)){ result.add(new String(current)); } } else { //进行递归遍历 current[pos] = '('; generateAll(current,pos+1,result); current[pos] = ')'; generateAll(current,pos+1,result); } } //判断是否有效的函数 public boolean isValid(char[] current){ int balance = 0; for(char c : current) { if(c == '(') { balance += 1; } else { balance -= 1; } if(balance &lt; 0) { return false; } } return balance == 0; }} 方法二：回溯法 相当于方法一的拓展，只有在序列还有效的时候进行加左括号或者右括号的操作 如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。 123456789101112131415161718192021222324class Solution { public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; ans = new ArrayList&lt;String&gt;(); backtrack(ans, new StringBuilder(), 0, 0, n); return ans; } public void backtrack(List&lt;String&gt; ans, StringBuilder cur, int open, int close, int max) { if (cur.length() == max * 2) { ans.add(cur.toString()); return; } if (open &lt; max) { cur.append('('); backtrack(ans, cur, open + 1, close, max); cur.deleteCharAt(cur.length() - 1); } if (close &lt; open) { cur.append(')'); backtrack(ans, cur, open, close + 1, max); cur.deleteCharAt(cur.length() - 1); } }} 方法三：递归法 剩余左括号总数要小于等于右括号，递归把所有符合要求的加上去就行了 1234567891011121314151617181920212223242526272829303132333435class Solution { /** 执行用时：1 ms, 在所有 Java 提交中击败了76.13%的用户 内存消耗：41.3 MB, 在所有 Java 提交中击败了78.55%的用户 */ List&lt;String&gt; res = new ArrayList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) { if(n &lt;= 0) { return res; } generateAll(&quot;&quot;,n,n); return res; } /** 生成最后返回的序列 left:左括号剩余的数量 right:右括号剩余的数量 */ public void generateAll(String str, int left, int right){ if(left == 0 &amp;&amp; right == 0) { res.add(str); return; } if(left == right) { //数量相等的时候，只能加入左括号 generateAll(str+&quot;(&quot; , left-1,right); } else if (left &lt; right) { //剩余左括号小于右括号的时候，下一个既可以是左括号也可以是右括号 if(left &gt; 0) { generateAll(str+&quot;(&quot;,left-1,right); } generateAll(str+&quot;)&quot;,left,right-1); } }} Question15:下一个排列题目描述： 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 下一个排列就是指的按照排列所得的大小进行排序，然后取出本个组合的下一个序列。 题解： 思路： 以[4,5,2,6,3,1] 为例 先找到要反转的位置，也就是找到前一位小于后一位这个位置也就是nums[i]=2 设置另一个指针，从后面的数中找出略大于上面位置的数字nums[j]=3 将nums[i]和nums[j]进行调换位置，之后再对nums[i]后面的位置进行反转即可(从最大反转到最小) 12345678910111213141516171819202122232425262728293031323334class Solution { /** 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：41.9 MB, 在所有 Java 提交中击败了35.21%的用户 */ public void nextPermutation(int[] nums) { int i = nums.length - 2; while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) { i--; } if (i &gt;= 0) { int j = nums.length - 1; while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) { j--; } swap(nums, i, j); } reverse(nums, i + 1); } public void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } public void reverse(int[] nums, int start) { int left = start, right = nums.length - 1; while (left &lt; right) { swap(nums, left, right); left++; right--; } }} Question16:搜索旋转排序数组题目描述： 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 题解： 本题主要是在非完全有序数组中利用二分法的思想。 分析：首先二分法是针对有序数组的一种查找条件，就是从数组中间一分为二进行查找。但是本体在将数组进行一分为二的时候，，分开的左右数组必有一个是有序数组，另一个是部分有序数组，因此采取以下思路 算法设计： 利用二分法将数组一分为二，并且判断左右哪一段为有序数组，判断方法：如果nums[mid] &lt; nums[right]那么右边的数组有序；如果nums[mid] &gt; nums[left]那么左边的数组有序； 如果左边的数组有序，那么判断target是否位于左边数组中，位于则right=mid-1，否则left=mid+1 若未找到数字，返回-1 12345678910111213141516171819202122232425262728293031class Solution { /** 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗：40.9 MB, 在所有 Java 提交中击败了69.04%的用户 */ public int search(int[] nums, int target) { int len = nums.length;; int left = 0; int right = len - 1; while (left &lt;= right) { int mid = (left + right) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] &gt;= nums[left]) { if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) { right = mid - 1; } else { left = mid + 1; } } else { if (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) { left = mid + 1; } else { right = mid - 1; } } } return -1; }} Question17：有序数组中查找元素的第一和最后位置题目描述： 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 题解： 解题思路： 本题使用二分法，最好是将查找左边界与查找右边界分开，这样不容易出错。 以查找右边界为例： 首先按照二分法获取当前区间的中间(left+right) / 2，判断下标对应的数字是否大于目标数字 如果大于目标数，则right = middle - 1 否则left = middle + 1；rightBorder = left 循环执行，最终得到右边界+1的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { public int[] searchRange(int[] nums, int target) { int leftBorder = getLeftBorder(nums,target); int rightBorder = getRightBorder(nums,target); if (leftBorder == -2 || rightBorder == -2) { return new int[]{-1,-1}; } if (rightBorder - leftBorder &gt; 1) { return new int[]{leftBorder+1,rightBorder-1}; } return new int[]{-1,-1}; } /** 用来获取数组的右边界 */ public int getRightBorder(int[] nums, int target) { int left = 0; int right = nums.length - 1; int rightBorder = -2; while(left &lt;= right) { int middle = left + (right - left) / 2; if(nums[middle] &gt; target) { right = middle - 1; } else { left = middle + 1; rightBorder = left; } } return rightBorder; } /** 用来获取数组的左边界 */ public int getLeftBorder(int[] nums, int target) { int left = 0; int right = nums.length - 1; int leftBorder = -2; while(left &lt;= right) { int middle = left + (right - left) / 2; if(nums[middle] &lt; target) { left = middle + 1; } else { right = middle - 1; leftBorder = right; } } return leftBorder; }} Chapter3:HardQuestion1:子序列宽度之和题目描述： 一个序列的宽度 定义为该序列中最大元素和最小元素的差值。 给你一个整数数组 nums ，返回 nums 的所有非空子序列的宽度之和。由于答案可能非常大，请返回对 1000000007 取余后的结果。 子序列定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。 题解： 数学法： 1234567891011121314151617/**执行用时：34 ms, 在所有 Java 提交中击败了94.74%的用户内存消耗：48.7 MB, 在所有 Java 提交中击败了98.68%的用户 */class Solution { public int sumSubseqWidths(int[] nums) { final int MOD = 1000000007; Arrays.sort(nums); long res = 0; long x = nums[0], y=2; for(int j = 1; j &lt; nums.length; j++) { res = (res + nums[j]*(y-1) - x) % MOD; x = (2*x+nums[j]) % MOD; y = (2 * y) % MOD; } return (int)res; }} Question2:第N个神奇数字题目描述： 一个正整数如果能被 a 或 b 整除，那么它是神奇的。 给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。 我再来解读一下题目想要表达的意思：就是除a或者除b能除开的数字就是神奇的数，我们现在要寻找第N个能除开他们的数 题解： 思路：其实本题很简单，就是取一个并集再减去交集即可；也就是说。除以a可以除开的数和除以b可以除开的数，必有重复，把重复的数字去除即可。 首先寻找到a和b的最小公倍数 利用公式$$f(x)=[x/a]+[x/b]+[x/c]$$ x即为第x个数 12345678910111213141516171819202122class Solution { static final int mod=1000000007; public int nthMagicalNumber(int n, int a, int b) { long l=Math.min(a,b),r=(long)n*Math.min(a,b);//这样的话一定至少有n个数 int c = a * b / gcd(a,b);//c即为最小公倍数 while (l &lt;= r) { long mid = (r+l) / 2; long count = mid / a + mid / b - mid / c;//分析中的公式 if (count &gt;= n) {//包含等于n的情况，多减了1，因此返回时加上1 r = mid - 1; } else { l = mid + 1; } } return (int) ((r+1) % mod); } //首先写一个方法寻找两个数中的最小公约数 public int gcd(int a, int b) { return a&lt;b ? gcd(b,a) : ((a%b==0)?b : gcd(b,a%b)); }} 找规律的方法见力扣官方解答","link":"/2022/11/14/LeetCode/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Java_Project","slug":"Java-Project","link":"/tags/Java-Project/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"About me","text":"This is a detailed self-introduction about the blogger.","link":"/about/index.html"},{"title":"Write down what you want to say","text":"","link":"/guestbook/index.html"}]}